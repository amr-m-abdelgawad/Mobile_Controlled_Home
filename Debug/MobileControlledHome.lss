
MobileControlledHome.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004402  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000003c  00800060  00004402  00004496  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000005ca  0080009c  0080009c  000044d2  2**0
                  ALLOC
  3 .stab         000077ac  00000000  00000000  000044d4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004602  00000000  00000000  0000bc80  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 58 0d 	jmp	0x1ab0	; 0x1ab0 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 cb 1f 	jmp	0x3f96	; 0x3f96 <__vector_13>
      38:	0c 94 fe 1f 	jmp	0x3ffc	; 0x3ffc <__vector_14>
      3c:	0c 94 31 20 	jmp	0x4062	; 0x4062 <__vector_15>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e0       	ldi	r30, 0x02	; 2
      68:	f4 e4       	ldi	r31, 0x44	; 68
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 39       	cpi	r26, 0x9C	; 156
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	ac e9       	ldi	r26, 0x9C	; 156
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 36       	cpi	r26, 0x66	; 102
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 92 02 	call	0x524	; 0x524 <main>
      8a:	0c 94 ff 21 	jmp	0x43fe	; 0x43fe <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Actuator_Control>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <Actuator_Control+0x6>
      98:	0f 92       	push	r0
      9a:	cd b7       	in	r28, 0x3d	; 61
      9c:	de b7       	in	r29, 0x3e	; 62
      9e:	9b 83       	std	Y+3, r25	; 0x03
      a0:	8a 83       	std	Y+2, r24	; 0x02
      a2:	80 91 a0 05 	lds	r24, 0x05A0
      a6:	90 91 a1 05 	lds	r25, 0x05A1
      aa:	60 e0       	ldi	r22, 0x00	; 0
      ac:	70 e0       	ldi	r23, 0x00	; 0
      ae:	40 e0       	ldi	r20, 0x00	; 0
      b0:	50 e0       	ldi	r21, 0x00	; 0
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	0e 94 0e 0f 	call	0x1e1c	; 0x1e1c <xQueueGenericReceive>
      b8:	89 83       	std	Y+1, r24	; 0x01
      ba:	89 81       	ldd	r24, Y+1	; 0x01
      bc:	81 30       	cpi	r24, 0x01	; 1
      be:	a1 f5       	brne	.+104    	; 0x128 <Actuator_Control+0x96>
      c0:	80 91 85 05 	lds	r24, 0x0585
      c4:	86 30       	cpi	r24, 0x06	; 6
      c6:	51 f4       	brne	.+20     	; 0xdc <Actuator_Control+0x4a>
      c8:	80 91 86 05 	lds	r24, 0x0586
      cc:	81 30       	cpi	r24, 0x01	; 1
      ce:	19 f4       	brne	.+6      	; 0xd6 <Actuator_Control+0x44>
      d0:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DoorLock_On>
      d4:	1e c0       	rjmp	.+60     	; 0x112 <Actuator_Control+0x80>
      d6:	0e 94 df 00 	call	0x1be	; 0x1be <DoorLock_Off>
      da:	1b c0       	rjmp	.+54     	; 0x112 <Actuator_Control+0x80>
      dc:	80 91 85 05 	lds	r24, 0x0585
      e0:	87 30       	cpi	r24, 0x07	; 7
      e2:	51 f4       	brne	.+20     	; 0xf8 <Actuator_Control+0x66>
      e4:	80 91 86 05 	lds	r24, 0x0586
      e8:	81 30       	cpi	r24, 0x01	; 1
      ea:	19 f4       	brne	.+6      	; 0xf2 <Actuator_Control+0x60>
      ec:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <Room1Light_On>
      f0:	10 c0       	rjmp	.+32     	; 0x112 <Actuator_Control+0x80>
      f2:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <Room1Light_Off>
      f6:	0d c0       	rjmp	.+26     	; 0x112 <Actuator_Control+0x80>
      f8:	80 91 85 05 	lds	r24, 0x0585
      fc:	88 30       	cpi	r24, 0x08	; 8
      fe:	49 f4       	brne	.+18     	; 0x112 <Actuator_Control+0x80>
     100:	80 91 86 05 	lds	r24, 0x0586
     104:	81 30       	cpi	r24, 0x01	; 1
     106:	19 f4       	brne	.+6      	; 0x10e <Actuator_Control+0x7c>
     108:	0e 94 06 01 	call	0x20c	; 0x20c <Room2Light_On>
     10c:	02 c0       	rjmp	.+4      	; 0x112 <Actuator_Control+0x80>
     10e:	0e 94 13 01 	call	0x226	; 0x226 <Room2Light_Off>
     112:	80 91 9c 05 	lds	r24, 0x059C
     116:	90 91 9d 05 	lds	r25, 0x059D
     11a:	60 e0       	ldi	r22, 0x00	; 0
     11c:	70 e0       	ldi	r23, 0x00	; 0
     11e:	40 e0       	ldi	r20, 0x00	; 0
     120:	50 e0       	ldi	r21, 0x00	; 0
     122:	20 e0       	ldi	r18, 0x00	; 0
     124:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xQueueGenericSend>
     128:	83 e0       	ldi	r24, 0x03	; 3
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	0e 94 bf 13 	call	0x277e	; 0x277e <vTaskDelay>
     130:	b8 cf       	rjmp	.-144    	; 0xa2 <Actuator_Control+0x10>

00000132 <Actuators_Init>:
/* =======================================================================
 * 	@ Func  	 - Actuators_Init
 * 	@ Brief 	 - Initialize Actuators according to the specified configuration.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void Actuators_Init(void) {
     132:	df 93       	push	r29
     134:	cf 93       	push	r28
     136:	cd b7       	in	r28, 0x3d	; 61
     138:	de b7       	in	r29, 0x3e	; 62

	// Initialize Siren Alarm Relay
	HAL_Relay_Init(Siren_Alarm_Relay);
     13a:	80 91 9c 00 	lds	r24, 0x009C
     13e:	90 91 9d 00 	lds	r25, 0x009D
     142:	0e 94 1b 21 	call	0x4236	; 0x4236 <HAL_Relay_Init>

	// Initialize Door Lock Relay
	HAL_Relay_Init(Door_Lock_Relay);
     146:	80 91 65 00 	lds	r24, 0x0065
     14a:	90 91 66 00 	lds	r25, 0x0066
     14e:	0e 94 1b 21 	call	0x4236	; 0x4236 <HAL_Relay_Init>

	// Initialize Room 1 Light Relay
	HAL_Relay_Init(Room1_Light_Relay);
     152:	80 91 67 00 	lds	r24, 0x0067
     156:	90 91 68 00 	lds	r25, 0x0068
     15a:	0e 94 1b 21 	call	0x4236	; 0x4236 <HAL_Relay_Init>

	// Initialize Room 2 Light Relay
	HAL_Relay_Init(Room2_Light_Relay);
     15e:	80 91 69 00 	lds	r24, 0x0069
     162:	90 91 6a 00 	lds	r25, 0x006A
     166:	0e 94 1b 21 	call	0x4236	; 0x4236 <HAL_Relay_Init>

}
     16a:	cf 91       	pop	r28
     16c:	df 91       	pop	r29
     16e:	08 95       	ret

00000170 <SirenAlarm_On>:
/* =======================================================================
 * 	@ Func  	 - SirenAlarm_On
 * 	@ Brief 	 - Turn On Siren Alarm.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void SirenAlarm_On(void) { HAL_Relay_On(Siren_Alarm_Relay); }
     170:	df 93       	push	r29
     172:	cf 93       	push	r28
     174:	cd b7       	in	r28, 0x3d	; 61
     176:	de b7       	in	r29, 0x3e	; 62
     178:	80 91 9c 00 	lds	r24, 0x009C
     17c:	90 91 9d 00 	lds	r25, 0x009D
     180:	0e 94 3a 21 	call	0x4274	; 0x4274 <HAL_Relay_On>
     184:	cf 91       	pop	r28
     186:	df 91       	pop	r29
     188:	08 95       	ret

0000018a <SirenAlarm_Off>:
/* =======================================================================
 * 	@ Func  	 - SirenAlarm_Off
 * 	@ Brief 	 - Turn Off Siren Alarm.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void SirenAlarm_Off(void) { HAL_Relay_Off(Siren_Alarm_Relay); }
     18a:	df 93       	push	r29
     18c:	cf 93       	push	r28
     18e:	cd b7       	in	r28, 0x3d	; 61
     190:	de b7       	in	r29, 0x3e	; 62
     192:	80 91 9c 00 	lds	r24, 0x009C
     196:	90 91 9d 00 	lds	r25, 0x009D
     19a:	0e 94 61 21 	call	0x42c2	; 0x42c2 <HAL_Relay_Off>
     19e:	cf 91       	pop	r28
     1a0:	df 91       	pop	r29
     1a2:	08 95       	ret

000001a4 <DoorLock_On>:
/* =======================================================================
 * 	@ Func  	 - DoorLock_On
 * 	@ Brief 	 - Turn On Door Lock.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void DoorLock_On(void) { HAL_Relay_On(Door_Lock_Relay); }
     1a4:	df 93       	push	r29
     1a6:	cf 93       	push	r28
     1a8:	cd b7       	in	r28, 0x3d	; 61
     1aa:	de b7       	in	r29, 0x3e	; 62
     1ac:	80 91 65 00 	lds	r24, 0x0065
     1b0:	90 91 66 00 	lds	r25, 0x0066
     1b4:	0e 94 3a 21 	call	0x4274	; 0x4274 <HAL_Relay_On>
     1b8:	cf 91       	pop	r28
     1ba:	df 91       	pop	r29
     1bc:	08 95       	ret

000001be <DoorLock_Off>:
/* =======================================================================
 * 	@ Func  	 - DoorLock_Off
 * 	@ Brief 	 - Turn Off Door Lock.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void DoorLock_Off(void) { HAL_Relay_Off(Door_Lock_Relay); }
     1be:	df 93       	push	r29
     1c0:	cf 93       	push	r28
     1c2:	cd b7       	in	r28, 0x3d	; 61
     1c4:	de b7       	in	r29, 0x3e	; 62
     1c6:	80 91 65 00 	lds	r24, 0x0065
     1ca:	90 91 66 00 	lds	r25, 0x0066
     1ce:	0e 94 61 21 	call	0x42c2	; 0x42c2 <HAL_Relay_Off>
     1d2:	cf 91       	pop	r28
     1d4:	df 91       	pop	r29
     1d6:	08 95       	ret

000001d8 <Room1Light_On>:
/* =======================================================================
 * 	@ Func  	 - Room1Light_On
 * 	@ Brief 	 - Turn On Room 1 Light.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void Room1Light_On(void) { HAL_Relay_On(Room1_Light_Relay); }
     1d8:	df 93       	push	r29
     1da:	cf 93       	push	r28
     1dc:	cd b7       	in	r28, 0x3d	; 61
     1de:	de b7       	in	r29, 0x3e	; 62
     1e0:	80 91 67 00 	lds	r24, 0x0067
     1e4:	90 91 68 00 	lds	r25, 0x0068
     1e8:	0e 94 3a 21 	call	0x4274	; 0x4274 <HAL_Relay_On>
     1ec:	cf 91       	pop	r28
     1ee:	df 91       	pop	r29
     1f0:	08 95       	ret

000001f2 <Room1Light_Off>:
/* =======================================================================
 * 	@ Func  	 - Room1Light_Off
 * 	@ Brief 	 - Turn Off Room 1 Light.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void Room1Light_Off(void) { HAL_Relay_Off(Room1_Light_Relay); }
     1f2:	df 93       	push	r29
     1f4:	cf 93       	push	r28
     1f6:	cd b7       	in	r28, 0x3d	; 61
     1f8:	de b7       	in	r29, 0x3e	; 62
     1fa:	80 91 67 00 	lds	r24, 0x0067
     1fe:	90 91 68 00 	lds	r25, 0x0068
     202:	0e 94 61 21 	call	0x42c2	; 0x42c2 <HAL_Relay_Off>
     206:	cf 91       	pop	r28
     208:	df 91       	pop	r29
     20a:	08 95       	ret

0000020c <Room2Light_On>:
/* =======================================================================
 * 	@ Func  	 - Room2Light_On
 * 	@ Brief 	 - Turn On Room 2 Light.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void Room2Light_On(void) { HAL_Relay_On(Room2_Light_Relay); }
     20c:	df 93       	push	r29
     20e:	cf 93       	push	r28
     210:	cd b7       	in	r28, 0x3d	; 61
     212:	de b7       	in	r29, 0x3e	; 62
     214:	80 91 69 00 	lds	r24, 0x0069
     218:	90 91 6a 00 	lds	r25, 0x006A
     21c:	0e 94 3a 21 	call	0x4274	; 0x4274 <HAL_Relay_On>
     220:	cf 91       	pop	r28
     222:	df 91       	pop	r29
     224:	08 95       	ret

00000226 <Room2Light_Off>:
/* =======================================================================
 * 	@ Func  	 - Room2Light_Off
 * 	@ Brief 	 - Turn Off Room 2 Light.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void Room2Light_Off(void) { HAL_Relay_Off(Room2_Light_Relay); }
     226:	df 93       	push	r29
     228:	cf 93       	push	r28
     22a:	cd b7       	in	r28, 0x3d	; 61
     22c:	de b7       	in	r29, 0x3e	; 62
     22e:	80 91 69 00 	lds	r24, 0x0069
     232:	90 91 6a 00 	lds	r25, 0x006A
     236:	0e 94 61 21 	call	0x42c2	; 0x42c2 <HAL_Relay_Off>
     23a:	cf 91       	pop	r28
     23c:	df 91       	pop	r29
     23e:	08 95       	ret

00000240 <Bluetooth_Receive>:
 * 	@ Func  	 - Bluetooth_Receive
 * 	@ Brief 	 - Receiving data from bluetooth task.
 * 	@ Param [in] - pvParameter: Pointer to task input parameters.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void Bluetooth_Receive(void*pvParameter){
     240:	df 93       	push	r29
     242:	cf 93       	push	r28
     244:	00 d0       	rcall	.+0      	; 0x246 <Bluetooth_Receive+0x6>
     246:	00 d0       	rcall	.+0      	; 0x248 <Bluetooth_Receive+0x8>
     248:	cd b7       	in	r28, 0x3d	; 61
     24a:	de b7       	in	r29, 0x3e	; 62
     24c:	9c 83       	std	Y+4, r25	; 0x04
     24e:	8b 83       	std	Y+3, r24	; 0x03
	UART_8BitDataType DataBuf;

	while(1){

		// Check if There is Bytes to Receive
		if(MCAL_UART_ByteReceiveStatus() == UART_BYTE_READY){
     250:	0e 94 8a 1e 	call	0x3d14	; 0x3d14 <MCAL_UART_ByteReceiveStatus>
     254:	81 30       	cpi	r24, 0x01	; 1
     256:	09 f0       	breq	.+2      	; 0x25a <Bluetooth_Receive+0x1a>
     258:	f0 c0       	rjmp	.+480    	; 0x43a <Bluetooth_Receive+0x1fa>

			// Take Access to Write On the Bluetooth Buffers
			Return = xSemaphoreTake(Bluetooth_Data_Access,0);
     25a:	80 91 9c 05 	lds	r24, 0x059C
     25e:	90 91 9d 05 	lds	r25, 0x059D
     262:	60 e0       	ldi	r22, 0x00	; 0
     264:	70 e0       	ldi	r23, 0x00	; 0
     266:	40 e0       	ldi	r20, 0x00	; 0
     268:	50 e0       	ldi	r21, 0x00	; 0
     26a:	20 e0       	ldi	r18, 0x00	; 0
     26c:	0e 94 0e 0f 	call	0x1e1c	; 0x1e1c <xQueueGenericReceive>
     270:	89 83       	std	Y+1, r24	; 0x01
			if(Return == pdPASS) {
     272:	89 81       	ldd	r24, Y+1	; 0x01
     274:	81 30       	cpi	r24, 0x01	; 1
     276:	09 f0       	breq	.+2      	; 0x27a <Bluetooth_Receive+0x3a>
     278:	e0 c0       	rjmp	.+448    	; 0x43a <Bluetooth_Receive+0x1fa>

				// Receive Frame Start Byte
				MCAL_UART_Receive(&DataBuf);
     27a:	ce 01       	movw	r24, r28
     27c:	02 96       	adiw	r24, 0x02	; 2
     27e:	0e 94 97 1e 	call	0x3d2e	; 0x3d2e <MCAL_UART_Receive>
				if(DataBuf == BLUETOOTH_FRAME_START) {
     282:	8a 81       	ldd	r24, Y+2	; 0x02
     284:	8e 37       	cpi	r24, 0x7E	; 126
     286:	09 f0       	breq	.+2      	; 0x28a <Bluetooth_Receive+0x4a>
     288:	d8 c0       	rjmp	.+432    	; 0x43a <Bluetooth_Receive+0x1fa>

					// Clean Data & Pass Buffers
					memset((char*)Bluetooth.Data,'\0',15*sizeof(UART_8BitDataType));
     28a:	86 e8       	ldi	r24, 0x86	; 134
     28c:	95 e0       	ldi	r25, 0x05	; 5
     28e:	60 e0       	ldi	r22, 0x00	; 0
     290:	70 e0       	ldi	r23, 0x00	; 0
     292:	4f e0       	ldi	r20, 0x0F	; 15
     294:	50 e0       	ldi	r21, 0x00	; 0
     296:	0e 94 d1 21 	call	0x43a2	; 0x43a2 <memset>
					memset((char*)Bluetooth.Pass,'\0',5*sizeof(UART_8BitDataType));
     29a:	85 e9       	ldi	r24, 0x95	; 149
     29c:	95 e0       	ldi	r25, 0x05	; 5
     29e:	60 e0       	ldi	r22, 0x00	; 0
     2a0:	70 e0       	ldi	r23, 0x00	; 0
     2a2:	45 e0       	ldi	r20, 0x05	; 5
     2a4:	50 e0       	ldi	r21, 0x00	; 0
     2a6:	0e 94 d1 21 	call	0x43a2	; 0x43a2 <memset>

					// Receive Frame Type Byte
					MCAL_UART_Receive(&DataBuf);
     2aa:	ce 01       	movw	r24, r28
     2ac:	02 96       	adiw	r24, 0x02	; 2
     2ae:	0e 94 97 1e 	call	0x3d2e	; 0x3d2e <MCAL_UART_Receive>
     2b2:	39 c0       	rjmp	.+114    	; 0x326 <Bluetooth_Receive+0xe6>
					while(DataBuf != BLUETOOTH_FRAME_STOP) {
						if(ReceiveIdx == FRAME_TYPE_IDX) Bluetooth.Type = DataBuf;
     2b4:	80 91 a1 00 	lds	r24, 0x00A1
     2b8:	88 23       	and	r24, r24
     2ba:	21 f4       	brne	.+8      	; 0x2c4 <Bluetooth_Receive+0x84>
     2bc:	8a 81       	ldd	r24, Y+2	; 0x02
     2be:	80 93 85 05 	sts	0x0585, r24
     2c2:	28 c0       	rjmp	.+80     	; 0x314 <Bluetooth_Receive+0xd4>
						else {

							// Set Flag That Incoming Bytes Are For Pass When Receiving Pass Indicator
							if(DataBuf == BLUETOOTH_PASS_IND) PassFlag = 1;
     2c4:	8a 81       	ldd	r24, Y+2	; 0x02
     2c6:	80 36       	cpi	r24, 0x60	; 96
     2c8:	21 f4       	brne	.+8      	; 0x2d2 <Bluetooth_Receive+0x92>
     2ca:	81 e0       	ldi	r24, 0x01	; 1
     2cc:	80 93 9e 00 	sts	0x009E, r24
     2d0:	21 c0       	rjmp	.+66     	; 0x314 <Bluetooth_Receive+0xd4>
							else {

								// Store Bytes in Pass Buffer
								if(PassFlag == 1){
     2d2:	80 91 9e 00 	lds	r24, 0x009E
     2d6:	81 30       	cpi	r24, 0x01	; 1
     2d8:	79 f4       	brne	.+30     	; 0x2f8 <Bluetooth_Receive+0xb8>
									Bluetooth.Pass[PassIdx] = DataBuf;
     2da:	80 91 9f 00 	lds	r24, 0x009F
     2de:	88 2f       	mov	r24, r24
     2e0:	90 e0       	ldi	r25, 0x00	; 0
     2e2:	2a 81       	ldd	r18, Y+2	; 0x02
     2e4:	fc 01       	movw	r30, r24
     2e6:	eb 56       	subi	r30, 0x6B	; 107
     2e8:	fa 4f       	sbci	r31, 0xFA	; 250
     2ea:	20 83       	st	Z, r18
									PassIdx++;
     2ec:	80 91 9f 00 	lds	r24, 0x009F
     2f0:	8f 5f       	subi	r24, 0xFF	; 255
     2f2:	80 93 9f 00 	sts	0x009F, r24
     2f6:	0e c0       	rjmp	.+28     	; 0x314 <Bluetooth_Receive+0xd4>
								}

								// Store Bytes in Data Buffer
								else {
									Bluetooth.Data[DataIdx] = DataBuf;
     2f8:	80 91 a0 00 	lds	r24, 0x00A0
     2fc:	88 2f       	mov	r24, r24
     2fe:	90 e0       	ldi	r25, 0x00	; 0
     300:	2a 81       	ldd	r18, Y+2	; 0x02
     302:	fc 01       	movw	r30, r24
     304:	ea 57       	subi	r30, 0x7A	; 122
     306:	fa 4f       	sbci	r31, 0xFA	; 250
     308:	20 83       	st	Z, r18
									DataIdx++;
     30a:	80 91 a0 00 	lds	r24, 0x00A0
     30e:	8f 5f       	subi	r24, 0xFF	; 255
     310:	80 93 a0 00 	sts	0x00A0, r24
								}
							}
						}
						ReceiveIdx++;
     314:	80 91 a1 00 	lds	r24, 0x00A1
     318:	8f 5f       	subi	r24, 0xFF	; 255
     31a:	80 93 a1 00 	sts	0x00A1, r24
						MCAL_UART_Receive(&DataBuf);
     31e:	ce 01       	movw	r24, r28
     320:	02 96       	adiw	r24, 0x02	; 2
     322:	0e 94 97 1e 	call	0x3d2e	; 0x3d2e <MCAL_UART_Receive>
					memset((char*)Bluetooth.Data,'\0',15*sizeof(UART_8BitDataType));
					memset((char*)Bluetooth.Pass,'\0',5*sizeof(UART_8BitDataType));

					// Receive Frame Type Byte
					MCAL_UART_Receive(&DataBuf);
					while(DataBuf != BLUETOOTH_FRAME_STOP) {
     326:	8a 81       	ldd	r24, Y+2	; 0x02
     328:	8e 37       	cpi	r24, 0x7E	; 126
     32a:	21 f6       	brne	.-120    	; 0x2b4 <Bluetooth_Receive+0x74>
						ReceiveIdx++;
						MCAL_UART_Receive(&DataBuf);
					}

					// Set Event For the Desired Task
					if(Bluetooth.Type == BLUETOOTH_USER_LOGIN) xSemaphoreGive(User_Login_Access);
     32c:	80 91 85 05 	lds	r24, 0x0585
     330:	81 30       	cpi	r24, 0x01	; 1
     332:	61 f4       	brne	.+24     	; 0x34c <Bluetooth_Receive+0x10c>
     334:	80 91 a6 05 	lds	r24, 0x05A6
     338:	90 91 a7 05 	lds	r25, 0x05A7
     33c:	60 e0       	ldi	r22, 0x00	; 0
     33e:	70 e0       	ldi	r23, 0x00	; 0
     340:	40 e0       	ldi	r20, 0x00	; 0
     342:	50 e0       	ldi	r21, 0x00	; 0
     344:	20 e0       	ldi	r18, 0x00	; 0
     346:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xQueueGenericSend>
     34a:	6f c0       	rjmp	.+222    	; 0x42a <Bluetooth_Receive+0x1ea>
					else if(Bluetooth.Type == BLUETOOTH_MASTER_ACCESS) xSemaphoreGive(User_Master_Access);
     34c:	80 91 85 05 	lds	r24, 0x0585
     350:	82 30       	cpi	r24, 0x02	; 2
     352:	61 f4       	brne	.+24     	; 0x36c <Bluetooth_Receive+0x12c>
     354:	80 91 b0 05 	lds	r24, 0x05B0
     358:	90 91 b1 05 	lds	r25, 0x05B1
     35c:	60 e0       	ldi	r22, 0x00	; 0
     35e:	70 e0       	ldi	r23, 0x00	; 0
     360:	40 e0       	ldi	r20, 0x00	; 0
     362:	50 e0       	ldi	r21, 0x00	; 0
     364:	20 e0       	ldi	r18, 0x00	; 0
     366:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xQueueGenericSend>
     36a:	5f c0       	rjmp	.+190    	; 0x42a <Bluetooth_Receive+0x1ea>
					else if(Bluetooth.Type == BLUETOOTH_USER_ADD) xSemaphoreGive(User_Add_Access);
     36c:	80 91 85 05 	lds	r24, 0x0585
     370:	83 30       	cpi	r24, 0x03	; 3
     372:	61 f4       	brne	.+24     	; 0x38c <Bluetooth_Receive+0x14c>
     374:	80 91 ae 05 	lds	r24, 0x05AE
     378:	90 91 af 05 	lds	r25, 0x05AF
     37c:	60 e0       	ldi	r22, 0x00	; 0
     37e:	70 e0       	ldi	r23, 0x00	; 0
     380:	40 e0       	ldi	r20, 0x00	; 0
     382:	50 e0       	ldi	r21, 0x00	; 0
     384:	20 e0       	ldi	r18, 0x00	; 0
     386:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xQueueGenericSend>
     38a:	4f c0       	rjmp	.+158    	; 0x42a <Bluetooth_Receive+0x1ea>
					else if(Bluetooth.Type == BLUETOOTH_USER_REMOVE) xSemaphoreGive(User_Remove_Access);
     38c:	80 91 85 05 	lds	r24, 0x0585
     390:	84 30       	cpi	r24, 0x04	; 4
     392:	61 f4       	brne	.+24     	; 0x3ac <Bluetooth_Receive+0x16c>
     394:	80 91 a8 05 	lds	r24, 0x05A8
     398:	90 91 a9 05 	lds	r25, 0x05A9
     39c:	60 e0       	ldi	r22, 0x00	; 0
     39e:	70 e0       	ldi	r23, 0x00	; 0
     3a0:	40 e0       	ldi	r20, 0x00	; 0
     3a2:	50 e0       	ldi	r21, 0x00	; 0
     3a4:	20 e0       	ldi	r18, 0x00	; 0
     3a6:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xQueueGenericSend>
     3aa:	3f c0       	rjmp	.+126    	; 0x42a <Bluetooth_Receive+0x1ea>
					else if(Bluetooth.Type == BLUETOOTH_SIREN_ALARM) xSemaphoreGive(Siren_Alarm_Access);
     3ac:	80 91 85 05 	lds	r24, 0x0585
     3b0:	85 30       	cpi	r24, 0x05	; 5
     3b2:	61 f4       	brne	.+24     	; 0x3cc <Bluetooth_Receive+0x18c>
     3b4:	80 91 a2 05 	lds	r24, 0x05A2
     3b8:	90 91 a3 05 	lds	r25, 0x05A3
     3bc:	60 e0       	ldi	r22, 0x00	; 0
     3be:	70 e0       	ldi	r23, 0x00	; 0
     3c0:	40 e0       	ldi	r20, 0x00	; 0
     3c2:	50 e0       	ldi	r21, 0x00	; 0
     3c4:	20 e0       	ldi	r18, 0x00	; 0
     3c6:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xQueueGenericSend>
     3ca:	2f c0       	rjmp	.+94     	; 0x42a <Bluetooth_Receive+0x1ea>
					else if(Bluetooth.Type == BLUETOOTH_DOOR_LOCK) xSemaphoreGive(Actuator_Access);
     3cc:	80 91 85 05 	lds	r24, 0x0585
     3d0:	86 30       	cpi	r24, 0x06	; 6
     3d2:	61 f4       	brne	.+24     	; 0x3ec <Bluetooth_Receive+0x1ac>
     3d4:	80 91 a0 05 	lds	r24, 0x05A0
     3d8:	90 91 a1 05 	lds	r25, 0x05A1
     3dc:	60 e0       	ldi	r22, 0x00	; 0
     3de:	70 e0       	ldi	r23, 0x00	; 0
     3e0:	40 e0       	ldi	r20, 0x00	; 0
     3e2:	50 e0       	ldi	r21, 0x00	; 0
     3e4:	20 e0       	ldi	r18, 0x00	; 0
     3e6:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xQueueGenericSend>
     3ea:	1f c0       	rjmp	.+62     	; 0x42a <Bluetooth_Receive+0x1ea>
					else if(Bluetooth.Type == BLUETOOTH_ROOM1_LIGHT) xSemaphoreGive(Actuator_Access);
     3ec:	80 91 85 05 	lds	r24, 0x0585
     3f0:	87 30       	cpi	r24, 0x07	; 7
     3f2:	61 f4       	brne	.+24     	; 0x40c <Bluetooth_Receive+0x1cc>
     3f4:	80 91 a0 05 	lds	r24, 0x05A0
     3f8:	90 91 a1 05 	lds	r25, 0x05A1
     3fc:	60 e0       	ldi	r22, 0x00	; 0
     3fe:	70 e0       	ldi	r23, 0x00	; 0
     400:	40 e0       	ldi	r20, 0x00	; 0
     402:	50 e0       	ldi	r21, 0x00	; 0
     404:	20 e0       	ldi	r18, 0x00	; 0
     406:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xQueueGenericSend>
     40a:	0f c0       	rjmp	.+30     	; 0x42a <Bluetooth_Receive+0x1ea>
					else if(Bluetooth.Type == BLUETOOTH_ROOM2_LIGHT) xSemaphoreGive(Actuator_Access);
     40c:	80 91 85 05 	lds	r24, 0x0585
     410:	88 30       	cpi	r24, 0x08	; 8
     412:	59 f4       	brne	.+22     	; 0x42a <Bluetooth_Receive+0x1ea>
     414:	80 91 a0 05 	lds	r24, 0x05A0
     418:	90 91 a1 05 	lds	r25, 0x05A1
     41c:	60 e0       	ldi	r22, 0x00	; 0
     41e:	70 e0       	ldi	r23, 0x00	; 0
     420:	40 e0       	ldi	r20, 0x00	; 0
     422:	50 e0       	ldi	r21, 0x00	; 0
     424:	20 e0       	ldi	r18, 0x00	; 0
     426:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xQueueGenericSend>

					// Reset all Receiving Index Variables & Flags
					DataIdx = 0;
     42a:	10 92 a0 00 	sts	0x00A0, r1
					PassFlag = 0;
     42e:	10 92 9e 00 	sts	0x009E, r1
					PassIdx = 0;
     432:	10 92 9f 00 	sts	0x009F, r1
					ReceiveIdx = 0;
     436:	10 92 a1 00 	sts	0x00A1, r1

			}

		}

		vTaskDelay(2);
     43a:	82 e0       	ldi	r24, 0x02	; 2
     43c:	90 e0       	ldi	r25, 0x00	; 0
     43e:	0e 94 bf 13 	call	0x277e	; 0x277e <vTaskDelay>
     442:	06 cf       	rjmp	.-500    	; 0x250 <Bluetooth_Receive+0x10>

00000444 <MCU_Init>:

/* =======================================================================
 * 	Microcontroller Unit Initialization
 * ==================================================================== */

void MCU_Init(void) {
     444:	df 93       	push	r29
     446:	cf 93       	push	r28
     448:	cd b7       	in	r28, 0x3d	; 61
     44a:	de b7       	in	r29, 0x3e	; 62
     44c:	6d 97       	sbiw	r28, 0x1d	; 29
     44e:	0f b6       	in	r0, 0x3f	; 63
     450:	f8 94       	cli
     452:	de bf       	out	0x3e, r29	; 62
     454:	0f be       	out	0x3f, r0	; 63
     456:	cd bf       	out	0x3d, r28	; 61
		UART_Tx_Rising_Rx_Falling,
		9600,
		NULL,
		NULL,
		NULL
	};
     458:	ce 01       	movw	r24, r28
     45a:	01 96       	adiw	r24, 0x01	; 1
     45c:	9d 8b       	std	Y+21, r25	; 0x15
     45e:	8c 8b       	std	Y+20, r24	; 0x14
     460:	e2 e8       	ldi	r30, 0x82	; 130
     462:	f0 e0       	ldi	r31, 0x00	; 0
     464:	ff 8b       	std	Y+23, r31	; 0x17
     466:	ee 8b       	std	Y+22, r30	; 0x16
     468:	f3 e1       	ldi	r31, 0x13	; 19
     46a:	f8 8f       	std	Y+24, r31	; 0x18
     46c:	ee 89       	ldd	r30, Y+22	; 0x16
     46e:	ff 89       	ldd	r31, Y+23	; 0x17
     470:	00 80       	ld	r0, Z
     472:	8e 89       	ldd	r24, Y+22	; 0x16
     474:	9f 89       	ldd	r25, Y+23	; 0x17
     476:	01 96       	adiw	r24, 0x01	; 1
     478:	9f 8b       	std	Y+23, r25	; 0x17
     47a:	8e 8b       	std	Y+22, r24	; 0x16
     47c:	ec 89       	ldd	r30, Y+20	; 0x14
     47e:	fd 89       	ldd	r31, Y+21	; 0x15
     480:	00 82       	st	Z, r0
     482:	8c 89       	ldd	r24, Y+20	; 0x14
     484:	9d 89       	ldd	r25, Y+21	; 0x15
     486:	01 96       	adiw	r24, 0x01	; 1
     488:	9d 8b       	std	Y+21, r25	; 0x15
     48a:	8c 8b       	std	Y+20, r24	; 0x14
     48c:	98 8d       	ldd	r25, Y+24	; 0x18
     48e:	91 50       	subi	r25, 0x01	; 1
     490:	98 8f       	std	Y+24, r25	; 0x18
     492:	e8 8d       	ldd	r30, Y+24	; 0x18
     494:	ee 23       	and	r30, r30
     496:	51 f7       	brne	.-44     	; 0x46c <MCU_Init+0x28>
	MCAL_UART_Init(UART_DefaultConfig);
     498:	8d b7       	in	r24, 0x3d	; 61
     49a:	9e b7       	in	r25, 0x3e	; 62
     49c:	43 97       	sbiw	r24, 0x13	; 19
     49e:	0f b6       	in	r0, 0x3f	; 63
     4a0:	f8 94       	cli
     4a2:	9e bf       	out	0x3e, r25	; 62
     4a4:	0f be       	out	0x3f, r0	; 63
     4a6:	8d bf       	out	0x3d, r24	; 61
     4a8:	8d b7       	in	r24, 0x3d	; 61
     4aa:	9e b7       	in	r25, 0x3e	; 62
     4ac:	01 96       	adiw	r24, 0x01	; 1
     4ae:	9a 8f       	std	Y+26, r25	; 0x1a
     4b0:	89 8f       	std	Y+25, r24	; 0x19
     4b2:	fe 01       	movw	r30, r28
     4b4:	31 96       	adiw	r30, 0x01	; 1
     4b6:	fc 8f       	std	Y+28, r31	; 0x1c
     4b8:	eb 8f       	std	Y+27, r30	; 0x1b
     4ba:	f3 e1       	ldi	r31, 0x13	; 19
     4bc:	fd 8f       	std	Y+29, r31	; 0x1d
     4be:	eb 8d       	ldd	r30, Y+27	; 0x1b
     4c0:	fc 8d       	ldd	r31, Y+28	; 0x1c
     4c2:	00 80       	ld	r0, Z
     4c4:	8b 8d       	ldd	r24, Y+27	; 0x1b
     4c6:	9c 8d       	ldd	r25, Y+28	; 0x1c
     4c8:	01 96       	adiw	r24, 0x01	; 1
     4ca:	9c 8f       	std	Y+28, r25	; 0x1c
     4cc:	8b 8f       	std	Y+27, r24	; 0x1b
     4ce:	e9 8d       	ldd	r30, Y+25	; 0x19
     4d0:	fa 8d       	ldd	r31, Y+26	; 0x1a
     4d2:	00 82       	st	Z, r0
     4d4:	89 8d       	ldd	r24, Y+25	; 0x19
     4d6:	9a 8d       	ldd	r25, Y+26	; 0x1a
     4d8:	01 96       	adiw	r24, 0x01	; 1
     4da:	9a 8f       	std	Y+26, r25	; 0x1a
     4dc:	89 8f       	std	Y+25, r24	; 0x19
     4de:	9d 8d       	ldd	r25, Y+29	; 0x1d
     4e0:	91 50       	subi	r25, 0x01	; 1
     4e2:	9d 8f       	std	Y+29, r25	; 0x1d
     4e4:	ed 8d       	ldd	r30, Y+29	; 0x1d
     4e6:	ee 23       	and	r30, r30
     4e8:	51 f7       	brne	.-44     	; 0x4be <MCU_Init+0x7a>
     4ea:	0e 94 1b 1d 	call	0x3a36	; 0x3a36 <MCAL_UART_Init>
     4ee:	8d b7       	in	r24, 0x3d	; 61
     4f0:	9e b7       	in	r25, 0x3e	; 62
     4f2:	43 96       	adiw	r24, 0x13	; 19
     4f4:	0f b6       	in	r0, 0x3f	; 63
     4f6:	f8 94       	cli
     4f8:	9e bf       	out	0x3e, r25	; 62
     4fa:	0f be       	out	0x3f, r0	; 63
     4fc:	8d bf       	out	0x3d, r24	; 61

	// Initialize User Management
	User_Init();
     4fe:	0e 94 bf 03 	call	0x77e	; 0x77e <User_Init>

	// Initialize Actuators
	Actuators_Init();
     502:	0e 94 99 00 	call	0x132	; 0x132 <Actuators_Init>

	// Initialize LEDs
	HAL_LED_Init(SystemErrorLED);
     506:	80 91 6b 00 	lds	r24, 0x006B
     50a:	90 91 6c 00 	lds	r25, 0x006C
     50e:	0e 94 64 20 	call	0x40c8	; 0x40c8 <HAL_LED_Init>

}
     512:	6d 96       	adiw	r28, 0x1d	; 29
     514:	0f b6       	in	r0, 0x3f	; 63
     516:	f8 94       	cli
     518:	de bf       	out	0x3e, r29	; 62
     51a:	0f be       	out	0x3f, r0	; 63
     51c:	cd bf       	out	0x3d, r28	; 61
     51e:	cf 91       	pop	r28
     520:	df 91       	pop	r29
     522:	08 95       	ret

00000524 <main>:

/* =======================================================================
 * 	APP Main
 * ==================================================================== */

int main(void){
     524:	df 93       	push	r29
     526:	cf 93       	push	r28
     528:	cd b7       	in	r28, 0x3d	; 61
     52a:	de b7       	in	r29, 0x3e	; 62

	/* =======================================================================
	 * 	Initialize Microcontroller Unit
	 * ==================================================================== */

	MCU_Init();
     52c:	0e 94 22 02 	call	0x444	; 0x444 <MCU_Init>

	/* =======================================================================
	 * 	Initialize APP OS
	 * ==================================================================== */

	OS_Init();
     530:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <OS_Init>

	/* =======================================================================
	 * 	Start APP Task Scheduler
	 * ==================================================================== */

	vTaskStartScheduler();
     534:	0e 94 f4 13 	call	0x27e8	; 0x27e8 <vTaskStartScheduler>
     538:	80 e0       	ldi	r24, 0x00	; 0
     53a:	90 e0       	ldi	r25, 0x00	; 0

	/* ==================================================================== */

}
     53c:	cf 91       	pop	r28
     53e:	df 91       	pop	r29
     540:	08 95       	ret

00000542 <Master_Access>:
 * 	@ Func  	 - Master_Access
 * 	@ Brief 	 - Master Access to User Management task.
 * 	@ Param [in] - pvParameter: Pointer to task input parameters.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void Master_Access(void*pvParameter){
     542:	df 93       	push	r29
     544:	cf 93       	push	r28
     546:	00 d0       	rcall	.+0      	; 0x548 <Master_Access+0x6>
     548:	0f 92       	push	r0
     54a:	cd b7       	in	r28, 0x3d	; 61
     54c:	de b7       	in	r29, 0x3e	; 62
     54e:	9b 83       	std	Y+3, r25	; 0x03
     550:	8a 83       	std	Y+2, r24	; 0x02
	uint8 Return;

	while(1){

		// Take Access to Check the Received Master Pass
		Return = xSemaphoreTake(User_Master_Access,0);
     552:	80 91 b0 05 	lds	r24, 0x05B0
     556:	90 91 b1 05 	lds	r25, 0x05B1
     55a:	60 e0       	ldi	r22, 0x00	; 0
     55c:	70 e0       	ldi	r23, 0x00	; 0
     55e:	40 e0       	ldi	r20, 0x00	; 0
     560:	50 e0       	ldi	r21, 0x00	; 0
     562:	20 e0       	ldi	r18, 0x00	; 0
     564:	0e 94 0e 0f 	call	0x1e1c	; 0x1e1c <xQueueGenericReceive>
     568:	89 83       	std	Y+1, r24	; 0x01
		if(Return == pdPASS) {
     56a:	89 81       	ldd	r24, Y+1	; 0x01
     56c:	81 30       	cpi	r24, 0x01	; 1
     56e:	e1 f4       	brne	.+56     	; 0x5a8 <Master_Access+0x66>
			if(atoi((char*)Bluetooth.Data) == MASTER_PASS) MCAL_UART_Send(ACCEPT_ACCESS);
     570:	86 e8       	ldi	r24, 0x86	; 134
     572:	95 e0       	ldi	r25, 0x05	; 5
     574:	0e 94 aa 21 	call	0x4354	; 0x4354 <atoi>
     578:	24 e0       	ldi	r18, 0x04	; 4
     57a:	82 3d       	cpi	r24, 0xD2	; 210
     57c:	92 07       	cpc	r25, r18
     57e:	29 f4       	brne	.+10     	; 0x58a <Master_Access+0x48>
     580:	81 e0       	ldi	r24, 0x01	; 1
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <MCAL_UART_Send>
     588:	04 c0       	rjmp	.+8      	; 0x592 <Master_Access+0x50>
			else MCAL_UART_Send(REFUSE_ACCESS);
     58a:	80 e0       	ldi	r24, 0x00	; 0
     58c:	90 e0       	ldi	r25, 0x00	; 0
     58e:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <MCAL_UART_Send>

			// Give Access to Bluetooth Frame Again
			xSemaphoreGive(Bluetooth_Data_Access);
     592:	80 91 9c 05 	lds	r24, 0x059C
     596:	90 91 9d 05 	lds	r25, 0x059D
     59a:	60 e0       	ldi	r22, 0x00	; 0
     59c:	70 e0       	ldi	r23, 0x00	; 0
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	50 e0       	ldi	r21, 0x00	; 0
     5a2:	20 e0       	ldi	r18, 0x00	; 0
     5a4:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xQueueGenericSend>
		}

		vTaskDelay(3);
     5a8:	83 e0       	ldi	r24, 0x03	; 3
     5aa:	90 e0       	ldi	r25, 0x00	; 0
     5ac:	0e 94 bf 13 	call	0x277e	; 0x277e <vTaskDelay>
     5b0:	d0 cf       	rjmp	.-96     	; 0x552 <Master_Access+0x10>

000005b2 <OS_Init>:

/* =======================================================================
 * 	APP OS Initialization
 * ==================================================================== */

void OS_Init(void) {
     5b2:	af 92       	push	r10
     5b4:	bf 92       	push	r11
     5b6:	cf 92       	push	r12
     5b8:	df 92       	push	r13
     5ba:	ef 92       	push	r14
     5bc:	ff 92       	push	r15
     5be:	0f 93       	push	r16
     5c0:	df 93       	push	r29
     5c2:	cf 93       	push	r28
     5c4:	cd b7       	in	r28, 0x3d	; 61
     5c6:	de b7       	in	r29, 0x3e	; 62
	/* =======================================================================
	 * 	APP Semaphores Creation
	 * ==================================================================== */

	// Bluetooth Data Semaphore
	Bluetooth_Data_Access = xSemaphoreCreateCounting(1,1);
     5c8:	81 e0       	ldi	r24, 0x01	; 1
     5ca:	61 e0       	ldi	r22, 0x01	; 1
     5cc:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <xQueueCreateCountingSemaphore>
     5d0:	90 93 9d 05 	sts	0x059D, r25
     5d4:	80 93 9c 05 	sts	0x059C, r24

	// Master Access Semaphore
	User_Master_Access = xSemaphoreCreateCounting(1,0);
     5d8:	81 e0       	ldi	r24, 0x01	; 1
     5da:	60 e0       	ldi	r22, 0x00	; 0
     5dc:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <xQueueCreateCountingSemaphore>
     5e0:	90 93 b1 05 	sts	0x05B1, r25
     5e4:	80 93 b0 05 	sts	0x05B0, r24

	// User Log In Semaphore
	User_Login_Access = xSemaphoreCreateCounting(1,0);
     5e8:	81 e0       	ldi	r24, 0x01	; 1
     5ea:	60 e0       	ldi	r22, 0x00	; 0
     5ec:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <xQueueCreateCountingSemaphore>
     5f0:	90 93 a7 05 	sts	0x05A7, r25
     5f4:	80 93 a6 05 	sts	0x05A6, r24

	// User Add Semaphore
	User_Add_Access = xSemaphoreCreateCounting(1,0);
     5f8:	81 e0       	ldi	r24, 0x01	; 1
     5fa:	60 e0       	ldi	r22, 0x00	; 0
     5fc:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <xQueueCreateCountingSemaphore>
     600:	90 93 af 05 	sts	0x05AF, r25
     604:	80 93 ae 05 	sts	0x05AE, r24

	// User Remove Semaphore
	User_Remove_Access = xSemaphoreCreateCounting(1,0);
     608:	81 e0       	ldi	r24, 0x01	; 1
     60a:	60 e0       	ldi	r22, 0x00	; 0
     60c:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <xQueueCreateCountingSemaphore>
     610:	90 93 a9 05 	sts	0x05A9, r25
     614:	80 93 a8 05 	sts	0x05A8, r24

	// Siren Alarm Semaphore
	Siren_Alarm_Access = xSemaphoreCreateCounting(1,0);
     618:	81 e0       	ldi	r24, 0x01	; 1
     61a:	60 e0       	ldi	r22, 0x00	; 0
     61c:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <xQueueCreateCountingSemaphore>
     620:	90 93 a3 05 	sts	0x05A3, r25
     624:	80 93 a2 05 	sts	0x05A2, r24

	// Door Lock Semaphore
	Actuator_Access = xSemaphoreCreateCounting(1,0);
     628:	81 e0       	ldi	r24, 0x01	; 1
     62a:	60 e0       	ldi	r22, 0x00	; 0
     62c:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <xQueueCreateCountingSemaphore>
     630:	90 93 a1 05 	sts	0x05A1, r25
     634:	80 93 a0 05 	sts	0x05A0, r24
	/* =======================================================================
	 * 	APP Tasks Creation
	 * ==================================================================== */

	// Receiving Data From Bluetooth Task
	xTaskCreate(Bluetooth_Receive, NULL, configMINIMAL_STACK_SIZE, NULL, BLUETOOTH_RECEIVE_PRIORITY, Bluetooth_Receive_Task_Handle);
     638:	80 91 ac 05 	lds	r24, 0x05AC
     63c:	90 91 ad 05 	lds	r25, 0x05AD
     640:	fc 01       	movw	r30, r24
     642:	80 e2       	ldi	r24, 0x20	; 32
     644:	91 e0       	ldi	r25, 0x01	; 1
     646:	60 e0       	ldi	r22, 0x00	; 0
     648:	70 e0       	ldi	r23, 0x00	; 0
     64a:	45 e5       	ldi	r20, 0x55	; 85
     64c:	50 e0       	ldi	r21, 0x00	; 0
     64e:	20 e0       	ldi	r18, 0x00	; 0
     650:	30 e0       	ldi	r19, 0x00	; 0
     652:	02 e0       	ldi	r16, 0x02	; 2
     654:	7f 01       	movw	r14, r30
     656:	cc 24       	eor	r12, r12
     658:	dd 24       	eor	r13, r13
     65a:	aa 24       	eor	r10, r10
     65c:	bb 24       	eor	r11, r11
     65e:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <xTaskGenericCreate>

	// Master Access Task
	xTaskCreate(Master_Access, NULL, configMINIMAL_STACK_SIZE, NULL, MASTER_ACCESS_PRIORITY, Master_Access_Task_Handle);
     662:	80 91 9e 05 	lds	r24, 0x059E
     666:	90 91 9f 05 	lds	r25, 0x059F
     66a:	fc 01       	movw	r30, r24
     66c:	81 ea       	ldi	r24, 0xA1	; 161
     66e:	92 e0       	ldi	r25, 0x02	; 2
     670:	60 e0       	ldi	r22, 0x00	; 0
     672:	70 e0       	ldi	r23, 0x00	; 0
     674:	45 e5       	ldi	r20, 0x55	; 85
     676:	50 e0       	ldi	r21, 0x00	; 0
     678:	20 e0       	ldi	r18, 0x00	; 0
     67a:	30 e0       	ldi	r19, 0x00	; 0
     67c:	01 e0       	ldi	r16, 0x01	; 1
     67e:	7f 01       	movw	r14, r30
     680:	cc 24       	eor	r12, r12
     682:	dd 24       	eor	r13, r13
     684:	aa 24       	eor	r10, r10
     686:	bb 24       	eor	r11, r11
     688:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <xTaskGenericCreate>

	// User Management Task
	xTaskCreate(User_Manage, NULL, configMINIMAL_STACK_SIZE, NULL, USER_PRIORITY, User_Manage_Task_Handle);
     68c:	80 91 9a 05 	lds	r24, 0x059A
     690:	90 91 9b 05 	lds	r25, 0x059B
     694:	fc 01       	movw	r30, r24
     696:	8e e6       	ldi	r24, 0x6E	; 110
     698:	95 e0       	ldi	r25, 0x05	; 5
     69a:	60 e0       	ldi	r22, 0x00	; 0
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	45 e5       	ldi	r20, 0x55	; 85
     6a0:	50 e0       	ldi	r21, 0x00	; 0
     6a2:	20 e0       	ldi	r18, 0x00	; 0
     6a4:	30 e0       	ldi	r19, 0x00	; 0
     6a6:	01 e0       	ldi	r16, 0x01	; 1
     6a8:	7f 01       	movw	r14, r30
     6aa:	cc 24       	eor	r12, r12
     6ac:	dd 24       	eor	r13, r13
     6ae:	aa 24       	eor	r10, r10
     6b0:	bb 24       	eor	r11, r11
     6b2:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <xTaskGenericCreate>

	// Siren Alarm Task
	xTaskCreate(Siren_Alarm, NULL, configMINIMAL_STACK_SIZE, NULL, SIREN_ALARM_PRIORITY, Siren_Alarm_Task_Handle);
     6b6:	80 91 a4 05 	lds	r24, 0x05A4
     6ba:	90 91 a5 05 	lds	r25, 0x05A5
     6be:	fc 01       	movw	r30, r24
     6c0:	8f e8       	ldi	r24, 0x8F	; 143
     6c2:	93 e0       	ldi	r25, 0x03	; 3
     6c4:	60 e0       	ldi	r22, 0x00	; 0
     6c6:	70 e0       	ldi	r23, 0x00	; 0
     6c8:	45 e5       	ldi	r20, 0x55	; 85
     6ca:	50 e0       	ldi	r21, 0x00	; 0
     6cc:	20 e0       	ldi	r18, 0x00	; 0
     6ce:	30 e0       	ldi	r19, 0x00	; 0
     6d0:	03 e0       	ldi	r16, 0x03	; 3
     6d2:	7f 01       	movw	r14, r30
     6d4:	cc 24       	eor	r12, r12
     6d6:	dd 24       	eor	r13, r13
     6d8:	aa 24       	eor	r10, r10
     6da:	bb 24       	eor	r11, r11
     6dc:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <xTaskGenericCreate>

	// Actuator Control Task
	xTaskCreate(Actuator_Control, NULL, configMINIMAL_STACK_SIZE, NULL, ACTUATOR_CONTROL_PRIORITY, Actuator_Control_Task_Handle);
     6e0:	80 91 aa 05 	lds	r24, 0x05AA
     6e4:	90 91 ab 05 	lds	r25, 0x05AB
     6e8:	fc 01       	movw	r30, r24
     6ea:	89 e4       	ldi	r24, 0x49	; 73
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	60 e0       	ldi	r22, 0x00	; 0
     6f0:	70 e0       	ldi	r23, 0x00	; 0
     6f2:	45 e5       	ldi	r20, 0x55	; 85
     6f4:	50 e0       	ldi	r21, 0x00	; 0
     6f6:	20 e0       	ldi	r18, 0x00	; 0
     6f8:	30 e0       	ldi	r19, 0x00	; 0
     6fa:	01 e0       	ldi	r16, 0x01	; 1
     6fc:	7f 01       	movw	r14, r30
     6fe:	cc 24       	eor	r12, r12
     700:	dd 24       	eor	r13, r13
     702:	aa 24       	eor	r10, r10
     704:	bb 24       	eor	r11, r11
     706:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <xTaskGenericCreate>

	/* ==================================================================== */

}
     70a:	cf 91       	pop	r28
     70c:	df 91       	pop	r29
     70e:	0f 91       	pop	r16
     710:	ff 90       	pop	r15
     712:	ef 90       	pop	r14
     714:	df 90       	pop	r13
     716:	cf 90       	pop	r12
     718:	bf 90       	pop	r11
     71a:	af 90       	pop	r10
     71c:	08 95       	ret

0000071e <Siren_Alarm>:
 * 	@ Func  	 - Siren_Alarm
 * 	@ Brief 	 - Control Siren Alarm task.
 * 	@ Param [in] - pvParameter: Pointer to task input parameters.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void Siren_Alarm(void*pvParameter){
     71e:	df 93       	push	r29
     720:	cf 93       	push	r28
     722:	00 d0       	rcall	.+0      	; 0x724 <Siren_Alarm+0x6>
     724:	0f 92       	push	r0
     726:	cd b7       	in	r28, 0x3d	; 61
     728:	de b7       	in	r29, 0x3e	; 62
     72a:	9b 83       	std	Y+3, r25	; 0x03
     72c:	8a 83       	std	Y+2, r24	; 0x02
	uint8 Return;

	while(1){

		// Take Access to Check Siren Alarm Status
		Return = xSemaphoreTake(Siren_Alarm_Access,0);
     72e:	80 91 a2 05 	lds	r24, 0x05A2
     732:	90 91 a3 05 	lds	r25, 0x05A3
     736:	60 e0       	ldi	r22, 0x00	; 0
     738:	70 e0       	ldi	r23, 0x00	; 0
     73a:	40 e0       	ldi	r20, 0x00	; 0
     73c:	50 e0       	ldi	r21, 0x00	; 0
     73e:	20 e0       	ldi	r18, 0x00	; 0
     740:	0e 94 0e 0f 	call	0x1e1c	; 0x1e1c <xQueueGenericReceive>
     744:	89 83       	std	Y+1, r24	; 0x01
		if(Return == pdPASS) {
     746:	89 81       	ldd	r24, Y+1	; 0x01
     748:	81 30       	cpi	r24, 0x01	; 1
     74a:	a1 f4       	brne	.+40     	; 0x774 <Siren_Alarm+0x56>
			if(Bluetooth.Data[0] == 1) SirenAlarm_On();
     74c:	80 91 86 05 	lds	r24, 0x0586
     750:	81 30       	cpi	r24, 0x01	; 1
     752:	19 f4       	brne	.+6      	; 0x75a <Siren_Alarm+0x3c>
     754:	0e 94 b8 00 	call	0x170	; 0x170 <SirenAlarm_On>
     758:	02 c0       	rjmp	.+4      	; 0x75e <Siren_Alarm+0x40>
			else SirenAlarm_Off();
     75a:	0e 94 c5 00 	call	0x18a	; 0x18a <SirenAlarm_Off>

			// Give Access to Bluetooth Frame Again
			xSemaphoreGive(Bluetooth_Data_Access);
     75e:	80 91 9c 05 	lds	r24, 0x059C
     762:	90 91 9d 05 	lds	r25, 0x059D
     766:	60 e0       	ldi	r22, 0x00	; 0
     768:	70 e0       	ldi	r23, 0x00	; 0
     76a:	40 e0       	ldi	r20, 0x00	; 0
     76c:	50 e0       	ldi	r21, 0x00	; 0
     76e:	20 e0       	ldi	r18, 0x00	; 0
     770:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xQueueGenericSend>
		}

		vTaskDelay(3);
     774:	83 e0       	ldi	r24, 0x03	; 3
     776:	90 e0       	ldi	r25, 0x00	; 0
     778:	0e 94 bf 13 	call	0x277e	; 0x277e <vTaskDelay>
     77c:	d8 cf       	rjmp	.-80     	; 0x72e <Siren_Alarm+0x10>

0000077e <User_Init>:
/* =======================================================================
 * 	@ Func  	 - User_Init
 * 	@ Brief 	 - Initialize User Management Control.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void User_Init(void){
     77e:	df 93       	push	r29
     780:	cf 93       	push	r28
     782:	0f 92       	push	r0
     784:	cd b7       	in	r28, 0x3d	; 61
     786:	de b7       	in	r29, 0x3e	; 62
	uint8 Idx;
	for(Idx = 0;Idx<USERS_NUM;Idx++){
     788:	19 82       	std	Y+1, r1	; 0x01
     78a:	3e c0       	rjmp	.+124    	; 0x808 <User_Init+0x8a>
		memset(user[Idx].username,'\0',15*sizeof(char));
     78c:	89 81       	ldd	r24, Y+1	; 0x01
     78e:	88 2f       	mov	r24, r24
     790:	90 e0       	ldi	r25, 0x00	; 0
     792:	88 0f       	add	r24, r24
     794:	99 1f       	adc	r25, r25
     796:	9c 01       	movw	r18, r24
     798:	22 0f       	add	r18, r18
     79a:	33 1f       	adc	r19, r19
     79c:	22 0f       	add	r18, r18
     79e:	33 1f       	adc	r19, r19
     7a0:	22 0f       	add	r18, r18
     7a2:	33 1f       	adc	r19, r19
     7a4:	82 0f       	add	r24, r18
     7a6:	93 1f       	adc	r25, r19
     7a8:	8e 54       	subi	r24, 0x4E	; 78
     7aa:	9a 4f       	sbci	r25, 0xFA	; 250
     7ac:	60 e0       	ldi	r22, 0x00	; 0
     7ae:	70 e0       	ldi	r23, 0x00	; 0
     7b0:	4f e0       	ldi	r20, 0x0F	; 15
     7b2:	50 e0       	ldi	r21, 0x00	; 0
     7b4:	0e 94 d1 21 	call	0x43a2	; 0x43a2 <memset>
		user[Idx].pass = 0;
     7b8:	89 81       	ldd	r24, Y+1	; 0x01
     7ba:	88 2f       	mov	r24, r24
     7bc:	90 e0       	ldi	r25, 0x00	; 0
     7be:	88 0f       	add	r24, r24
     7c0:	99 1f       	adc	r25, r25
     7c2:	9c 01       	movw	r18, r24
     7c4:	22 0f       	add	r18, r18
     7c6:	33 1f       	adc	r19, r19
     7c8:	22 0f       	add	r18, r18
     7ca:	33 1f       	adc	r19, r19
     7cc:	22 0f       	add	r18, r18
     7ce:	33 1f       	adc	r19, r19
     7d0:	82 0f       	add	r24, r18
     7d2:	93 1f       	adc	r25, r19
     7d4:	fc 01       	movw	r30, r24
     7d6:	ef 53       	subi	r30, 0x3F	; 63
     7d8:	fa 4f       	sbci	r31, 0xFA	; 250
     7da:	11 82       	std	Z+1, r1	; 0x01
     7dc:	10 82       	st	Z, r1
		user[Idx].status = FREE;
     7de:	89 81       	ldd	r24, Y+1	; 0x01
     7e0:	88 2f       	mov	r24, r24
     7e2:	90 e0       	ldi	r25, 0x00	; 0
     7e4:	88 0f       	add	r24, r24
     7e6:	99 1f       	adc	r25, r25
     7e8:	9c 01       	movw	r18, r24
     7ea:	22 0f       	add	r18, r18
     7ec:	33 1f       	adc	r19, r19
     7ee:	22 0f       	add	r18, r18
     7f0:	33 1f       	adc	r19, r19
     7f2:	22 0f       	add	r18, r18
     7f4:	33 1f       	adc	r19, r19
     7f6:	82 0f       	add	r24, r18
     7f8:	93 1f       	adc	r25, r19
     7fa:	fc 01       	movw	r30, r24
     7fc:	ed 53       	subi	r30, 0x3D	; 61
     7fe:	fa 4f       	sbci	r31, 0xFA	; 250
     800:	10 82       	st	Z, r1
 * 	@ Brief 	 - Initialize User Management Control.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void User_Init(void){
	uint8 Idx;
	for(Idx = 0;Idx<USERS_NUM;Idx++){
     802:	89 81       	ldd	r24, Y+1	; 0x01
     804:	8f 5f       	subi	r24, 0xFF	; 255
     806:	89 83       	std	Y+1, r24	; 0x01
     808:	89 81       	ldd	r24, Y+1	; 0x01
     80a:	8a 30       	cpi	r24, 0x0A	; 10
     80c:	08 f4       	brcc	.+2      	; 0x810 <User_Init+0x92>
     80e:	be cf       	rjmp	.-132    	; 0x78c <User_Init+0xe>
		memset(user[Idx].username,'\0',15*sizeof(char));
		user[Idx].pass = 0;
		user[Idx].status = FREE;
	}
}
     810:	0f 90       	pop	r0
     812:	cf 91       	pop	r28
     814:	df 91       	pop	r29
     816:	08 95       	ret

00000818 <User_Search>:
 * 	@ RetVal	 - Std_Return.
 *	  Note		 - This API return "USER_FOUND" when the username & password found,
 *	  			   return "USER_WRONG_PASS" when username is found but password is wrong,
 *	  			   return "USER_NOT_FOUND"	when username not found.
 * ==================================================================== */
Std_Return User_Search(const char *username, uint16 pass, uint8 *userIdx){
     818:	df 93       	push	r29
     81a:	cf 93       	push	r28
     81c:	cd b7       	in	r28, 0x3d	; 61
     81e:	de b7       	in	r29, 0x3e	; 62
     820:	28 97       	sbiw	r28, 0x08	; 8
     822:	0f b6       	in	r0, 0x3f	; 63
     824:	f8 94       	cli
     826:	de bf       	out	0x3e, r29	; 62
     828:	0f be       	out	0x3f, r0	; 63
     82a:	cd bf       	out	0x3d, r28	; 61
     82c:	9c 83       	std	Y+4, r25	; 0x04
     82e:	8b 83       	std	Y+3, r24	; 0x03
     830:	7e 83       	std	Y+6, r23	; 0x06
     832:	6d 83       	std	Y+5, r22	; 0x05
     834:	58 87       	std	Y+8, r21	; 0x08
     836:	4f 83       	std	Y+7, r20	; 0x07
	Std_Return Search_UserStatus = USER_NOT_FOUND;
     838:	82 e0       	ldi	r24, 0x02	; 2
     83a:	8a 83       	std	Y+2, r24	; 0x02
	uint8 Idx;
	for(Idx = 0;Idx < USERS_NUM;Idx++){
     83c:	19 82       	std	Y+1, r1	; 0x01
     83e:	54 c0       	rjmp	.+168    	; 0x8e8 <__stack+0x89>

		// Check if User Place is Taken
		if(user[Idx].status == TAKEN){
     840:	89 81       	ldd	r24, Y+1	; 0x01
     842:	88 2f       	mov	r24, r24
     844:	90 e0       	ldi	r25, 0x00	; 0
     846:	88 0f       	add	r24, r24
     848:	99 1f       	adc	r25, r25
     84a:	9c 01       	movw	r18, r24
     84c:	22 0f       	add	r18, r18
     84e:	33 1f       	adc	r19, r19
     850:	22 0f       	add	r18, r18
     852:	33 1f       	adc	r19, r19
     854:	22 0f       	add	r18, r18
     856:	33 1f       	adc	r19, r19
     858:	82 0f       	add	r24, r18
     85a:	93 1f       	adc	r25, r19
     85c:	fc 01       	movw	r30, r24
     85e:	ed 53       	subi	r30, 0x3D	; 61
     860:	fa 4f       	sbci	r31, 0xFA	; 250
     862:	80 81       	ld	r24, Z
     864:	81 30       	cpi	r24, 0x01	; 1
     866:	e9 f5       	brne	.+122    	; 0x8e2 <__stack+0x83>
			if(strcmp(user[Idx].username, username) == 0) {
     868:	89 81       	ldd	r24, Y+1	; 0x01
     86a:	88 2f       	mov	r24, r24
     86c:	90 e0       	ldi	r25, 0x00	; 0
     86e:	88 0f       	add	r24, r24
     870:	99 1f       	adc	r25, r25
     872:	9c 01       	movw	r18, r24
     874:	22 0f       	add	r18, r18
     876:	33 1f       	adc	r19, r19
     878:	22 0f       	add	r18, r18
     87a:	33 1f       	adc	r19, r19
     87c:	22 0f       	add	r18, r18
     87e:	33 1f       	adc	r19, r19
     880:	82 0f       	add	r24, r18
     882:	93 1f       	adc	r25, r19
     884:	8e 54       	subi	r24, 0x4E	; 78
     886:	9a 4f       	sbci	r25, 0xFA	; 250
     888:	2b 81       	ldd	r18, Y+3	; 0x03
     88a:	3c 81       	ldd	r19, Y+4	; 0x04
     88c:	b9 01       	movw	r22, r18
     88e:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <strcmp>
     892:	00 97       	sbiw	r24, 0x00	; 0
     894:	31 f5       	brne	.+76     	; 0x8e2 <__stack+0x83>

				// Username is found
				if(user[Idx].pass == pass) {
     896:	89 81       	ldd	r24, Y+1	; 0x01
     898:	88 2f       	mov	r24, r24
     89a:	90 e0       	ldi	r25, 0x00	; 0
     89c:	88 0f       	add	r24, r24
     89e:	99 1f       	adc	r25, r25
     8a0:	9c 01       	movw	r18, r24
     8a2:	22 0f       	add	r18, r18
     8a4:	33 1f       	adc	r19, r19
     8a6:	22 0f       	add	r18, r18
     8a8:	33 1f       	adc	r19, r19
     8aa:	22 0f       	add	r18, r18
     8ac:	33 1f       	adc	r19, r19
     8ae:	82 0f       	add	r24, r18
     8b0:	93 1f       	adc	r25, r19
     8b2:	fc 01       	movw	r30, r24
     8b4:	ef 53       	subi	r30, 0x3F	; 63
     8b6:	fa 4f       	sbci	r31, 0xFA	; 250
     8b8:	20 81       	ld	r18, Z
     8ba:	31 81       	ldd	r19, Z+1	; 0x01
     8bc:	8d 81       	ldd	r24, Y+5	; 0x05
     8be:	9e 81       	ldd	r25, Y+6	; 0x06
     8c0:	28 17       	cp	r18, r24
     8c2:	39 07       	cpc	r19, r25
     8c4:	59 f4       	brne	.+22     	; 0x8dc <__stack+0x7d>

					// Password is Right
					Search_UserStatus = USER_FOUND;
     8c6:	83 e0       	ldi	r24, 0x03	; 3
     8c8:	8a 83       	std	Y+2, r24	; 0x02
					if(userIdx != NULL) *userIdx = Idx;
     8ca:	8f 81       	ldd	r24, Y+7	; 0x07
     8cc:	98 85       	ldd	r25, Y+8	; 0x08
     8ce:	00 97       	sbiw	r24, 0x00	; 0
     8d0:	79 f0       	breq	.+30     	; 0x8f0 <__stack+0x91>
     8d2:	ef 81       	ldd	r30, Y+7	; 0x07
     8d4:	f8 85       	ldd	r31, Y+8	; 0x08
     8d6:	89 81       	ldd	r24, Y+1	; 0x01
     8d8:	80 83       	st	Z, r24
     8da:	0a c0       	rjmp	.+20     	; 0x8f0 <__stack+0x91>
				}

				// Password is Wrong
				else Search_UserStatus = USER_WRONG_PASS;
     8dc:	84 e0       	ldi	r24, 0x04	; 4
     8de:	8a 83       	std	Y+2, r24	; 0x02
     8e0:	07 c0       	rjmp	.+14     	; 0x8f0 <__stack+0x91>
 *	  			   return "USER_NOT_FOUND"	when username not found.
 * ==================================================================== */
Std_Return User_Search(const char *username, uint16 pass, uint8 *userIdx){
	Std_Return Search_UserStatus = USER_NOT_FOUND;
	uint8 Idx;
	for(Idx = 0;Idx < USERS_NUM;Idx++){
     8e2:	89 81       	ldd	r24, Y+1	; 0x01
     8e4:	8f 5f       	subi	r24, 0xFF	; 255
     8e6:	89 83       	std	Y+1, r24	; 0x01
     8e8:	89 81       	ldd	r24, Y+1	; 0x01
     8ea:	8a 30       	cpi	r24, 0x0A	; 10
     8ec:	08 f4       	brcc	.+2      	; 0x8f0 <__stack+0x91>
     8ee:	a8 cf       	rjmp	.-176    	; 0x840 <User_Search+0x28>
				else Search_UserStatus = USER_WRONG_PASS;
				break;
			}
		}
	}
	return Search_UserStatus;
     8f0:	8a 81       	ldd	r24, Y+2	; 0x02
}
     8f2:	28 96       	adiw	r28, 0x08	; 8
     8f4:	0f b6       	in	r0, 0x3f	; 63
     8f6:	f8 94       	cli
     8f8:	de bf       	out	0x3e, r29	; 62
     8fa:	0f be       	out	0x3f, r0	; 63
     8fc:	cd bf       	out	0x3d, r28	; 61
     8fe:	cf 91       	pop	r28
     900:	df 91       	pop	r29
     902:	08 95       	ret

00000904 <User_Add>:
 * 	@ Param [in] - pass: User Password.
 * 	@ RetVal	 - Std_Return.
 *	  Note		 - This API return "USER_ADD_DONE" when user has been added to memory,
 *	  			   return "USER_NO_EMPTY_SPACE" when no empty spaces in memory,
 * ==================================================================== */
Std_Return User_Add(const char *username, uint16 pass){
     904:	df 93       	push	r29
     906:	cf 93       	push	r28
     908:	cd b7       	in	r28, 0x3d	; 61
     90a:	de b7       	in	r29, 0x3e	; 62
     90c:	27 97       	sbiw	r28, 0x07	; 7
     90e:	0f b6       	in	r0, 0x3f	; 63
     910:	f8 94       	cli
     912:	de bf       	out	0x3e, r29	; 62
     914:	0f be       	out	0x3f, r0	; 63
     916:	cd bf       	out	0x3d, r28	; 61
     918:	9d 83       	std	Y+5, r25	; 0x05
     91a:	8c 83       	std	Y+4, r24	; 0x04
     91c:	7f 83       	std	Y+7, r23	; 0x07
     91e:	6e 83       	std	Y+6, r22	; 0x06
	Std_Return Add_UserStatus = USER_NO_EMPTY_SPACE;
     920:	1b 82       	std	Y+3, r1	; 0x03
	Std_Return Local_Return;
	uint8 Idx;

	// Check if User is Already Existed in Memory
	Local_Return = User_Search(username,pass,NULL);
     922:	8c 81       	ldd	r24, Y+4	; 0x04
     924:	9d 81       	ldd	r25, Y+5	; 0x05
     926:	2e 81       	ldd	r18, Y+6	; 0x06
     928:	3f 81       	ldd	r19, Y+7	; 0x07
     92a:	b9 01       	movw	r22, r18
     92c:	40 e0       	ldi	r20, 0x00	; 0
     92e:	50 e0       	ldi	r21, 0x00	; 0
     930:	0e 94 0c 04 	call	0x818	; 0x818 <User_Search>
     934:	8a 83       	std	Y+2, r24	; 0x02

	if(Local_Return == USER_NOT_FOUND){
     936:	8a 81       	ldd	r24, Y+2	; 0x02
     938:	82 30       	cpi	r24, 0x02	; 2
     93a:	09 f0       	breq	.+2      	; 0x93e <User_Add+0x3a>
     93c:	5e c0       	rjmp	.+188    	; 0x9fa <User_Add+0xf6>
		for(Idx = 0;Idx < USERS_NUM;Idx++){
     93e:	19 82       	std	Y+1, r1	; 0x01
     940:	58 c0       	rjmp	.+176    	; 0x9f2 <User_Add+0xee>

			// Chcek if User Place is Free
			if(user[Idx].status == FREE){
     942:	89 81       	ldd	r24, Y+1	; 0x01
     944:	88 2f       	mov	r24, r24
     946:	90 e0       	ldi	r25, 0x00	; 0
     948:	88 0f       	add	r24, r24
     94a:	99 1f       	adc	r25, r25
     94c:	9c 01       	movw	r18, r24
     94e:	22 0f       	add	r18, r18
     950:	33 1f       	adc	r19, r19
     952:	22 0f       	add	r18, r18
     954:	33 1f       	adc	r19, r19
     956:	22 0f       	add	r18, r18
     958:	33 1f       	adc	r19, r19
     95a:	82 0f       	add	r24, r18
     95c:	93 1f       	adc	r25, r19
     95e:	fc 01       	movw	r30, r24
     960:	ed 53       	subi	r30, 0x3D	; 61
     962:	fa 4f       	sbci	r31, 0xFA	; 250
     964:	80 81       	ld	r24, Z
     966:	88 23       	and	r24, r24
     968:	09 f0       	breq	.+2      	; 0x96c <User_Add+0x68>
     96a:	40 c0       	rjmp	.+128    	; 0x9ec <User_Add+0xe8>
				strcpy(user[Idx].username,username);
     96c:	89 81       	ldd	r24, Y+1	; 0x01
     96e:	88 2f       	mov	r24, r24
     970:	90 e0       	ldi	r25, 0x00	; 0
     972:	88 0f       	add	r24, r24
     974:	99 1f       	adc	r25, r25
     976:	9c 01       	movw	r18, r24
     978:	22 0f       	add	r18, r18
     97a:	33 1f       	adc	r19, r19
     97c:	22 0f       	add	r18, r18
     97e:	33 1f       	adc	r19, r19
     980:	22 0f       	add	r18, r18
     982:	33 1f       	adc	r19, r19
     984:	82 0f       	add	r24, r18
     986:	93 1f       	adc	r25, r19
     988:	8e 54       	subi	r24, 0x4E	; 78
     98a:	9a 4f       	sbci	r25, 0xFA	; 250
     98c:	2c 81       	ldd	r18, Y+4	; 0x04
     98e:	3d 81       	ldd	r19, Y+5	; 0x05
     990:	b9 01       	movw	r22, r18
     992:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <strcpy>
				user[Idx].pass = pass;
     996:	89 81       	ldd	r24, Y+1	; 0x01
     998:	88 2f       	mov	r24, r24
     99a:	90 e0       	ldi	r25, 0x00	; 0
     99c:	88 0f       	add	r24, r24
     99e:	99 1f       	adc	r25, r25
     9a0:	9c 01       	movw	r18, r24
     9a2:	22 0f       	add	r18, r18
     9a4:	33 1f       	adc	r19, r19
     9a6:	22 0f       	add	r18, r18
     9a8:	33 1f       	adc	r19, r19
     9aa:	22 0f       	add	r18, r18
     9ac:	33 1f       	adc	r19, r19
     9ae:	82 0f       	add	r24, r18
     9b0:	93 1f       	adc	r25, r19
     9b2:	fc 01       	movw	r30, r24
     9b4:	ef 53       	subi	r30, 0x3F	; 63
     9b6:	fa 4f       	sbci	r31, 0xFA	; 250
     9b8:	8e 81       	ldd	r24, Y+6	; 0x06
     9ba:	9f 81       	ldd	r25, Y+7	; 0x07
     9bc:	91 83       	std	Z+1, r25	; 0x01
     9be:	80 83       	st	Z, r24
				user[Idx].status = TAKEN;
     9c0:	89 81       	ldd	r24, Y+1	; 0x01
     9c2:	88 2f       	mov	r24, r24
     9c4:	90 e0       	ldi	r25, 0x00	; 0
     9c6:	88 0f       	add	r24, r24
     9c8:	99 1f       	adc	r25, r25
     9ca:	9c 01       	movw	r18, r24
     9cc:	22 0f       	add	r18, r18
     9ce:	33 1f       	adc	r19, r19
     9d0:	22 0f       	add	r18, r18
     9d2:	33 1f       	adc	r19, r19
     9d4:	22 0f       	add	r18, r18
     9d6:	33 1f       	adc	r19, r19
     9d8:	82 0f       	add	r24, r18
     9da:	93 1f       	adc	r25, r19
     9dc:	fc 01       	movw	r30, r24
     9de:	ed 53       	subi	r30, 0x3D	; 61
     9e0:	fa 4f       	sbci	r31, 0xFA	; 250
     9e2:	81 e0       	ldi	r24, 0x01	; 1
     9e4:	80 83       	st	Z, r24
				Add_UserStatus = USER_ADD_DONE;
     9e6:	81 e0       	ldi	r24, 0x01	; 1
     9e8:	8b 83       	std	Y+3, r24	; 0x03
     9ea:	07 c0       	rjmp	.+14     	; 0x9fa <User_Add+0xf6>

	// Check if User is Already Existed in Memory
	Local_Return = User_Search(username,pass,NULL);

	if(Local_Return == USER_NOT_FOUND){
		for(Idx = 0;Idx < USERS_NUM;Idx++){
     9ec:	89 81       	ldd	r24, Y+1	; 0x01
     9ee:	8f 5f       	subi	r24, 0xFF	; 255
     9f0:	89 83       	std	Y+1, r24	; 0x01
     9f2:	89 81       	ldd	r24, Y+1	; 0x01
     9f4:	8a 30       	cpi	r24, 0x0A	; 10
     9f6:	08 f4       	brcc	.+2      	; 0x9fa <User_Add+0xf6>
     9f8:	a4 cf       	rjmp	.-184    	; 0x942 <User_Add+0x3e>
				Add_UserStatus = USER_ADD_DONE;
				break;
			}
		}
	}
	return Add_UserStatus;
     9fa:	8b 81       	ldd	r24, Y+3	; 0x03
}
     9fc:	27 96       	adiw	r28, 0x07	; 7
     9fe:	0f b6       	in	r0, 0x3f	; 63
     a00:	f8 94       	cli
     a02:	de bf       	out	0x3e, r29	; 62
     a04:	0f be       	out	0x3f, r0	; 63
     a06:	cd bf       	out	0x3d, r28	; 61
     a08:	cf 91       	pop	r28
     a0a:	df 91       	pop	r29
     a0c:	08 95       	ret

00000a0e <User_Delete>:
 * 	@ Param [in] - pass: User Password.
 * 	@ RetVal	 - Std_Return.
 *	  Note		 - This API return "USER_DELETED" when user has been deleted from memory,
 *	  			   return "USER_NOT_DELETED" when user not found so his data didn't delete from memory,
 * ==================================================================== */
Std_Return User_Delete(const char *username, uint16 pass){
     a0e:	df 93       	push	r29
     a10:	cf 93       	push	r28
     a12:	cd b7       	in	r28, 0x3d	; 61
     a14:	de b7       	in	r29, 0x3e	; 62
     a16:	27 97       	sbiw	r28, 0x07	; 7
     a18:	0f b6       	in	r0, 0x3f	; 63
     a1a:	f8 94       	cli
     a1c:	de bf       	out	0x3e, r29	; 62
     a1e:	0f be       	out	0x3f, r0	; 63
     a20:	cd bf       	out	0x3d, r28	; 61
     a22:	9d 83       	std	Y+5, r25	; 0x05
     a24:	8c 83       	std	Y+4, r24	; 0x04
     a26:	7f 83       	std	Y+7, r23	; 0x07
     a28:	6e 83       	std	Y+6, r22	; 0x06
	Std_Return Delete_UserStatus = USER_DELETED;
     a2a:	85 e0       	ldi	r24, 0x05	; 5
     a2c:	8a 83       	std	Y+2, r24	; 0x02
	Std_Return Local_Return;
	uint8 Idx = 0;
     a2e:	1b 82       	std	Y+3, r1	; 0x03

	// Check if User is Already Existed in Memory
	Local_Return = User_Search(username,pass,&Idx);
     a30:	8c 81       	ldd	r24, Y+4	; 0x04
     a32:	9d 81       	ldd	r25, Y+5	; 0x05
     a34:	2e 81       	ldd	r18, Y+6	; 0x06
     a36:	3f 81       	ldd	r19, Y+7	; 0x07
     a38:	ae 01       	movw	r20, r28
     a3a:	4d 5f       	subi	r20, 0xFD	; 253
     a3c:	5f 4f       	sbci	r21, 0xFF	; 255
     a3e:	b9 01       	movw	r22, r18
     a40:	0e 94 0c 04 	call	0x818	; 0x818 <User_Search>
     a44:	89 83       	std	Y+1, r24	; 0x01

	if(Local_Return == USER_FOUND) {
     a46:	89 81       	ldd	r24, Y+1	; 0x01
     a48:	83 30       	cpi	r24, 0x03	; 3
     a4a:	e1 f5       	brne	.+120    	; 0xac4 <User_Delete+0xb6>

		// User Found and Data is Deleted
		memset(user[Idx].username,'\0',15*sizeof(char));
     a4c:	8b 81       	ldd	r24, Y+3	; 0x03
     a4e:	88 2f       	mov	r24, r24
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	88 0f       	add	r24, r24
     a54:	99 1f       	adc	r25, r25
     a56:	9c 01       	movw	r18, r24
     a58:	22 0f       	add	r18, r18
     a5a:	33 1f       	adc	r19, r19
     a5c:	22 0f       	add	r18, r18
     a5e:	33 1f       	adc	r19, r19
     a60:	22 0f       	add	r18, r18
     a62:	33 1f       	adc	r19, r19
     a64:	82 0f       	add	r24, r18
     a66:	93 1f       	adc	r25, r19
     a68:	8e 54       	subi	r24, 0x4E	; 78
     a6a:	9a 4f       	sbci	r25, 0xFA	; 250
     a6c:	60 e0       	ldi	r22, 0x00	; 0
     a6e:	70 e0       	ldi	r23, 0x00	; 0
     a70:	4f e0       	ldi	r20, 0x0F	; 15
     a72:	50 e0       	ldi	r21, 0x00	; 0
     a74:	0e 94 d1 21 	call	0x43a2	; 0x43a2 <memset>
		user[Idx].pass = 0;
     a78:	8b 81       	ldd	r24, Y+3	; 0x03
     a7a:	88 2f       	mov	r24, r24
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	88 0f       	add	r24, r24
     a80:	99 1f       	adc	r25, r25
     a82:	9c 01       	movw	r18, r24
     a84:	22 0f       	add	r18, r18
     a86:	33 1f       	adc	r19, r19
     a88:	22 0f       	add	r18, r18
     a8a:	33 1f       	adc	r19, r19
     a8c:	22 0f       	add	r18, r18
     a8e:	33 1f       	adc	r19, r19
     a90:	82 0f       	add	r24, r18
     a92:	93 1f       	adc	r25, r19
     a94:	fc 01       	movw	r30, r24
     a96:	ef 53       	subi	r30, 0x3F	; 63
     a98:	fa 4f       	sbci	r31, 0xFA	; 250
     a9a:	11 82       	std	Z+1, r1	; 0x01
     a9c:	10 82       	st	Z, r1
		user[Idx].status = FREE;
     a9e:	8b 81       	ldd	r24, Y+3	; 0x03
     aa0:	88 2f       	mov	r24, r24
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	88 0f       	add	r24, r24
     aa6:	99 1f       	adc	r25, r25
     aa8:	9c 01       	movw	r18, r24
     aaa:	22 0f       	add	r18, r18
     aac:	33 1f       	adc	r19, r19
     aae:	22 0f       	add	r18, r18
     ab0:	33 1f       	adc	r19, r19
     ab2:	22 0f       	add	r18, r18
     ab4:	33 1f       	adc	r19, r19
     ab6:	82 0f       	add	r24, r18
     ab8:	93 1f       	adc	r25, r19
     aba:	fc 01       	movw	r30, r24
     abc:	ed 53       	subi	r30, 0x3D	; 61
     abe:	fa 4f       	sbci	r31, 0xFA	; 250
     ac0:	10 82       	st	Z, r1
     ac2:	02 c0       	rjmp	.+4      	; 0xac8 <User_Delete+0xba>
	}
	else Delete_UserStatus = USER_NOT_DELETED;
     ac4:	86 e0       	ldi	r24, 0x06	; 6
     ac6:	8a 83       	std	Y+2, r24	; 0x02
	return Delete_UserStatus;
     ac8:	8a 81       	ldd	r24, Y+2	; 0x02
}
     aca:	27 96       	adiw	r28, 0x07	; 7
     acc:	0f b6       	in	r0, 0x3f	; 63
     ace:	f8 94       	cli
     ad0:	de bf       	out	0x3e, r29	; 62
     ad2:	0f be       	out	0x3f, r0	; 63
     ad4:	cd bf       	out	0x3d, r28	; 61
     ad6:	cf 91       	pop	r28
     ad8:	df 91       	pop	r29
     ada:	08 95       	ret

00000adc <User_Manage>:
 * 	@ Func  	 - User_Manage
 * 	@ Brief 	 - User Management task.
 * 	@ Param [in] - pvParameter: Pointer to task input parameters.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void User_Manage(void*pvParameter){
     adc:	df 93       	push	r29
     ade:	cf 93       	push	r28
     ae0:	00 d0       	rcall	.+0      	; 0xae2 <User_Manage+0x6>
     ae2:	0f 92       	push	r0
     ae4:	cd b7       	in	r28, 0x3d	; 61
     ae6:	de b7       	in	r29, 0x3e	; 62
     ae8:	9b 83       	std	Y+3, r25	; 0x03
     aea:	8a 83       	std	Y+2, r24	; 0x02
	uint8 Return;

	while(1){

		// Take Access to User Log In Management
		Return = xSemaphoreTake(User_Login_Access,0);
     aec:	80 91 a6 05 	lds	r24, 0x05A6
     af0:	90 91 a7 05 	lds	r25, 0x05A7
     af4:	60 e0       	ldi	r22, 0x00	; 0
     af6:	70 e0       	ldi	r23, 0x00	; 0
     af8:	40 e0       	ldi	r20, 0x00	; 0
     afa:	50 e0       	ldi	r21, 0x00	; 0
     afc:	20 e0       	ldi	r18, 0x00	; 0
     afe:	0e 94 0e 0f 	call	0x1e1c	; 0x1e1c <xQueueGenericReceive>
     b02:	89 83       	std	Y+1, r24	; 0x01
		if(Return == pdPASS) {
     b04:	89 81       	ldd	r24, Y+1	; 0x01
     b06:	81 30       	cpi	r24, 0x01	; 1
     b08:	11 f5       	brne	.+68     	; 0xb4e <User_Manage+0x72>
			if(User_Search((char*)Bluetooth.Data,atoi((char*)Bluetooth.Pass),NULL) == USER_FOUND) MCAL_UART_Send(ACCEPT_ACCESS);
     b0a:	85 e9       	ldi	r24, 0x95	; 149
     b0c:	95 e0       	ldi	r25, 0x05	; 5
     b0e:	0e 94 aa 21 	call	0x4354	; 0x4354 <atoi>
     b12:	9c 01       	movw	r18, r24
     b14:	86 e8       	ldi	r24, 0x86	; 134
     b16:	95 e0       	ldi	r25, 0x05	; 5
     b18:	b9 01       	movw	r22, r18
     b1a:	40 e0       	ldi	r20, 0x00	; 0
     b1c:	50 e0       	ldi	r21, 0x00	; 0
     b1e:	0e 94 0c 04 	call	0x818	; 0x818 <User_Search>
     b22:	83 30       	cpi	r24, 0x03	; 3
     b24:	29 f4       	brne	.+10     	; 0xb30 <User_Manage+0x54>
     b26:	81 e0       	ldi	r24, 0x01	; 1
     b28:	90 e0       	ldi	r25, 0x00	; 0
     b2a:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <MCAL_UART_Send>
     b2e:	04 c0       	rjmp	.+8      	; 0xb38 <User_Manage+0x5c>
			else MCAL_UART_Send(REFUSE_ACCESS);
     b30:	80 e0       	ldi	r24, 0x00	; 0
     b32:	90 e0       	ldi	r25, 0x00	; 0
     b34:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <MCAL_UART_Send>

			// Give Access to Bluetooth Frame Again
			xSemaphoreGive(Bluetooth_Data_Access);
     b38:	80 91 9c 05 	lds	r24, 0x059C
     b3c:	90 91 9d 05 	lds	r25, 0x059D
     b40:	60 e0       	ldi	r22, 0x00	; 0
     b42:	70 e0       	ldi	r23, 0x00	; 0
     b44:	40 e0       	ldi	r20, 0x00	; 0
     b46:	50 e0       	ldi	r21, 0x00	; 0
     b48:	20 e0       	ldi	r18, 0x00	; 0
     b4a:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xQueueGenericSend>
		}

		// Take Access to Add User Management
		Return = xSemaphoreTake(User_Add_Access,0);
     b4e:	80 91 ae 05 	lds	r24, 0x05AE
     b52:	90 91 af 05 	lds	r25, 0x05AF
     b56:	60 e0       	ldi	r22, 0x00	; 0
     b58:	70 e0       	ldi	r23, 0x00	; 0
     b5a:	40 e0       	ldi	r20, 0x00	; 0
     b5c:	50 e0       	ldi	r21, 0x00	; 0
     b5e:	20 e0       	ldi	r18, 0x00	; 0
     b60:	0e 94 0e 0f 	call	0x1e1c	; 0x1e1c <xQueueGenericReceive>
     b64:	89 83       	std	Y+1, r24	; 0x01
		if(Return == pdPASS) {
     b66:	89 81       	ldd	r24, Y+1	; 0x01
     b68:	81 30       	cpi	r24, 0x01	; 1
     b6a:	01 f5       	brne	.+64     	; 0xbac <User_Manage+0xd0>
			if(User_Add((char*)Bluetooth.Data,atoi((char*)Bluetooth.Pass)) == USER_ADD_DONE) MCAL_UART_Send(ACCEPT_ACCESS);
     b6c:	85 e9       	ldi	r24, 0x95	; 149
     b6e:	95 e0       	ldi	r25, 0x05	; 5
     b70:	0e 94 aa 21 	call	0x4354	; 0x4354 <atoi>
     b74:	9c 01       	movw	r18, r24
     b76:	86 e8       	ldi	r24, 0x86	; 134
     b78:	95 e0       	ldi	r25, 0x05	; 5
     b7a:	b9 01       	movw	r22, r18
     b7c:	0e 94 82 04 	call	0x904	; 0x904 <User_Add>
     b80:	81 30       	cpi	r24, 0x01	; 1
     b82:	29 f4       	brne	.+10     	; 0xb8e <User_Manage+0xb2>
     b84:	81 e0       	ldi	r24, 0x01	; 1
     b86:	90 e0       	ldi	r25, 0x00	; 0
     b88:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <MCAL_UART_Send>
     b8c:	04 c0       	rjmp	.+8      	; 0xb96 <User_Manage+0xba>
			else MCAL_UART_Send(REFUSE_ACCESS);
     b8e:	80 e0       	ldi	r24, 0x00	; 0
     b90:	90 e0       	ldi	r25, 0x00	; 0
     b92:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <MCAL_UART_Send>

			// Give Access to Bluetooth Frame Again
			xSemaphoreGive(Bluetooth_Data_Access);
     b96:	80 91 9c 05 	lds	r24, 0x059C
     b9a:	90 91 9d 05 	lds	r25, 0x059D
     b9e:	60 e0       	ldi	r22, 0x00	; 0
     ba0:	70 e0       	ldi	r23, 0x00	; 0
     ba2:	40 e0       	ldi	r20, 0x00	; 0
     ba4:	50 e0       	ldi	r21, 0x00	; 0
     ba6:	20 e0       	ldi	r18, 0x00	; 0
     ba8:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xQueueGenericSend>
		}

		// Take Access to Remove User Management
		Return = xSemaphoreTake(User_Remove_Access,0);
     bac:	80 91 a8 05 	lds	r24, 0x05A8
     bb0:	90 91 a9 05 	lds	r25, 0x05A9
     bb4:	60 e0       	ldi	r22, 0x00	; 0
     bb6:	70 e0       	ldi	r23, 0x00	; 0
     bb8:	40 e0       	ldi	r20, 0x00	; 0
     bba:	50 e0       	ldi	r21, 0x00	; 0
     bbc:	20 e0       	ldi	r18, 0x00	; 0
     bbe:	0e 94 0e 0f 	call	0x1e1c	; 0x1e1c <xQueueGenericReceive>
     bc2:	89 83       	std	Y+1, r24	; 0x01
		if(Return == pdPASS) {
     bc4:	89 81       	ldd	r24, Y+1	; 0x01
     bc6:	81 30       	cpi	r24, 0x01	; 1
     bc8:	01 f5       	brne	.+64     	; 0xc0a <User_Manage+0x12e>
			if(User_Delete((char*)Bluetooth.Data,atoi((char*)Bluetooth.Pass)) == USER_DELETED) MCAL_UART_Send(ACCEPT_ACCESS);
     bca:	85 e9       	ldi	r24, 0x95	; 149
     bcc:	95 e0       	ldi	r25, 0x05	; 5
     bce:	0e 94 aa 21 	call	0x4354	; 0x4354 <atoi>
     bd2:	9c 01       	movw	r18, r24
     bd4:	86 e8       	ldi	r24, 0x86	; 134
     bd6:	95 e0       	ldi	r25, 0x05	; 5
     bd8:	b9 01       	movw	r22, r18
     bda:	0e 94 07 05 	call	0xa0e	; 0xa0e <User_Delete>
     bde:	85 30       	cpi	r24, 0x05	; 5
     be0:	29 f4       	brne	.+10     	; 0xbec <User_Manage+0x110>
     be2:	81 e0       	ldi	r24, 0x01	; 1
     be4:	90 e0       	ldi	r25, 0x00	; 0
     be6:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <MCAL_UART_Send>
     bea:	04 c0       	rjmp	.+8      	; 0xbf4 <User_Manage+0x118>
			else MCAL_UART_Send(REFUSE_ACCESS);
     bec:	80 e0       	ldi	r24, 0x00	; 0
     bee:	90 e0       	ldi	r25, 0x00	; 0
     bf0:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <MCAL_UART_Send>

			// Give Access to Bluetooth Frame Again
			xSemaphoreGive(Bluetooth_Data_Access);
     bf4:	80 91 9c 05 	lds	r24, 0x059C
     bf8:	90 91 9d 05 	lds	r25, 0x059D
     bfc:	60 e0       	ldi	r22, 0x00	; 0
     bfe:	70 e0       	ldi	r23, 0x00	; 0
     c00:	40 e0       	ldi	r20, 0x00	; 0
     c02:	50 e0       	ldi	r21, 0x00	; 0
     c04:	20 e0       	ldi	r18, 0x00	; 0
     c06:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xQueueGenericSend>
		}

		vTaskDelay(3);
     c0a:	83 e0       	ldi	r24, 0x03	; 3
     c0c:	90 e0       	ldi	r25, 0x00	; 0
     c0e:	0e 94 bf 13 	call	0x277e	; 0x277e <vTaskDelay>
     c12:	6c cf       	rjmp	.-296    	; 0xaec <User_Manage+0x10>

00000c14 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     c14:	df 93       	push	r29
     c16:	cf 93       	push	r28
     c18:	cd b7       	in	r28, 0x3d	; 61
     c1a:	de b7       	in	r29, 0x3e	; 62
     c1c:	27 97       	sbiw	r28, 0x07	; 7
     c1e:	0f b6       	in	r0, 0x3f	; 63
     c20:	f8 94       	cli
     c22:	de bf       	out	0x3e, r29	; 62
     c24:	0f be       	out	0x3f, r0	; 63
     c26:	cd bf       	out	0x3d, r28	; 61
     c28:	9d 83       	std	Y+5, r25	; 0x05
     c2a:	8c 83       	std	Y+4, r24	; 0x04
     c2c:	6e 83       	std	Y+6, r22	; 0x06
     c2e:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     c30:	8a e1       	ldi	r24, 0x1A	; 26
     c32:	90 e0       	ldi	r25, 0x00	; 0
     c34:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <pvPortMalloc>
     c38:	9a 83       	std	Y+2, r25	; 0x02
     c3a:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     c3c:	89 81       	ldd	r24, Y+1	; 0x01
     c3e:	9a 81       	ldd	r25, Y+2	; 0x02
     c40:	00 97       	sbiw	r24, 0x00	; 0
     c42:	09 f4       	brne	.+2      	; 0xc46 <xCoRoutineCreate+0x32>
     c44:	6f c0       	rjmp	.+222    	; 0xd24 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     c46:	80 91 a2 00 	lds	r24, 0x00A2
     c4a:	90 91 a3 00 	lds	r25, 0x00A3
     c4e:	00 97       	sbiw	r24, 0x00	; 0
     c50:	41 f4       	brne	.+16     	; 0xc62 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     c52:	89 81       	ldd	r24, Y+1	; 0x01
     c54:	9a 81       	ldd	r25, Y+2	; 0x02
     c56:	90 93 a3 00 	sts	0x00A3, r25
     c5a:	80 93 a2 00 	sts	0x00A2, r24
			prvInitialiseCoRoutineLists();
     c5e:	0e 94 71 08 	call	0x10e2	; 0x10e2 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     c62:	8e 81       	ldd	r24, Y+6	; 0x06
     c64:	82 30       	cpi	r24, 0x02	; 2
     c66:	10 f0       	brcs	.+4      	; 0xc6c <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     c68:	81 e0       	ldi	r24, 0x01	; 1
     c6a:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     c6c:	e9 81       	ldd	r30, Y+1	; 0x01
     c6e:	fa 81       	ldd	r31, Y+2	; 0x02
     c70:	11 8e       	std	Z+25, r1	; 0x19
     c72:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     c74:	e9 81       	ldd	r30, Y+1	; 0x01
     c76:	fa 81       	ldd	r31, Y+2	; 0x02
     c78:	8e 81       	ldd	r24, Y+6	; 0x06
     c7a:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     c7c:	e9 81       	ldd	r30, Y+1	; 0x01
     c7e:	fa 81       	ldd	r31, Y+2	; 0x02
     c80:	8f 81       	ldd	r24, Y+7	; 0x07
     c82:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     c84:	e9 81       	ldd	r30, Y+1	; 0x01
     c86:	fa 81       	ldd	r31, Y+2	; 0x02
     c88:	8c 81       	ldd	r24, Y+4	; 0x04
     c8a:	9d 81       	ldd	r25, Y+5	; 0x05
     c8c:	91 83       	std	Z+1, r25	; 0x01
     c8e:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     c90:	89 81       	ldd	r24, Y+1	; 0x01
     c92:	9a 81       	ldd	r25, Y+2	; 0x02
     c94:	02 96       	adiw	r24, 0x02	; 2
     c96:	0e 94 78 09 	call	0x12f0	; 0x12f0 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     c9a:	89 81       	ldd	r24, Y+1	; 0x01
     c9c:	9a 81       	ldd	r25, Y+2	; 0x02
     c9e:	0c 96       	adiw	r24, 0x0c	; 12
     ca0:	0e 94 78 09 	call	0x12f0	; 0x12f0 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     ca4:	e9 81       	ldd	r30, Y+1	; 0x01
     ca6:	fa 81       	ldd	r31, Y+2	; 0x02
     ca8:	89 81       	ldd	r24, Y+1	; 0x01
     caa:	9a 81       	ldd	r25, Y+2	; 0x02
     cac:	91 87       	std	Z+9, r25	; 0x09
     cae:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     cb0:	e9 81       	ldd	r30, Y+1	; 0x01
     cb2:	fa 81       	ldd	r31, Y+2	; 0x02
     cb4:	89 81       	ldd	r24, Y+1	; 0x01
     cb6:	9a 81       	ldd	r25, Y+2	; 0x02
     cb8:	93 8b       	std	Z+19, r25	; 0x13
     cba:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     cbc:	8e 81       	ldd	r24, Y+6	; 0x06
     cbe:	28 2f       	mov	r18, r24
     cc0:	30 e0       	ldi	r19, 0x00	; 0
     cc2:	84 e0       	ldi	r24, 0x04	; 4
     cc4:	90 e0       	ldi	r25, 0x00	; 0
     cc6:	82 1b       	sub	r24, r18
     cc8:	93 0b       	sbc	r25, r19
     cca:	e9 81       	ldd	r30, Y+1	; 0x01
     ccc:	fa 81       	ldd	r31, Y+2	; 0x02
     cce:	95 87       	std	Z+13, r25	; 0x0d
     cd0:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     cd2:	e9 81       	ldd	r30, Y+1	; 0x01
     cd4:	fa 81       	ldd	r31, Y+2	; 0x02
     cd6:	96 89       	ldd	r25, Z+22	; 0x16
     cd8:	80 91 a4 00 	lds	r24, 0x00A4
     cdc:	89 17       	cp	r24, r25
     cde:	28 f4       	brcc	.+10     	; 0xcea <xCoRoutineCreate+0xd6>
     ce0:	e9 81       	ldd	r30, Y+1	; 0x01
     ce2:	fa 81       	ldd	r31, Y+2	; 0x02
     ce4:	86 89       	ldd	r24, Z+22	; 0x16
     ce6:	80 93 a4 00 	sts	0x00A4, r24
     cea:	e9 81       	ldd	r30, Y+1	; 0x01
     cec:	fa 81       	ldd	r31, Y+2	; 0x02
     cee:	86 89       	ldd	r24, Z+22	; 0x16
     cf0:	28 2f       	mov	r18, r24
     cf2:	30 e0       	ldi	r19, 0x00	; 0
     cf4:	c9 01       	movw	r24, r18
     cf6:	88 0f       	add	r24, r24
     cf8:	99 1f       	adc	r25, r25
     cfa:	88 0f       	add	r24, r24
     cfc:	99 1f       	adc	r25, r25
     cfe:	88 0f       	add	r24, r24
     d00:	99 1f       	adc	r25, r25
     d02:	82 0f       	add	r24, r18
     d04:	93 1f       	adc	r25, r19
     d06:	ac 01       	movw	r20, r24
     d08:	45 55       	subi	r20, 0x55	; 85
     d0a:	5f 4f       	sbci	r21, 0xFF	; 255
     d0c:	89 81       	ldd	r24, Y+1	; 0x01
     d0e:	9a 81       	ldd	r25, Y+2	; 0x02
     d10:	9c 01       	movw	r18, r24
     d12:	2e 5f       	subi	r18, 0xFE	; 254
     d14:	3f 4f       	sbci	r19, 0xFF	; 255
     d16:	ca 01       	movw	r24, r20
     d18:	b9 01       	movw	r22, r18
     d1a:	0e 94 88 09 	call	0x1310	; 0x1310 <vListInsertEnd>

		xReturn = pdPASS;
     d1e:	81 e0       	ldi	r24, 0x01	; 1
     d20:	8b 83       	std	Y+3, r24	; 0x03
     d22:	02 c0       	rjmp	.+4      	; 0xd28 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     d24:	8f ef       	ldi	r24, 0xFF	; 255
     d26:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     d28:	8b 81       	ldd	r24, Y+3	; 0x03
}
     d2a:	27 96       	adiw	r28, 0x07	; 7
     d2c:	0f b6       	in	r0, 0x3f	; 63
     d2e:	f8 94       	cli
     d30:	de bf       	out	0x3e, r29	; 62
     d32:	0f be       	out	0x3f, r0	; 63
     d34:	cd bf       	out	0x3d, r28	; 61
     d36:	cf 91       	pop	r28
     d38:	df 91       	pop	r29
     d3a:	08 95       	ret

00000d3c <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     d3c:	df 93       	push	r29
     d3e:	cf 93       	push	r28
     d40:	00 d0       	rcall	.+0      	; 0xd42 <vCoRoutineAddToDelayedList+0x6>
     d42:	00 d0       	rcall	.+0      	; 0xd44 <vCoRoutineAddToDelayedList+0x8>
     d44:	00 d0       	rcall	.+0      	; 0xd46 <vCoRoutineAddToDelayedList+0xa>
     d46:	cd b7       	in	r28, 0x3d	; 61
     d48:	de b7       	in	r29, 0x3e	; 62
     d4a:	9c 83       	std	Y+4, r25	; 0x04
     d4c:	8b 83       	std	Y+3, r24	; 0x03
     d4e:	7e 83       	std	Y+6, r23	; 0x06
     d50:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     d52:	20 91 a5 00 	lds	r18, 0x00A5
     d56:	30 91 a6 00 	lds	r19, 0x00A6
     d5a:	8b 81       	ldd	r24, Y+3	; 0x03
     d5c:	9c 81       	ldd	r25, Y+4	; 0x04
     d5e:	82 0f       	add	r24, r18
     d60:	93 1f       	adc	r25, r19
     d62:	9a 83       	std	Y+2, r25	; 0x02
     d64:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     d66:	80 91 a2 00 	lds	r24, 0x00A2
     d6a:	90 91 a3 00 	lds	r25, 0x00A3
     d6e:	02 96       	adiw	r24, 0x02	; 2
     d70:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     d74:	e0 91 a2 00 	lds	r30, 0x00A2
     d78:	f0 91 a3 00 	lds	r31, 0x00A3
     d7c:	89 81       	ldd	r24, Y+1	; 0x01
     d7e:	9a 81       	ldd	r25, Y+2	; 0x02
     d80:	93 83       	std	Z+3, r25	; 0x03
     d82:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     d84:	20 91 a5 00 	lds	r18, 0x00A5
     d88:	30 91 a6 00 	lds	r19, 0x00A6
     d8c:	89 81       	ldd	r24, Y+1	; 0x01
     d8e:	9a 81       	ldd	r25, Y+2	; 0x02
     d90:	82 17       	cp	r24, r18
     d92:	93 07       	cpc	r25, r19
     d94:	70 f4       	brcc	.+28     	; 0xdb2 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     d96:	80 91 d1 00 	lds	r24, 0x00D1
     d9a:	90 91 d2 00 	lds	r25, 0x00D2
     d9e:	20 91 a2 00 	lds	r18, 0x00A2
     da2:	30 91 a3 00 	lds	r19, 0x00A3
     da6:	2e 5f       	subi	r18, 0xFE	; 254
     da8:	3f 4f       	sbci	r19, 0xFF	; 255
     daa:	b9 01       	movw	r22, r18
     dac:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <vListInsert>
     db0:	0d c0       	rjmp	.+26     	; 0xdcc <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     db2:	80 91 cf 00 	lds	r24, 0x00CF
     db6:	90 91 d0 00 	lds	r25, 0x00D0
     dba:	20 91 a2 00 	lds	r18, 0x00A2
     dbe:	30 91 a3 00 	lds	r19, 0x00A3
     dc2:	2e 5f       	subi	r18, 0xFE	; 254
     dc4:	3f 4f       	sbci	r19, 0xFF	; 255
     dc6:	b9 01       	movw	r22, r18
     dc8:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <vListInsert>
	}

	if( pxEventList )
     dcc:	8d 81       	ldd	r24, Y+5	; 0x05
     dce:	9e 81       	ldd	r25, Y+6	; 0x06
     dd0:	00 97       	sbiw	r24, 0x00	; 0
     dd2:	61 f0       	breq	.+24     	; 0xdec <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     dd4:	80 91 a2 00 	lds	r24, 0x00A2
     dd8:	90 91 a3 00 	lds	r25, 0x00A3
     ddc:	9c 01       	movw	r18, r24
     dde:	24 5f       	subi	r18, 0xF4	; 244
     de0:	3f 4f       	sbci	r19, 0xFF	; 255
     de2:	8d 81       	ldd	r24, Y+5	; 0x05
     de4:	9e 81       	ldd	r25, Y+6	; 0x06
     de6:	b9 01       	movw	r22, r18
     de8:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <vListInsert>
	}
}
     dec:	26 96       	adiw	r28, 0x06	; 6
     dee:	0f b6       	in	r0, 0x3f	; 63
     df0:	f8 94       	cli
     df2:	de bf       	out	0x3e, r29	; 62
     df4:	0f be       	out	0x3f, r0	; 63
     df6:	cd bf       	out	0x3d, r28	; 61
     df8:	cf 91       	pop	r28
     dfa:	df 91       	pop	r29
     dfc:	08 95       	ret

00000dfe <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     dfe:	df 93       	push	r29
     e00:	cf 93       	push	r28
     e02:	00 d0       	rcall	.+0      	; 0xe04 <prvCheckPendingReadyList+0x6>
     e04:	cd b7       	in	r28, 0x3d	; 61
     e06:	de b7       	in	r29, 0x3e	; 62
     e08:	3a c0       	rjmp	.+116    	; 0xe7e <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     e0a:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     e0c:	e0 91 d8 00 	lds	r30, 0x00D8
     e10:	f0 91 d9 00 	lds	r31, 0x00D9
     e14:	86 81       	ldd	r24, Z+6	; 0x06
     e16:	97 81       	ldd	r25, Z+7	; 0x07
     e18:	9a 83       	std	Y+2, r25	; 0x02
     e1a:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     e1c:	89 81       	ldd	r24, Y+1	; 0x01
     e1e:	9a 81       	ldd	r25, Y+2	; 0x02
     e20:	0c 96       	adiw	r24, 0x0c	; 12
     e22:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     e26:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     e28:	89 81       	ldd	r24, Y+1	; 0x01
     e2a:	9a 81       	ldd	r25, Y+2	; 0x02
     e2c:	02 96       	adiw	r24, 0x02	; 2
     e2e:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     e32:	e9 81       	ldd	r30, Y+1	; 0x01
     e34:	fa 81       	ldd	r31, Y+2	; 0x02
     e36:	96 89       	ldd	r25, Z+22	; 0x16
     e38:	80 91 a4 00 	lds	r24, 0x00A4
     e3c:	89 17       	cp	r24, r25
     e3e:	28 f4       	brcc	.+10     	; 0xe4a <prvCheckPendingReadyList+0x4c>
     e40:	e9 81       	ldd	r30, Y+1	; 0x01
     e42:	fa 81       	ldd	r31, Y+2	; 0x02
     e44:	86 89       	ldd	r24, Z+22	; 0x16
     e46:	80 93 a4 00 	sts	0x00A4, r24
     e4a:	e9 81       	ldd	r30, Y+1	; 0x01
     e4c:	fa 81       	ldd	r31, Y+2	; 0x02
     e4e:	86 89       	ldd	r24, Z+22	; 0x16
     e50:	28 2f       	mov	r18, r24
     e52:	30 e0       	ldi	r19, 0x00	; 0
     e54:	c9 01       	movw	r24, r18
     e56:	88 0f       	add	r24, r24
     e58:	99 1f       	adc	r25, r25
     e5a:	88 0f       	add	r24, r24
     e5c:	99 1f       	adc	r25, r25
     e5e:	88 0f       	add	r24, r24
     e60:	99 1f       	adc	r25, r25
     e62:	82 0f       	add	r24, r18
     e64:	93 1f       	adc	r25, r19
     e66:	ac 01       	movw	r20, r24
     e68:	45 55       	subi	r20, 0x55	; 85
     e6a:	5f 4f       	sbci	r21, 0xFF	; 255
     e6c:	89 81       	ldd	r24, Y+1	; 0x01
     e6e:	9a 81       	ldd	r25, Y+2	; 0x02
     e70:	9c 01       	movw	r18, r24
     e72:	2e 5f       	subi	r18, 0xFE	; 254
     e74:	3f 4f       	sbci	r19, 0xFF	; 255
     e76:	ca 01       	movw	r24, r20
     e78:	b9 01       	movw	r22, r18
     e7a:	0e 94 88 09 	call	0x1310	; 0x1310 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     e7e:	80 91 d3 00 	lds	r24, 0x00D3
     e82:	88 23       	and	r24, r24
     e84:	09 f0       	breq	.+2      	; 0xe88 <prvCheckPendingReadyList+0x8a>
     e86:	c1 cf       	rjmp	.-126    	; 0xe0a <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     e88:	0f 90       	pop	r0
     e8a:	0f 90       	pop	r0
     e8c:	cf 91       	pop	r28
     e8e:	df 91       	pop	r29
     e90:	08 95       	ret

00000e92 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     e92:	df 93       	push	r29
     e94:	cf 93       	push	r28
     e96:	00 d0       	rcall	.+0      	; 0xe98 <prvCheckDelayedList+0x6>
     e98:	00 d0       	rcall	.+0      	; 0xe9a <prvCheckDelayedList+0x8>
     e9a:	cd b7       	in	r28, 0x3d	; 61
     e9c:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     e9e:	0e 94 cd 14 	call	0x299a	; 0x299a <xTaskGetTickCount>
     ea2:	20 91 a7 00 	lds	r18, 0x00A7
     ea6:	30 91 a8 00 	lds	r19, 0x00A8
     eaa:	82 1b       	sub	r24, r18
     eac:	93 0b       	sbc	r25, r19
     eae:	90 93 aa 00 	sts	0x00AA, r25
     eb2:	80 93 a9 00 	sts	0x00A9, r24
     eb6:	85 c0       	rjmp	.+266    	; 0xfc2 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     eb8:	80 91 a5 00 	lds	r24, 0x00A5
     ebc:	90 91 a6 00 	lds	r25, 0x00A6
     ec0:	01 96       	adiw	r24, 0x01	; 1
     ec2:	90 93 a6 00 	sts	0x00A6, r25
     ec6:	80 93 a5 00 	sts	0x00A5, r24
		xPassedTicks--;
     eca:	80 91 a9 00 	lds	r24, 0x00A9
     ece:	90 91 aa 00 	lds	r25, 0x00AA
     ed2:	01 97       	sbiw	r24, 0x01	; 1
     ed4:	90 93 aa 00 	sts	0x00AA, r25
     ed8:	80 93 a9 00 	sts	0x00A9, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     edc:	80 91 a5 00 	lds	r24, 0x00A5
     ee0:	90 91 a6 00 	lds	r25, 0x00A6
     ee4:	00 97       	sbiw	r24, 0x00	; 0
     ee6:	09 f0       	breq	.+2      	; 0xeea <prvCheckDelayedList+0x58>
     ee8:	64 c0       	rjmp	.+200    	; 0xfb2 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     eea:	80 91 cf 00 	lds	r24, 0x00CF
     eee:	90 91 d0 00 	lds	r25, 0x00D0
     ef2:	9a 83       	std	Y+2, r25	; 0x02
     ef4:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     ef6:	80 91 d1 00 	lds	r24, 0x00D1
     efa:	90 91 d2 00 	lds	r25, 0x00D2
     efe:	90 93 d0 00 	sts	0x00D0, r25
     f02:	80 93 cf 00 	sts	0x00CF, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     f06:	89 81       	ldd	r24, Y+1	; 0x01
     f08:	9a 81       	ldd	r25, Y+2	; 0x02
     f0a:	90 93 d2 00 	sts	0x00D2, r25
     f0e:	80 93 d1 00 	sts	0x00D1, r24
     f12:	4f c0       	rjmp	.+158    	; 0xfb2 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     f14:	e0 91 cf 00 	lds	r30, 0x00CF
     f18:	f0 91 d0 00 	lds	r31, 0x00D0
     f1c:	05 80       	ldd	r0, Z+5	; 0x05
     f1e:	f6 81       	ldd	r31, Z+6	; 0x06
     f20:	e0 2d       	mov	r30, r0
     f22:	86 81       	ldd	r24, Z+6	; 0x06
     f24:	97 81       	ldd	r25, Z+7	; 0x07
     f26:	9c 83       	std	Y+4, r25	; 0x04
     f28:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     f2a:	eb 81       	ldd	r30, Y+3	; 0x03
     f2c:	fc 81       	ldd	r31, Y+4	; 0x04
     f2e:	22 81       	ldd	r18, Z+2	; 0x02
     f30:	33 81       	ldd	r19, Z+3	; 0x03
     f32:	80 91 a5 00 	lds	r24, 0x00A5
     f36:	90 91 a6 00 	lds	r25, 0x00A6
     f3a:	82 17       	cp	r24, r18
     f3c:	93 07       	cpc	r25, r19
     f3e:	08 f4       	brcc	.+2      	; 0xf42 <prvCheckDelayedList+0xb0>
     f40:	40 c0       	rjmp	.+128    	; 0xfc2 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     f42:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     f44:	8b 81       	ldd	r24, Y+3	; 0x03
     f46:	9c 81       	ldd	r25, Y+4	; 0x04
     f48:	02 96       	adiw	r24, 0x02	; 2
     f4a:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     f4e:	eb 81       	ldd	r30, Y+3	; 0x03
     f50:	fc 81       	ldd	r31, Y+4	; 0x04
     f52:	84 89       	ldd	r24, Z+20	; 0x14
     f54:	95 89       	ldd	r25, Z+21	; 0x15
     f56:	00 97       	sbiw	r24, 0x00	; 0
     f58:	29 f0       	breq	.+10     	; 0xf64 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     f5a:	8b 81       	ldd	r24, Y+3	; 0x03
     f5c:	9c 81       	ldd	r25, Y+4	; 0x04
     f5e:	0c 96       	adiw	r24, 0x0c	; 12
     f60:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     f64:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     f66:	eb 81       	ldd	r30, Y+3	; 0x03
     f68:	fc 81       	ldd	r31, Y+4	; 0x04
     f6a:	96 89       	ldd	r25, Z+22	; 0x16
     f6c:	80 91 a4 00 	lds	r24, 0x00A4
     f70:	89 17       	cp	r24, r25
     f72:	28 f4       	brcc	.+10     	; 0xf7e <prvCheckDelayedList+0xec>
     f74:	eb 81       	ldd	r30, Y+3	; 0x03
     f76:	fc 81       	ldd	r31, Y+4	; 0x04
     f78:	86 89       	ldd	r24, Z+22	; 0x16
     f7a:	80 93 a4 00 	sts	0x00A4, r24
     f7e:	eb 81       	ldd	r30, Y+3	; 0x03
     f80:	fc 81       	ldd	r31, Y+4	; 0x04
     f82:	86 89       	ldd	r24, Z+22	; 0x16
     f84:	28 2f       	mov	r18, r24
     f86:	30 e0       	ldi	r19, 0x00	; 0
     f88:	c9 01       	movw	r24, r18
     f8a:	88 0f       	add	r24, r24
     f8c:	99 1f       	adc	r25, r25
     f8e:	88 0f       	add	r24, r24
     f90:	99 1f       	adc	r25, r25
     f92:	88 0f       	add	r24, r24
     f94:	99 1f       	adc	r25, r25
     f96:	82 0f       	add	r24, r18
     f98:	93 1f       	adc	r25, r19
     f9a:	ac 01       	movw	r20, r24
     f9c:	45 55       	subi	r20, 0x55	; 85
     f9e:	5f 4f       	sbci	r21, 0xFF	; 255
     fa0:	8b 81       	ldd	r24, Y+3	; 0x03
     fa2:	9c 81       	ldd	r25, Y+4	; 0x04
     fa4:	9c 01       	movw	r18, r24
     fa6:	2e 5f       	subi	r18, 0xFE	; 254
     fa8:	3f 4f       	sbci	r19, 0xFF	; 255
     faa:	ca 01       	movw	r24, r20
     fac:	b9 01       	movw	r22, r18
     fae:	0e 94 88 09 	call	0x1310	; 0x1310 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     fb2:	e0 91 cf 00 	lds	r30, 0x00CF
     fb6:	f0 91 d0 00 	lds	r31, 0x00D0
     fba:	80 81       	ld	r24, Z
     fbc:	88 23       	and	r24, r24
     fbe:	09 f0       	breq	.+2      	; 0xfc2 <prvCheckDelayedList+0x130>
     fc0:	a9 cf       	rjmp	.-174    	; 0xf14 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     fc2:	80 91 a9 00 	lds	r24, 0x00A9
     fc6:	90 91 aa 00 	lds	r25, 0x00AA
     fca:	00 97       	sbiw	r24, 0x00	; 0
     fcc:	09 f0       	breq	.+2      	; 0xfd0 <prvCheckDelayedList+0x13e>
     fce:	74 cf       	rjmp	.-280    	; 0xeb8 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     fd0:	80 91 a5 00 	lds	r24, 0x00A5
     fd4:	90 91 a6 00 	lds	r25, 0x00A6
     fd8:	90 93 a8 00 	sts	0x00A8, r25
     fdc:	80 93 a7 00 	sts	0x00A7, r24
}
     fe0:	0f 90       	pop	r0
     fe2:	0f 90       	pop	r0
     fe4:	0f 90       	pop	r0
     fe6:	0f 90       	pop	r0
     fe8:	cf 91       	pop	r28
     fea:	df 91       	pop	r29
     fec:	08 95       	ret

00000fee <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     fee:	df 93       	push	r29
     ff0:	cf 93       	push	r28
     ff2:	00 d0       	rcall	.+0      	; 0xff4 <vCoRoutineSchedule+0x6>
     ff4:	cd b7       	in	r28, 0x3d	; 61
     ff6:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     ff8:	0e 94 ff 06 	call	0xdfe	; 0xdfe <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     ffc:	0e 94 49 07 	call	0xe92	; 0xe92 <prvCheckDelayedList>
    1000:	0a c0       	rjmp	.+20     	; 0x1016 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1002:	80 91 a4 00 	lds	r24, 0x00A4
    1006:	88 23       	and	r24, r24
    1008:	09 f4       	brne	.+2      	; 0x100c <vCoRoutineSchedule+0x1e>
    100a:	66 c0       	rjmp	.+204    	; 0x10d8 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    100c:	80 91 a4 00 	lds	r24, 0x00A4
    1010:	81 50       	subi	r24, 0x01	; 1
    1012:	80 93 a4 00 	sts	0x00A4, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1016:	80 91 a4 00 	lds	r24, 0x00A4
    101a:	28 2f       	mov	r18, r24
    101c:	30 e0       	ldi	r19, 0x00	; 0
    101e:	c9 01       	movw	r24, r18
    1020:	88 0f       	add	r24, r24
    1022:	99 1f       	adc	r25, r25
    1024:	88 0f       	add	r24, r24
    1026:	99 1f       	adc	r25, r25
    1028:	88 0f       	add	r24, r24
    102a:	99 1f       	adc	r25, r25
    102c:	82 0f       	add	r24, r18
    102e:	93 1f       	adc	r25, r19
    1030:	fc 01       	movw	r30, r24
    1032:	e5 55       	subi	r30, 0x55	; 85
    1034:	ff 4f       	sbci	r31, 0xFF	; 255
    1036:	80 81       	ld	r24, Z
    1038:	88 23       	and	r24, r24
    103a:	19 f3       	breq	.-58     	; 0x1002 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    103c:	80 91 a4 00 	lds	r24, 0x00A4
    1040:	28 2f       	mov	r18, r24
    1042:	30 e0       	ldi	r19, 0x00	; 0
    1044:	c9 01       	movw	r24, r18
    1046:	88 0f       	add	r24, r24
    1048:	99 1f       	adc	r25, r25
    104a:	88 0f       	add	r24, r24
    104c:	99 1f       	adc	r25, r25
    104e:	88 0f       	add	r24, r24
    1050:	99 1f       	adc	r25, r25
    1052:	82 0f       	add	r24, r18
    1054:	93 1f       	adc	r25, r19
    1056:	85 55       	subi	r24, 0x55	; 85
    1058:	9f 4f       	sbci	r25, 0xFF	; 255
    105a:	9a 83       	std	Y+2, r25	; 0x02
    105c:	89 83       	std	Y+1, r24	; 0x01
    105e:	e9 81       	ldd	r30, Y+1	; 0x01
    1060:	fa 81       	ldd	r31, Y+2	; 0x02
    1062:	01 80       	ldd	r0, Z+1	; 0x01
    1064:	f2 81       	ldd	r31, Z+2	; 0x02
    1066:	e0 2d       	mov	r30, r0
    1068:	82 81       	ldd	r24, Z+2	; 0x02
    106a:	93 81       	ldd	r25, Z+3	; 0x03
    106c:	e9 81       	ldd	r30, Y+1	; 0x01
    106e:	fa 81       	ldd	r31, Y+2	; 0x02
    1070:	92 83       	std	Z+2, r25	; 0x02
    1072:	81 83       	std	Z+1, r24	; 0x01
    1074:	e9 81       	ldd	r30, Y+1	; 0x01
    1076:	fa 81       	ldd	r31, Y+2	; 0x02
    1078:	21 81       	ldd	r18, Z+1	; 0x01
    107a:	32 81       	ldd	r19, Z+2	; 0x02
    107c:	89 81       	ldd	r24, Y+1	; 0x01
    107e:	9a 81       	ldd	r25, Y+2	; 0x02
    1080:	03 96       	adiw	r24, 0x03	; 3
    1082:	28 17       	cp	r18, r24
    1084:	39 07       	cpc	r19, r25
    1086:	59 f4       	brne	.+22     	; 0x109e <vCoRoutineSchedule+0xb0>
    1088:	e9 81       	ldd	r30, Y+1	; 0x01
    108a:	fa 81       	ldd	r31, Y+2	; 0x02
    108c:	01 80       	ldd	r0, Z+1	; 0x01
    108e:	f2 81       	ldd	r31, Z+2	; 0x02
    1090:	e0 2d       	mov	r30, r0
    1092:	82 81       	ldd	r24, Z+2	; 0x02
    1094:	93 81       	ldd	r25, Z+3	; 0x03
    1096:	e9 81       	ldd	r30, Y+1	; 0x01
    1098:	fa 81       	ldd	r31, Y+2	; 0x02
    109a:	92 83       	std	Z+2, r25	; 0x02
    109c:	81 83       	std	Z+1, r24	; 0x01
    109e:	e9 81       	ldd	r30, Y+1	; 0x01
    10a0:	fa 81       	ldd	r31, Y+2	; 0x02
    10a2:	01 80       	ldd	r0, Z+1	; 0x01
    10a4:	f2 81       	ldd	r31, Z+2	; 0x02
    10a6:	e0 2d       	mov	r30, r0
    10a8:	86 81       	ldd	r24, Z+6	; 0x06
    10aa:	97 81       	ldd	r25, Z+7	; 0x07
    10ac:	90 93 a3 00 	sts	0x00A3, r25
    10b0:	80 93 a2 00 	sts	0x00A2, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    10b4:	e0 91 a2 00 	lds	r30, 0x00A2
    10b8:	f0 91 a3 00 	lds	r31, 0x00A3
    10bc:	40 81       	ld	r20, Z
    10be:	51 81       	ldd	r21, Z+1	; 0x01
    10c0:	80 91 a2 00 	lds	r24, 0x00A2
    10c4:	90 91 a3 00 	lds	r25, 0x00A3
    10c8:	e0 91 a2 00 	lds	r30, 0x00A2
    10cc:	f0 91 a3 00 	lds	r31, 0x00A3
    10d0:	27 89       	ldd	r18, Z+23	; 0x17
    10d2:	62 2f       	mov	r22, r18
    10d4:	fa 01       	movw	r30, r20
    10d6:	09 95       	icall

	return;
}
    10d8:	0f 90       	pop	r0
    10da:	0f 90       	pop	r0
    10dc:	cf 91       	pop	r28
    10de:	df 91       	pop	r29
    10e0:	08 95       	ret

000010e2 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    10e2:	df 93       	push	r29
    10e4:	cf 93       	push	r28
    10e6:	0f 92       	push	r0
    10e8:	cd b7       	in	r28, 0x3d	; 61
    10ea:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    10ec:	19 82       	std	Y+1, r1	; 0x01
    10ee:	13 c0       	rjmp	.+38     	; 0x1116 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    10f0:	89 81       	ldd	r24, Y+1	; 0x01
    10f2:	28 2f       	mov	r18, r24
    10f4:	30 e0       	ldi	r19, 0x00	; 0
    10f6:	c9 01       	movw	r24, r18
    10f8:	88 0f       	add	r24, r24
    10fa:	99 1f       	adc	r25, r25
    10fc:	88 0f       	add	r24, r24
    10fe:	99 1f       	adc	r25, r25
    1100:	88 0f       	add	r24, r24
    1102:	99 1f       	adc	r25, r25
    1104:	82 0f       	add	r24, r18
    1106:	93 1f       	adc	r25, r19
    1108:	85 55       	subi	r24, 0x55	; 85
    110a:	9f 4f       	sbci	r25, 0xFF	; 255
    110c:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1110:	89 81       	ldd	r24, Y+1	; 0x01
    1112:	8f 5f       	subi	r24, 0xFF	; 255
    1114:	89 83       	std	Y+1, r24	; 0x01
    1116:	89 81       	ldd	r24, Y+1	; 0x01
    1118:	82 30       	cpi	r24, 0x02	; 2
    111a:	50 f3       	brcs	.-44     	; 0x10f0 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    111c:	8d eb       	ldi	r24, 0xBD	; 189
    111e:	90 e0       	ldi	r25, 0x00	; 0
    1120:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    1124:	86 ec       	ldi	r24, 0xC6	; 198
    1126:	90 e0       	ldi	r25, 0x00	; 0
    1128:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    112c:	83 ed       	ldi	r24, 0xD3	; 211
    112e:	90 e0       	ldi	r25, 0x00	; 0
    1130:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1134:	8d eb       	ldi	r24, 0xBD	; 189
    1136:	90 e0       	ldi	r25, 0x00	; 0
    1138:	90 93 d0 00 	sts	0x00D0, r25
    113c:	80 93 cf 00 	sts	0x00CF, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1140:	86 ec       	ldi	r24, 0xC6	; 198
    1142:	90 e0       	ldi	r25, 0x00	; 0
    1144:	90 93 d2 00 	sts	0x00D2, r25
    1148:	80 93 d1 00 	sts	0x00D1, r24
}
    114c:	0f 90       	pop	r0
    114e:	cf 91       	pop	r28
    1150:	df 91       	pop	r29
    1152:	08 95       	ret

00001154 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1154:	df 93       	push	r29
    1156:	cf 93       	push	r28
    1158:	00 d0       	rcall	.+0      	; 0x115a <xCoRoutineRemoveFromEventList+0x6>
    115a:	00 d0       	rcall	.+0      	; 0x115c <xCoRoutineRemoveFromEventList+0x8>
    115c:	0f 92       	push	r0
    115e:	cd b7       	in	r28, 0x3d	; 61
    1160:	de b7       	in	r29, 0x3e	; 62
    1162:	9d 83       	std	Y+5, r25	; 0x05
    1164:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1166:	ec 81       	ldd	r30, Y+4	; 0x04
    1168:	fd 81       	ldd	r31, Y+5	; 0x05
    116a:	05 80       	ldd	r0, Z+5	; 0x05
    116c:	f6 81       	ldd	r31, Z+6	; 0x06
    116e:	e0 2d       	mov	r30, r0
    1170:	86 81       	ldd	r24, Z+6	; 0x06
    1172:	97 81       	ldd	r25, Z+7	; 0x07
    1174:	9b 83       	std	Y+3, r25	; 0x03
    1176:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1178:	8a 81       	ldd	r24, Y+2	; 0x02
    117a:	9b 81       	ldd	r25, Y+3	; 0x03
    117c:	0c 96       	adiw	r24, 0x0c	; 12
    117e:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1182:	8a 81       	ldd	r24, Y+2	; 0x02
    1184:	9b 81       	ldd	r25, Y+3	; 0x03
    1186:	9c 01       	movw	r18, r24
    1188:	24 5f       	subi	r18, 0xF4	; 244
    118a:	3f 4f       	sbci	r19, 0xFF	; 255
    118c:	83 ed       	ldi	r24, 0xD3	; 211
    118e:	90 e0       	ldi	r25, 0x00	; 0
    1190:	b9 01       	movw	r22, r18
    1192:	0e 94 88 09 	call	0x1310	; 0x1310 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1196:	ea 81       	ldd	r30, Y+2	; 0x02
    1198:	fb 81       	ldd	r31, Y+3	; 0x03
    119a:	96 89       	ldd	r25, Z+22	; 0x16
    119c:	e0 91 a2 00 	lds	r30, 0x00A2
    11a0:	f0 91 a3 00 	lds	r31, 0x00A3
    11a4:	86 89       	ldd	r24, Z+22	; 0x16
    11a6:	98 17       	cp	r25, r24
    11a8:	18 f0       	brcs	.+6      	; 0x11b0 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    11aa:	81 e0       	ldi	r24, 0x01	; 1
    11ac:	89 83       	std	Y+1, r24	; 0x01
    11ae:	01 c0       	rjmp	.+2      	; 0x11b2 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    11b0:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    11b2:	89 81       	ldd	r24, Y+1	; 0x01
}
    11b4:	0f 90       	pop	r0
    11b6:	0f 90       	pop	r0
    11b8:	0f 90       	pop	r0
    11ba:	0f 90       	pop	r0
    11bc:	0f 90       	pop	r0
    11be:	cf 91       	pop	r28
    11c0:	df 91       	pop	r29
    11c2:	08 95       	ret

000011c4 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    11c4:	df 93       	push	r29
    11c6:	cf 93       	push	r28
    11c8:	00 d0       	rcall	.+0      	; 0x11ca <pvPortMalloc+0x6>
    11ca:	00 d0       	rcall	.+0      	; 0x11cc <pvPortMalloc+0x8>
    11cc:	cd b7       	in	r28, 0x3d	; 61
    11ce:	de b7       	in	r29, 0x3e	; 62
    11d0:	9c 83       	std	Y+4, r25	; 0x04
    11d2:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    11d4:	1a 82       	std	Y+2, r1	; 0x02
    11d6:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    11d8:	0e 94 37 14 	call	0x286e	; 0x286e <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    11dc:	80 91 dc 00 	lds	r24, 0x00DC
    11e0:	90 91 dd 00 	lds	r25, 0x00DD
    11e4:	2b 81       	ldd	r18, Y+3	; 0x03
    11e6:	3c 81       	ldd	r19, Y+4	; 0x04
    11e8:	82 0f       	add	r24, r18
    11ea:	93 1f       	adc	r25, r19
    11ec:	24 e0       	ldi	r18, 0x04	; 4
    11ee:	8c 34       	cpi	r24, 0x4C	; 76
    11f0:	92 07       	cpc	r25, r18
    11f2:	18 f5       	brcc	.+70     	; 0x123a <pvPortMalloc+0x76>
    11f4:	20 91 dc 00 	lds	r18, 0x00DC
    11f8:	30 91 dd 00 	lds	r19, 0x00DD
    11fc:	8b 81       	ldd	r24, Y+3	; 0x03
    11fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1200:	28 0f       	add	r18, r24
    1202:	39 1f       	adc	r19, r25
    1204:	80 91 dc 00 	lds	r24, 0x00DC
    1208:	90 91 dd 00 	lds	r25, 0x00DD
    120c:	82 17       	cp	r24, r18
    120e:	93 07       	cpc	r25, r19
    1210:	a0 f4       	brcc	.+40     	; 0x123a <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1212:	80 91 dc 00 	lds	r24, 0x00DC
    1216:	90 91 dd 00 	lds	r25, 0x00DD
    121a:	82 52       	subi	r24, 0x22	; 34
    121c:	9f 4f       	sbci	r25, 0xFF	; 255
    121e:	9a 83       	std	Y+2, r25	; 0x02
    1220:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    1222:	20 91 dc 00 	lds	r18, 0x00DC
    1226:	30 91 dd 00 	lds	r19, 0x00DD
    122a:	8b 81       	ldd	r24, Y+3	; 0x03
    122c:	9c 81       	ldd	r25, Y+4	; 0x04
    122e:	82 0f       	add	r24, r18
    1230:	93 1f       	adc	r25, r19
    1232:	90 93 dd 00 	sts	0x00DD, r25
    1236:	80 93 dc 00 	sts	0x00DC, r24
		}	
	}
	xTaskResumeAll();
    123a:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    123e:	89 81       	ldd	r24, Y+1	; 0x01
    1240:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1242:	0f 90       	pop	r0
    1244:	0f 90       	pop	r0
    1246:	0f 90       	pop	r0
    1248:	0f 90       	pop	r0
    124a:	cf 91       	pop	r28
    124c:	df 91       	pop	r29
    124e:	08 95       	ret

00001250 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1250:	df 93       	push	r29
    1252:	cf 93       	push	r28
    1254:	00 d0       	rcall	.+0      	; 0x1256 <vPortFree+0x6>
    1256:	cd b7       	in	r28, 0x3d	; 61
    1258:	de b7       	in	r29, 0x3e	; 62
    125a:	9a 83       	std	Y+2, r25	; 0x02
    125c:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    125e:	0f 90       	pop	r0
    1260:	0f 90       	pop	r0
    1262:	cf 91       	pop	r28
    1264:	df 91       	pop	r29
    1266:	08 95       	ret

00001268 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1268:	df 93       	push	r29
    126a:	cf 93       	push	r28
    126c:	cd b7       	in	r28, 0x3d	; 61
    126e:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1270:	10 92 dd 00 	sts	0x00DD, r1
    1274:	10 92 dc 00 	sts	0x00DC, r1
}
    1278:	cf 91       	pop	r28
    127a:	df 91       	pop	r29
    127c:	08 95       	ret

0000127e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    127e:	df 93       	push	r29
    1280:	cf 93       	push	r28
    1282:	cd b7       	in	r28, 0x3d	; 61
    1284:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    1286:	20 91 dc 00 	lds	r18, 0x00DC
    128a:	30 91 dd 00 	lds	r19, 0x00DD
    128e:	8c e4       	ldi	r24, 0x4C	; 76
    1290:	94 e0       	ldi	r25, 0x04	; 4
    1292:	82 1b       	sub	r24, r18
    1294:	93 0b       	sbc	r25, r19
}
    1296:	cf 91       	pop	r28
    1298:	df 91       	pop	r29
    129a:	08 95       	ret

0000129c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    129c:	df 93       	push	r29
    129e:	cf 93       	push	r28
    12a0:	00 d0       	rcall	.+0      	; 0x12a2 <vListInitialise+0x6>
    12a2:	cd b7       	in	r28, 0x3d	; 61
    12a4:	de b7       	in	r29, 0x3e	; 62
    12a6:	9a 83       	std	Y+2, r25	; 0x02
    12a8:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    12aa:	89 81       	ldd	r24, Y+1	; 0x01
    12ac:	9a 81       	ldd	r25, Y+2	; 0x02
    12ae:	03 96       	adiw	r24, 0x03	; 3
    12b0:	e9 81       	ldd	r30, Y+1	; 0x01
    12b2:	fa 81       	ldd	r31, Y+2	; 0x02
    12b4:	92 83       	std	Z+2, r25	; 0x02
    12b6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    12b8:	e9 81       	ldd	r30, Y+1	; 0x01
    12ba:	fa 81       	ldd	r31, Y+2	; 0x02
    12bc:	8f ef       	ldi	r24, 0xFF	; 255
    12be:	9f ef       	ldi	r25, 0xFF	; 255
    12c0:	94 83       	std	Z+4, r25	; 0x04
    12c2:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    12c4:	89 81       	ldd	r24, Y+1	; 0x01
    12c6:	9a 81       	ldd	r25, Y+2	; 0x02
    12c8:	03 96       	adiw	r24, 0x03	; 3
    12ca:	e9 81       	ldd	r30, Y+1	; 0x01
    12cc:	fa 81       	ldd	r31, Y+2	; 0x02
    12ce:	96 83       	std	Z+6, r25	; 0x06
    12d0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    12d2:	89 81       	ldd	r24, Y+1	; 0x01
    12d4:	9a 81       	ldd	r25, Y+2	; 0x02
    12d6:	03 96       	adiw	r24, 0x03	; 3
    12d8:	e9 81       	ldd	r30, Y+1	; 0x01
    12da:	fa 81       	ldd	r31, Y+2	; 0x02
    12dc:	90 87       	std	Z+8, r25	; 0x08
    12de:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    12e0:	e9 81       	ldd	r30, Y+1	; 0x01
    12e2:	fa 81       	ldd	r31, Y+2	; 0x02
    12e4:	10 82       	st	Z, r1
}
    12e6:	0f 90       	pop	r0
    12e8:	0f 90       	pop	r0
    12ea:	cf 91       	pop	r28
    12ec:	df 91       	pop	r29
    12ee:	08 95       	ret

000012f0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    12f0:	df 93       	push	r29
    12f2:	cf 93       	push	r28
    12f4:	00 d0       	rcall	.+0      	; 0x12f6 <vListInitialiseItem+0x6>
    12f6:	cd b7       	in	r28, 0x3d	; 61
    12f8:	de b7       	in	r29, 0x3e	; 62
    12fa:	9a 83       	std	Y+2, r25	; 0x02
    12fc:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    12fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1300:	fa 81       	ldd	r31, Y+2	; 0x02
    1302:	11 86       	std	Z+9, r1	; 0x09
    1304:	10 86       	std	Z+8, r1	; 0x08
}
    1306:	0f 90       	pop	r0
    1308:	0f 90       	pop	r0
    130a:	cf 91       	pop	r28
    130c:	df 91       	pop	r29
    130e:	08 95       	ret

00001310 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1310:	df 93       	push	r29
    1312:	cf 93       	push	r28
    1314:	00 d0       	rcall	.+0      	; 0x1316 <vListInsertEnd+0x6>
    1316:	00 d0       	rcall	.+0      	; 0x1318 <vListInsertEnd+0x8>
    1318:	00 d0       	rcall	.+0      	; 0x131a <vListInsertEnd+0xa>
    131a:	cd b7       	in	r28, 0x3d	; 61
    131c:	de b7       	in	r29, 0x3e	; 62
    131e:	9c 83       	std	Y+4, r25	; 0x04
    1320:	8b 83       	std	Y+3, r24	; 0x03
    1322:	7e 83       	std	Y+6, r23	; 0x06
    1324:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1326:	eb 81       	ldd	r30, Y+3	; 0x03
    1328:	fc 81       	ldd	r31, Y+4	; 0x04
    132a:	81 81       	ldd	r24, Z+1	; 0x01
    132c:	92 81       	ldd	r25, Z+2	; 0x02
    132e:	9a 83       	std	Y+2, r25	; 0x02
    1330:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    1332:	e9 81       	ldd	r30, Y+1	; 0x01
    1334:	fa 81       	ldd	r31, Y+2	; 0x02
    1336:	82 81       	ldd	r24, Z+2	; 0x02
    1338:	93 81       	ldd	r25, Z+3	; 0x03
    133a:	ed 81       	ldd	r30, Y+5	; 0x05
    133c:	fe 81       	ldd	r31, Y+6	; 0x06
    133e:	93 83       	std	Z+3, r25	; 0x03
    1340:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1342:	eb 81       	ldd	r30, Y+3	; 0x03
    1344:	fc 81       	ldd	r31, Y+4	; 0x04
    1346:	81 81       	ldd	r24, Z+1	; 0x01
    1348:	92 81       	ldd	r25, Z+2	; 0x02
    134a:	ed 81       	ldd	r30, Y+5	; 0x05
    134c:	fe 81       	ldd	r31, Y+6	; 0x06
    134e:	95 83       	std	Z+5, r25	; 0x05
    1350:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1352:	e9 81       	ldd	r30, Y+1	; 0x01
    1354:	fa 81       	ldd	r31, Y+2	; 0x02
    1356:	02 80       	ldd	r0, Z+2	; 0x02
    1358:	f3 81       	ldd	r31, Z+3	; 0x03
    135a:	e0 2d       	mov	r30, r0
    135c:	8d 81       	ldd	r24, Y+5	; 0x05
    135e:	9e 81       	ldd	r25, Y+6	; 0x06
    1360:	95 83       	std	Z+5, r25	; 0x05
    1362:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1364:	8d 81       	ldd	r24, Y+5	; 0x05
    1366:	9e 81       	ldd	r25, Y+6	; 0x06
    1368:	e9 81       	ldd	r30, Y+1	; 0x01
    136a:	fa 81       	ldd	r31, Y+2	; 0x02
    136c:	93 83       	std	Z+3, r25	; 0x03
    136e:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1370:	8d 81       	ldd	r24, Y+5	; 0x05
    1372:	9e 81       	ldd	r25, Y+6	; 0x06
    1374:	eb 81       	ldd	r30, Y+3	; 0x03
    1376:	fc 81       	ldd	r31, Y+4	; 0x04
    1378:	92 83       	std	Z+2, r25	; 0x02
    137a:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    137c:	ed 81       	ldd	r30, Y+5	; 0x05
    137e:	fe 81       	ldd	r31, Y+6	; 0x06
    1380:	8b 81       	ldd	r24, Y+3	; 0x03
    1382:	9c 81       	ldd	r25, Y+4	; 0x04
    1384:	91 87       	std	Z+9, r25	; 0x09
    1386:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1388:	eb 81       	ldd	r30, Y+3	; 0x03
    138a:	fc 81       	ldd	r31, Y+4	; 0x04
    138c:	80 81       	ld	r24, Z
    138e:	8f 5f       	subi	r24, 0xFF	; 255
    1390:	eb 81       	ldd	r30, Y+3	; 0x03
    1392:	fc 81       	ldd	r31, Y+4	; 0x04
    1394:	80 83       	st	Z, r24
}
    1396:	26 96       	adiw	r28, 0x06	; 6
    1398:	0f b6       	in	r0, 0x3f	; 63
    139a:	f8 94       	cli
    139c:	de bf       	out	0x3e, r29	; 62
    139e:	0f be       	out	0x3f, r0	; 63
    13a0:	cd bf       	out	0x3d, r28	; 61
    13a2:	cf 91       	pop	r28
    13a4:	df 91       	pop	r29
    13a6:	08 95       	ret

000013a8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    13a8:	df 93       	push	r29
    13aa:	cf 93       	push	r28
    13ac:	cd b7       	in	r28, 0x3d	; 61
    13ae:	de b7       	in	r29, 0x3e	; 62
    13b0:	28 97       	sbiw	r28, 0x08	; 8
    13b2:	0f b6       	in	r0, 0x3f	; 63
    13b4:	f8 94       	cli
    13b6:	de bf       	out	0x3e, r29	; 62
    13b8:	0f be       	out	0x3f, r0	; 63
    13ba:	cd bf       	out	0x3d, r28	; 61
    13bc:	9e 83       	std	Y+6, r25	; 0x06
    13be:	8d 83       	std	Y+5, r24	; 0x05
    13c0:	78 87       	std	Y+8, r23	; 0x08
    13c2:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    13c4:	ef 81       	ldd	r30, Y+7	; 0x07
    13c6:	f8 85       	ldd	r31, Y+8	; 0x08
    13c8:	80 81       	ld	r24, Z
    13ca:	91 81       	ldd	r25, Z+1	; 0x01
    13cc:	9a 83       	std	Y+2, r25	; 0x02
    13ce:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    13d0:	89 81       	ldd	r24, Y+1	; 0x01
    13d2:	9a 81       	ldd	r25, Y+2	; 0x02
    13d4:	2f ef       	ldi	r18, 0xFF	; 255
    13d6:	8f 3f       	cpi	r24, 0xFF	; 255
    13d8:	92 07       	cpc	r25, r18
    13da:	39 f4       	brne	.+14     	; 0x13ea <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    13dc:	ed 81       	ldd	r30, Y+5	; 0x05
    13de:	fe 81       	ldd	r31, Y+6	; 0x06
    13e0:	87 81       	ldd	r24, Z+7	; 0x07
    13e2:	90 85       	ldd	r25, Z+8	; 0x08
    13e4:	9c 83       	std	Y+4, r25	; 0x04
    13e6:	8b 83       	std	Y+3, r24	; 0x03
    13e8:	18 c0       	rjmp	.+48     	; 0x141a <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    13ea:	8d 81       	ldd	r24, Y+5	; 0x05
    13ec:	9e 81       	ldd	r25, Y+6	; 0x06
    13ee:	03 96       	adiw	r24, 0x03	; 3
    13f0:	9c 83       	std	Y+4, r25	; 0x04
    13f2:	8b 83       	std	Y+3, r24	; 0x03
    13f4:	06 c0       	rjmp	.+12     	; 0x1402 <vListInsert+0x5a>
    13f6:	eb 81       	ldd	r30, Y+3	; 0x03
    13f8:	fc 81       	ldd	r31, Y+4	; 0x04
    13fa:	82 81       	ldd	r24, Z+2	; 0x02
    13fc:	93 81       	ldd	r25, Z+3	; 0x03
    13fe:	9c 83       	std	Y+4, r25	; 0x04
    1400:	8b 83       	std	Y+3, r24	; 0x03
    1402:	eb 81       	ldd	r30, Y+3	; 0x03
    1404:	fc 81       	ldd	r31, Y+4	; 0x04
    1406:	02 80       	ldd	r0, Z+2	; 0x02
    1408:	f3 81       	ldd	r31, Z+3	; 0x03
    140a:	e0 2d       	mov	r30, r0
    140c:	20 81       	ld	r18, Z
    140e:	31 81       	ldd	r19, Z+1	; 0x01
    1410:	89 81       	ldd	r24, Y+1	; 0x01
    1412:	9a 81       	ldd	r25, Y+2	; 0x02
    1414:	82 17       	cp	r24, r18
    1416:	93 07       	cpc	r25, r19
    1418:	70 f7       	brcc	.-36     	; 0x13f6 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    141a:	eb 81       	ldd	r30, Y+3	; 0x03
    141c:	fc 81       	ldd	r31, Y+4	; 0x04
    141e:	82 81       	ldd	r24, Z+2	; 0x02
    1420:	93 81       	ldd	r25, Z+3	; 0x03
    1422:	ef 81       	ldd	r30, Y+7	; 0x07
    1424:	f8 85       	ldd	r31, Y+8	; 0x08
    1426:	93 83       	std	Z+3, r25	; 0x03
    1428:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    142a:	ef 81       	ldd	r30, Y+7	; 0x07
    142c:	f8 85       	ldd	r31, Y+8	; 0x08
    142e:	02 80       	ldd	r0, Z+2	; 0x02
    1430:	f3 81       	ldd	r31, Z+3	; 0x03
    1432:	e0 2d       	mov	r30, r0
    1434:	8f 81       	ldd	r24, Y+7	; 0x07
    1436:	98 85       	ldd	r25, Y+8	; 0x08
    1438:	95 83       	std	Z+5, r25	; 0x05
    143a:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    143c:	ef 81       	ldd	r30, Y+7	; 0x07
    143e:	f8 85       	ldd	r31, Y+8	; 0x08
    1440:	8b 81       	ldd	r24, Y+3	; 0x03
    1442:	9c 81       	ldd	r25, Y+4	; 0x04
    1444:	95 83       	std	Z+5, r25	; 0x05
    1446:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1448:	8f 81       	ldd	r24, Y+7	; 0x07
    144a:	98 85       	ldd	r25, Y+8	; 0x08
    144c:	eb 81       	ldd	r30, Y+3	; 0x03
    144e:	fc 81       	ldd	r31, Y+4	; 0x04
    1450:	93 83       	std	Z+3, r25	; 0x03
    1452:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1454:	ef 81       	ldd	r30, Y+7	; 0x07
    1456:	f8 85       	ldd	r31, Y+8	; 0x08
    1458:	8d 81       	ldd	r24, Y+5	; 0x05
    145a:	9e 81       	ldd	r25, Y+6	; 0x06
    145c:	91 87       	std	Z+9, r25	; 0x09
    145e:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1460:	ed 81       	ldd	r30, Y+5	; 0x05
    1462:	fe 81       	ldd	r31, Y+6	; 0x06
    1464:	80 81       	ld	r24, Z
    1466:	8f 5f       	subi	r24, 0xFF	; 255
    1468:	ed 81       	ldd	r30, Y+5	; 0x05
    146a:	fe 81       	ldd	r31, Y+6	; 0x06
    146c:	80 83       	st	Z, r24
}
    146e:	28 96       	adiw	r28, 0x08	; 8
    1470:	0f b6       	in	r0, 0x3f	; 63
    1472:	f8 94       	cli
    1474:	de bf       	out	0x3e, r29	; 62
    1476:	0f be       	out	0x3f, r0	; 63
    1478:	cd bf       	out	0x3d, r28	; 61
    147a:	cf 91       	pop	r28
    147c:	df 91       	pop	r29
    147e:	08 95       	ret

00001480 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1480:	df 93       	push	r29
    1482:	cf 93       	push	r28
    1484:	00 d0       	rcall	.+0      	; 0x1486 <vListRemove+0x6>
    1486:	00 d0       	rcall	.+0      	; 0x1488 <vListRemove+0x8>
    1488:	cd b7       	in	r28, 0x3d	; 61
    148a:	de b7       	in	r29, 0x3e	; 62
    148c:	9c 83       	std	Y+4, r25	; 0x04
    148e:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1490:	eb 81       	ldd	r30, Y+3	; 0x03
    1492:	fc 81       	ldd	r31, Y+4	; 0x04
    1494:	a2 81       	ldd	r26, Z+2	; 0x02
    1496:	b3 81       	ldd	r27, Z+3	; 0x03
    1498:	eb 81       	ldd	r30, Y+3	; 0x03
    149a:	fc 81       	ldd	r31, Y+4	; 0x04
    149c:	84 81       	ldd	r24, Z+4	; 0x04
    149e:	95 81       	ldd	r25, Z+5	; 0x05
    14a0:	15 96       	adiw	r26, 0x05	; 5
    14a2:	9c 93       	st	X, r25
    14a4:	8e 93       	st	-X, r24
    14a6:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    14a8:	eb 81       	ldd	r30, Y+3	; 0x03
    14aa:	fc 81       	ldd	r31, Y+4	; 0x04
    14ac:	a4 81       	ldd	r26, Z+4	; 0x04
    14ae:	b5 81       	ldd	r27, Z+5	; 0x05
    14b0:	eb 81       	ldd	r30, Y+3	; 0x03
    14b2:	fc 81       	ldd	r31, Y+4	; 0x04
    14b4:	82 81       	ldd	r24, Z+2	; 0x02
    14b6:	93 81       	ldd	r25, Z+3	; 0x03
    14b8:	13 96       	adiw	r26, 0x03	; 3
    14ba:	9c 93       	st	X, r25
    14bc:	8e 93       	st	-X, r24
    14be:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    14c0:	eb 81       	ldd	r30, Y+3	; 0x03
    14c2:	fc 81       	ldd	r31, Y+4	; 0x04
    14c4:	80 85       	ldd	r24, Z+8	; 0x08
    14c6:	91 85       	ldd	r25, Z+9	; 0x09
    14c8:	9a 83       	std	Y+2, r25	; 0x02
    14ca:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    14cc:	e9 81       	ldd	r30, Y+1	; 0x01
    14ce:	fa 81       	ldd	r31, Y+2	; 0x02
    14d0:	21 81       	ldd	r18, Z+1	; 0x01
    14d2:	32 81       	ldd	r19, Z+2	; 0x02
    14d4:	8b 81       	ldd	r24, Y+3	; 0x03
    14d6:	9c 81       	ldd	r25, Y+4	; 0x04
    14d8:	28 17       	cp	r18, r24
    14da:	39 07       	cpc	r19, r25
    14dc:	41 f4       	brne	.+16     	; 0x14ee <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    14de:	eb 81       	ldd	r30, Y+3	; 0x03
    14e0:	fc 81       	ldd	r31, Y+4	; 0x04
    14e2:	84 81       	ldd	r24, Z+4	; 0x04
    14e4:	95 81       	ldd	r25, Z+5	; 0x05
    14e6:	e9 81       	ldd	r30, Y+1	; 0x01
    14e8:	fa 81       	ldd	r31, Y+2	; 0x02
    14ea:	92 83       	std	Z+2, r25	; 0x02
    14ec:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    14ee:	eb 81       	ldd	r30, Y+3	; 0x03
    14f0:	fc 81       	ldd	r31, Y+4	; 0x04
    14f2:	11 86       	std	Z+9, r1	; 0x09
    14f4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    14f6:	e9 81       	ldd	r30, Y+1	; 0x01
    14f8:	fa 81       	ldd	r31, Y+2	; 0x02
    14fa:	80 81       	ld	r24, Z
    14fc:	81 50       	subi	r24, 0x01	; 1
    14fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1500:	fa 81       	ldd	r31, Y+2	; 0x02
    1502:	80 83       	st	Z, r24
}
    1504:	0f 90       	pop	r0
    1506:	0f 90       	pop	r0
    1508:	0f 90       	pop	r0
    150a:	0f 90       	pop	r0
    150c:	cf 91       	pop	r28
    150e:	df 91       	pop	r29
    1510:	08 95       	ret

00001512 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    1512:	df 93       	push	r29
    1514:	cf 93       	push	r28
    1516:	cd b7       	in	r28, 0x3d	; 61
    1518:	de b7       	in	r29, 0x3e	; 62
    151a:	28 97       	sbiw	r28, 0x08	; 8
    151c:	0f b6       	in	r0, 0x3f	; 63
    151e:	f8 94       	cli
    1520:	de bf       	out	0x3e, r29	; 62
    1522:	0f be       	out	0x3f, r0	; 63
    1524:	cd bf       	out	0x3d, r28	; 61
    1526:	9c 83       	std	Y+4, r25	; 0x04
    1528:	8b 83       	std	Y+3, r24	; 0x03
    152a:	7e 83       	std	Y+6, r23	; 0x06
    152c:	6d 83       	std	Y+5, r22	; 0x05
    152e:	58 87       	std	Y+8, r21	; 0x08
    1530:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1532:	eb 81       	ldd	r30, Y+3	; 0x03
    1534:	fc 81       	ldd	r31, Y+4	; 0x04
    1536:	81 e1       	ldi	r24, 0x11	; 17
    1538:	80 83       	st	Z, r24
	pxTopOfStack--;
    153a:	8b 81       	ldd	r24, Y+3	; 0x03
    153c:	9c 81       	ldd	r25, Y+4	; 0x04
    153e:	01 97       	sbiw	r24, 0x01	; 1
    1540:	9c 83       	std	Y+4, r25	; 0x04
    1542:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1544:	eb 81       	ldd	r30, Y+3	; 0x03
    1546:	fc 81       	ldd	r31, Y+4	; 0x04
    1548:	82 e2       	ldi	r24, 0x22	; 34
    154a:	80 83       	st	Z, r24
	pxTopOfStack--;
    154c:	8b 81       	ldd	r24, Y+3	; 0x03
    154e:	9c 81       	ldd	r25, Y+4	; 0x04
    1550:	01 97       	sbiw	r24, 0x01	; 1
    1552:	9c 83       	std	Y+4, r25	; 0x04
    1554:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1556:	eb 81       	ldd	r30, Y+3	; 0x03
    1558:	fc 81       	ldd	r31, Y+4	; 0x04
    155a:	83 e3       	ldi	r24, 0x33	; 51
    155c:	80 83       	st	Z, r24
	pxTopOfStack--;
    155e:	8b 81       	ldd	r24, Y+3	; 0x03
    1560:	9c 81       	ldd	r25, Y+4	; 0x04
    1562:	01 97       	sbiw	r24, 0x01	; 1
    1564:	9c 83       	std	Y+4, r25	; 0x04
    1566:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    1568:	8d 81       	ldd	r24, Y+5	; 0x05
    156a:	9e 81       	ldd	r25, Y+6	; 0x06
    156c:	9a 83       	std	Y+2, r25	; 0x02
    156e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1570:	89 81       	ldd	r24, Y+1	; 0x01
    1572:	eb 81       	ldd	r30, Y+3	; 0x03
    1574:	fc 81       	ldd	r31, Y+4	; 0x04
    1576:	80 83       	st	Z, r24
	pxTopOfStack--;
    1578:	8b 81       	ldd	r24, Y+3	; 0x03
    157a:	9c 81       	ldd	r25, Y+4	; 0x04
    157c:	01 97       	sbiw	r24, 0x01	; 1
    157e:	9c 83       	std	Y+4, r25	; 0x04
    1580:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1582:	89 81       	ldd	r24, Y+1	; 0x01
    1584:	9a 81       	ldd	r25, Y+2	; 0x02
    1586:	89 2f       	mov	r24, r25
    1588:	99 27       	eor	r25, r25
    158a:	9a 83       	std	Y+2, r25	; 0x02
    158c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    158e:	89 81       	ldd	r24, Y+1	; 0x01
    1590:	eb 81       	ldd	r30, Y+3	; 0x03
    1592:	fc 81       	ldd	r31, Y+4	; 0x04
    1594:	80 83       	st	Z, r24
	pxTopOfStack--;
    1596:	8b 81       	ldd	r24, Y+3	; 0x03
    1598:	9c 81       	ldd	r25, Y+4	; 0x04
    159a:	01 97       	sbiw	r24, 0x01	; 1
    159c:	9c 83       	std	Y+4, r25	; 0x04
    159e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    15a0:	eb 81       	ldd	r30, Y+3	; 0x03
    15a2:	fc 81       	ldd	r31, Y+4	; 0x04
    15a4:	10 82       	st	Z, r1
	pxTopOfStack--;
    15a6:	8b 81       	ldd	r24, Y+3	; 0x03
    15a8:	9c 81       	ldd	r25, Y+4	; 0x04
    15aa:	01 97       	sbiw	r24, 0x01	; 1
    15ac:	9c 83       	std	Y+4, r25	; 0x04
    15ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    15b0:	eb 81       	ldd	r30, Y+3	; 0x03
    15b2:	fc 81       	ldd	r31, Y+4	; 0x04
    15b4:	80 e8       	ldi	r24, 0x80	; 128
    15b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    15b8:	8b 81       	ldd	r24, Y+3	; 0x03
    15ba:	9c 81       	ldd	r25, Y+4	; 0x04
    15bc:	01 97       	sbiw	r24, 0x01	; 1
    15be:	9c 83       	std	Y+4, r25	; 0x04
    15c0:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    15c2:	eb 81       	ldd	r30, Y+3	; 0x03
    15c4:	fc 81       	ldd	r31, Y+4	; 0x04
    15c6:	10 82       	st	Z, r1
	pxTopOfStack--;
    15c8:	8b 81       	ldd	r24, Y+3	; 0x03
    15ca:	9c 81       	ldd	r25, Y+4	; 0x04
    15cc:	01 97       	sbiw	r24, 0x01	; 1
    15ce:	9c 83       	std	Y+4, r25	; 0x04
    15d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    15d2:	eb 81       	ldd	r30, Y+3	; 0x03
    15d4:	fc 81       	ldd	r31, Y+4	; 0x04
    15d6:	82 e0       	ldi	r24, 0x02	; 2
    15d8:	80 83       	st	Z, r24
	pxTopOfStack--;
    15da:	8b 81       	ldd	r24, Y+3	; 0x03
    15dc:	9c 81       	ldd	r25, Y+4	; 0x04
    15de:	01 97       	sbiw	r24, 0x01	; 1
    15e0:	9c 83       	std	Y+4, r25	; 0x04
    15e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    15e4:	eb 81       	ldd	r30, Y+3	; 0x03
    15e6:	fc 81       	ldd	r31, Y+4	; 0x04
    15e8:	83 e0       	ldi	r24, 0x03	; 3
    15ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    15ec:	8b 81       	ldd	r24, Y+3	; 0x03
    15ee:	9c 81       	ldd	r25, Y+4	; 0x04
    15f0:	01 97       	sbiw	r24, 0x01	; 1
    15f2:	9c 83       	std	Y+4, r25	; 0x04
    15f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    15f6:	eb 81       	ldd	r30, Y+3	; 0x03
    15f8:	fc 81       	ldd	r31, Y+4	; 0x04
    15fa:	84 e0       	ldi	r24, 0x04	; 4
    15fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    15fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1600:	9c 81       	ldd	r25, Y+4	; 0x04
    1602:	01 97       	sbiw	r24, 0x01	; 1
    1604:	9c 83       	std	Y+4, r25	; 0x04
    1606:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1608:	eb 81       	ldd	r30, Y+3	; 0x03
    160a:	fc 81       	ldd	r31, Y+4	; 0x04
    160c:	85 e0       	ldi	r24, 0x05	; 5
    160e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1610:	8b 81       	ldd	r24, Y+3	; 0x03
    1612:	9c 81       	ldd	r25, Y+4	; 0x04
    1614:	01 97       	sbiw	r24, 0x01	; 1
    1616:	9c 83       	std	Y+4, r25	; 0x04
    1618:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    161a:	eb 81       	ldd	r30, Y+3	; 0x03
    161c:	fc 81       	ldd	r31, Y+4	; 0x04
    161e:	86 e0       	ldi	r24, 0x06	; 6
    1620:	80 83       	st	Z, r24
	pxTopOfStack--;
    1622:	8b 81       	ldd	r24, Y+3	; 0x03
    1624:	9c 81       	ldd	r25, Y+4	; 0x04
    1626:	01 97       	sbiw	r24, 0x01	; 1
    1628:	9c 83       	std	Y+4, r25	; 0x04
    162a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    162c:	eb 81       	ldd	r30, Y+3	; 0x03
    162e:	fc 81       	ldd	r31, Y+4	; 0x04
    1630:	87 e0       	ldi	r24, 0x07	; 7
    1632:	80 83       	st	Z, r24
	pxTopOfStack--;
    1634:	8b 81       	ldd	r24, Y+3	; 0x03
    1636:	9c 81       	ldd	r25, Y+4	; 0x04
    1638:	01 97       	sbiw	r24, 0x01	; 1
    163a:	9c 83       	std	Y+4, r25	; 0x04
    163c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    163e:	eb 81       	ldd	r30, Y+3	; 0x03
    1640:	fc 81       	ldd	r31, Y+4	; 0x04
    1642:	88 e0       	ldi	r24, 0x08	; 8
    1644:	80 83       	st	Z, r24
	pxTopOfStack--;
    1646:	8b 81       	ldd	r24, Y+3	; 0x03
    1648:	9c 81       	ldd	r25, Y+4	; 0x04
    164a:	01 97       	sbiw	r24, 0x01	; 1
    164c:	9c 83       	std	Y+4, r25	; 0x04
    164e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1650:	eb 81       	ldd	r30, Y+3	; 0x03
    1652:	fc 81       	ldd	r31, Y+4	; 0x04
    1654:	89 e0       	ldi	r24, 0x09	; 9
    1656:	80 83       	st	Z, r24
	pxTopOfStack--;
    1658:	8b 81       	ldd	r24, Y+3	; 0x03
    165a:	9c 81       	ldd	r25, Y+4	; 0x04
    165c:	01 97       	sbiw	r24, 0x01	; 1
    165e:	9c 83       	std	Y+4, r25	; 0x04
    1660:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1662:	eb 81       	ldd	r30, Y+3	; 0x03
    1664:	fc 81       	ldd	r31, Y+4	; 0x04
    1666:	80 e1       	ldi	r24, 0x10	; 16
    1668:	80 83       	st	Z, r24
	pxTopOfStack--;
    166a:	8b 81       	ldd	r24, Y+3	; 0x03
    166c:	9c 81       	ldd	r25, Y+4	; 0x04
    166e:	01 97       	sbiw	r24, 0x01	; 1
    1670:	9c 83       	std	Y+4, r25	; 0x04
    1672:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1674:	eb 81       	ldd	r30, Y+3	; 0x03
    1676:	fc 81       	ldd	r31, Y+4	; 0x04
    1678:	81 e1       	ldi	r24, 0x11	; 17
    167a:	80 83       	st	Z, r24
	pxTopOfStack--;
    167c:	8b 81       	ldd	r24, Y+3	; 0x03
    167e:	9c 81       	ldd	r25, Y+4	; 0x04
    1680:	01 97       	sbiw	r24, 0x01	; 1
    1682:	9c 83       	std	Y+4, r25	; 0x04
    1684:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1686:	eb 81       	ldd	r30, Y+3	; 0x03
    1688:	fc 81       	ldd	r31, Y+4	; 0x04
    168a:	82 e1       	ldi	r24, 0x12	; 18
    168c:	80 83       	st	Z, r24
	pxTopOfStack--;
    168e:	8b 81       	ldd	r24, Y+3	; 0x03
    1690:	9c 81       	ldd	r25, Y+4	; 0x04
    1692:	01 97       	sbiw	r24, 0x01	; 1
    1694:	9c 83       	std	Y+4, r25	; 0x04
    1696:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1698:	eb 81       	ldd	r30, Y+3	; 0x03
    169a:	fc 81       	ldd	r31, Y+4	; 0x04
    169c:	83 e1       	ldi	r24, 0x13	; 19
    169e:	80 83       	st	Z, r24
	pxTopOfStack--;
    16a0:	8b 81       	ldd	r24, Y+3	; 0x03
    16a2:	9c 81       	ldd	r25, Y+4	; 0x04
    16a4:	01 97       	sbiw	r24, 0x01	; 1
    16a6:	9c 83       	std	Y+4, r25	; 0x04
    16a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    16aa:	eb 81       	ldd	r30, Y+3	; 0x03
    16ac:	fc 81       	ldd	r31, Y+4	; 0x04
    16ae:	84 e1       	ldi	r24, 0x14	; 20
    16b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    16b2:	8b 81       	ldd	r24, Y+3	; 0x03
    16b4:	9c 81       	ldd	r25, Y+4	; 0x04
    16b6:	01 97       	sbiw	r24, 0x01	; 1
    16b8:	9c 83       	std	Y+4, r25	; 0x04
    16ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    16bc:	eb 81       	ldd	r30, Y+3	; 0x03
    16be:	fc 81       	ldd	r31, Y+4	; 0x04
    16c0:	85 e1       	ldi	r24, 0x15	; 21
    16c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    16c4:	8b 81       	ldd	r24, Y+3	; 0x03
    16c6:	9c 81       	ldd	r25, Y+4	; 0x04
    16c8:	01 97       	sbiw	r24, 0x01	; 1
    16ca:	9c 83       	std	Y+4, r25	; 0x04
    16cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    16ce:	eb 81       	ldd	r30, Y+3	; 0x03
    16d0:	fc 81       	ldd	r31, Y+4	; 0x04
    16d2:	86 e1       	ldi	r24, 0x16	; 22
    16d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    16d6:	8b 81       	ldd	r24, Y+3	; 0x03
    16d8:	9c 81       	ldd	r25, Y+4	; 0x04
    16da:	01 97       	sbiw	r24, 0x01	; 1
    16dc:	9c 83       	std	Y+4, r25	; 0x04
    16de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    16e0:	eb 81       	ldd	r30, Y+3	; 0x03
    16e2:	fc 81       	ldd	r31, Y+4	; 0x04
    16e4:	87 e1       	ldi	r24, 0x17	; 23
    16e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    16e8:	8b 81       	ldd	r24, Y+3	; 0x03
    16ea:	9c 81       	ldd	r25, Y+4	; 0x04
    16ec:	01 97       	sbiw	r24, 0x01	; 1
    16ee:	9c 83       	std	Y+4, r25	; 0x04
    16f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    16f2:	eb 81       	ldd	r30, Y+3	; 0x03
    16f4:	fc 81       	ldd	r31, Y+4	; 0x04
    16f6:	88 e1       	ldi	r24, 0x18	; 24
    16f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    16fa:	8b 81       	ldd	r24, Y+3	; 0x03
    16fc:	9c 81       	ldd	r25, Y+4	; 0x04
    16fe:	01 97       	sbiw	r24, 0x01	; 1
    1700:	9c 83       	std	Y+4, r25	; 0x04
    1702:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1704:	eb 81       	ldd	r30, Y+3	; 0x03
    1706:	fc 81       	ldd	r31, Y+4	; 0x04
    1708:	89 e1       	ldi	r24, 0x19	; 25
    170a:	80 83       	st	Z, r24
	pxTopOfStack--;
    170c:	8b 81       	ldd	r24, Y+3	; 0x03
    170e:	9c 81       	ldd	r25, Y+4	; 0x04
    1710:	01 97       	sbiw	r24, 0x01	; 1
    1712:	9c 83       	std	Y+4, r25	; 0x04
    1714:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1716:	eb 81       	ldd	r30, Y+3	; 0x03
    1718:	fc 81       	ldd	r31, Y+4	; 0x04
    171a:	80 e2       	ldi	r24, 0x20	; 32
    171c:	80 83       	st	Z, r24
	pxTopOfStack--;
    171e:	8b 81       	ldd	r24, Y+3	; 0x03
    1720:	9c 81       	ldd	r25, Y+4	; 0x04
    1722:	01 97       	sbiw	r24, 0x01	; 1
    1724:	9c 83       	std	Y+4, r25	; 0x04
    1726:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1728:	eb 81       	ldd	r30, Y+3	; 0x03
    172a:	fc 81       	ldd	r31, Y+4	; 0x04
    172c:	81 e2       	ldi	r24, 0x21	; 33
    172e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1730:	8b 81       	ldd	r24, Y+3	; 0x03
    1732:	9c 81       	ldd	r25, Y+4	; 0x04
    1734:	01 97       	sbiw	r24, 0x01	; 1
    1736:	9c 83       	std	Y+4, r25	; 0x04
    1738:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    173a:	eb 81       	ldd	r30, Y+3	; 0x03
    173c:	fc 81       	ldd	r31, Y+4	; 0x04
    173e:	82 e2       	ldi	r24, 0x22	; 34
    1740:	80 83       	st	Z, r24
	pxTopOfStack--;
    1742:	8b 81       	ldd	r24, Y+3	; 0x03
    1744:	9c 81       	ldd	r25, Y+4	; 0x04
    1746:	01 97       	sbiw	r24, 0x01	; 1
    1748:	9c 83       	std	Y+4, r25	; 0x04
    174a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    174c:	eb 81       	ldd	r30, Y+3	; 0x03
    174e:	fc 81       	ldd	r31, Y+4	; 0x04
    1750:	83 e2       	ldi	r24, 0x23	; 35
    1752:	80 83       	st	Z, r24
	pxTopOfStack--;
    1754:	8b 81       	ldd	r24, Y+3	; 0x03
    1756:	9c 81       	ldd	r25, Y+4	; 0x04
    1758:	01 97       	sbiw	r24, 0x01	; 1
    175a:	9c 83       	std	Y+4, r25	; 0x04
    175c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    175e:	8f 81       	ldd	r24, Y+7	; 0x07
    1760:	98 85       	ldd	r25, Y+8	; 0x08
    1762:	9a 83       	std	Y+2, r25	; 0x02
    1764:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1766:	89 81       	ldd	r24, Y+1	; 0x01
    1768:	eb 81       	ldd	r30, Y+3	; 0x03
    176a:	fc 81       	ldd	r31, Y+4	; 0x04
    176c:	80 83       	st	Z, r24
	pxTopOfStack--;
    176e:	8b 81       	ldd	r24, Y+3	; 0x03
    1770:	9c 81       	ldd	r25, Y+4	; 0x04
    1772:	01 97       	sbiw	r24, 0x01	; 1
    1774:	9c 83       	std	Y+4, r25	; 0x04
    1776:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1778:	89 81       	ldd	r24, Y+1	; 0x01
    177a:	9a 81       	ldd	r25, Y+2	; 0x02
    177c:	89 2f       	mov	r24, r25
    177e:	99 27       	eor	r25, r25
    1780:	9a 83       	std	Y+2, r25	; 0x02
    1782:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1784:	89 81       	ldd	r24, Y+1	; 0x01
    1786:	eb 81       	ldd	r30, Y+3	; 0x03
    1788:	fc 81       	ldd	r31, Y+4	; 0x04
    178a:	80 83       	st	Z, r24
	pxTopOfStack--;
    178c:	8b 81       	ldd	r24, Y+3	; 0x03
    178e:	9c 81       	ldd	r25, Y+4	; 0x04
    1790:	01 97       	sbiw	r24, 0x01	; 1
    1792:	9c 83       	std	Y+4, r25	; 0x04
    1794:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1796:	eb 81       	ldd	r30, Y+3	; 0x03
    1798:	fc 81       	ldd	r31, Y+4	; 0x04
    179a:	86 e2       	ldi	r24, 0x26	; 38
    179c:	80 83       	st	Z, r24
	pxTopOfStack--;
    179e:	8b 81       	ldd	r24, Y+3	; 0x03
    17a0:	9c 81       	ldd	r25, Y+4	; 0x04
    17a2:	01 97       	sbiw	r24, 0x01	; 1
    17a4:	9c 83       	std	Y+4, r25	; 0x04
    17a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    17a8:	eb 81       	ldd	r30, Y+3	; 0x03
    17aa:	fc 81       	ldd	r31, Y+4	; 0x04
    17ac:	87 e2       	ldi	r24, 0x27	; 39
    17ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    17b0:	8b 81       	ldd	r24, Y+3	; 0x03
    17b2:	9c 81       	ldd	r25, Y+4	; 0x04
    17b4:	01 97       	sbiw	r24, 0x01	; 1
    17b6:	9c 83       	std	Y+4, r25	; 0x04
    17b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    17ba:	eb 81       	ldd	r30, Y+3	; 0x03
    17bc:	fc 81       	ldd	r31, Y+4	; 0x04
    17be:	88 e2       	ldi	r24, 0x28	; 40
    17c0:	80 83       	st	Z, r24
	pxTopOfStack--;
    17c2:	8b 81       	ldd	r24, Y+3	; 0x03
    17c4:	9c 81       	ldd	r25, Y+4	; 0x04
    17c6:	01 97       	sbiw	r24, 0x01	; 1
    17c8:	9c 83       	std	Y+4, r25	; 0x04
    17ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    17cc:	eb 81       	ldd	r30, Y+3	; 0x03
    17ce:	fc 81       	ldd	r31, Y+4	; 0x04
    17d0:	89 e2       	ldi	r24, 0x29	; 41
    17d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    17d4:	8b 81       	ldd	r24, Y+3	; 0x03
    17d6:	9c 81       	ldd	r25, Y+4	; 0x04
    17d8:	01 97       	sbiw	r24, 0x01	; 1
    17da:	9c 83       	std	Y+4, r25	; 0x04
    17dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    17de:	eb 81       	ldd	r30, Y+3	; 0x03
    17e0:	fc 81       	ldd	r31, Y+4	; 0x04
    17e2:	80 e3       	ldi	r24, 0x30	; 48
    17e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    17e6:	8b 81       	ldd	r24, Y+3	; 0x03
    17e8:	9c 81       	ldd	r25, Y+4	; 0x04
    17ea:	01 97       	sbiw	r24, 0x01	; 1
    17ec:	9c 83       	std	Y+4, r25	; 0x04
    17ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    17f0:	eb 81       	ldd	r30, Y+3	; 0x03
    17f2:	fc 81       	ldd	r31, Y+4	; 0x04
    17f4:	81 e3       	ldi	r24, 0x31	; 49
    17f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    17f8:	8b 81       	ldd	r24, Y+3	; 0x03
    17fa:	9c 81       	ldd	r25, Y+4	; 0x04
    17fc:	01 97       	sbiw	r24, 0x01	; 1
    17fe:	9c 83       	std	Y+4, r25	; 0x04
    1800:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1802:	8b 81       	ldd	r24, Y+3	; 0x03
    1804:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1806:	28 96       	adiw	r28, 0x08	; 8
    1808:	0f b6       	in	r0, 0x3f	; 63
    180a:	f8 94       	cli
    180c:	de bf       	out	0x3e, r29	; 62
    180e:	0f be       	out	0x3f, r0	; 63
    1810:	cd bf       	out	0x3d, r28	; 61
    1812:	cf 91       	pop	r28
    1814:	df 91       	pop	r29
    1816:	08 95       	ret

00001818 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    1818:	df 93       	push	r29
    181a:	cf 93       	push	r28
    181c:	cd b7       	in	r28, 0x3d	; 61
    181e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1820:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1824:	a0 91 2a 05 	lds	r26, 0x052A
    1828:	b0 91 2b 05 	lds	r27, 0x052B
    182c:	cd 91       	ld	r28, X+
    182e:	cd bf       	out	0x3d, r28	; 61
    1830:	dd 91       	ld	r29, X+
    1832:	de bf       	out	0x3e, r29	; 62
    1834:	ff 91       	pop	r31
    1836:	ef 91       	pop	r30
    1838:	df 91       	pop	r29
    183a:	cf 91       	pop	r28
    183c:	bf 91       	pop	r27
    183e:	af 91       	pop	r26
    1840:	9f 91       	pop	r25
    1842:	8f 91       	pop	r24
    1844:	7f 91       	pop	r23
    1846:	6f 91       	pop	r22
    1848:	5f 91       	pop	r21
    184a:	4f 91       	pop	r20
    184c:	3f 91       	pop	r19
    184e:	2f 91       	pop	r18
    1850:	1f 91       	pop	r17
    1852:	0f 91       	pop	r16
    1854:	ff 90       	pop	r15
    1856:	ef 90       	pop	r14
    1858:	df 90       	pop	r13
    185a:	cf 90       	pop	r12
    185c:	bf 90       	pop	r11
    185e:	af 90       	pop	r10
    1860:	9f 90       	pop	r9
    1862:	8f 90       	pop	r8
    1864:	7f 90       	pop	r7
    1866:	6f 90       	pop	r6
    1868:	5f 90       	pop	r5
    186a:	4f 90       	pop	r4
    186c:	3f 90       	pop	r3
    186e:	2f 90       	pop	r2
    1870:	1f 90       	pop	r1
    1872:	0f 90       	pop	r0
    1874:	0f be       	out	0x3f, r0	; 63
    1876:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1878:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    187a:	81 e0       	ldi	r24, 0x01	; 1
}
    187c:	cf 91       	pop	r28
    187e:	df 91       	pop	r29
    1880:	08 95       	ret

00001882 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1882:	df 93       	push	r29
    1884:	cf 93       	push	r28
    1886:	cd b7       	in	r28, 0x3d	; 61
    1888:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    188a:	cf 91       	pop	r28
    188c:	df 91       	pop	r29
    188e:	08 95       	ret

00001890 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1890:	0f 92       	push	r0
    1892:	0f b6       	in	r0, 0x3f	; 63
    1894:	f8 94       	cli
    1896:	0f 92       	push	r0
    1898:	1f 92       	push	r1
    189a:	11 24       	eor	r1, r1
    189c:	2f 92       	push	r2
    189e:	3f 92       	push	r3
    18a0:	4f 92       	push	r4
    18a2:	5f 92       	push	r5
    18a4:	6f 92       	push	r6
    18a6:	7f 92       	push	r7
    18a8:	8f 92       	push	r8
    18aa:	9f 92       	push	r9
    18ac:	af 92       	push	r10
    18ae:	bf 92       	push	r11
    18b0:	cf 92       	push	r12
    18b2:	df 92       	push	r13
    18b4:	ef 92       	push	r14
    18b6:	ff 92       	push	r15
    18b8:	0f 93       	push	r16
    18ba:	1f 93       	push	r17
    18bc:	2f 93       	push	r18
    18be:	3f 93       	push	r19
    18c0:	4f 93       	push	r20
    18c2:	5f 93       	push	r21
    18c4:	6f 93       	push	r22
    18c6:	7f 93       	push	r23
    18c8:	8f 93       	push	r24
    18ca:	9f 93       	push	r25
    18cc:	af 93       	push	r26
    18ce:	bf 93       	push	r27
    18d0:	cf 93       	push	r28
    18d2:	df 93       	push	r29
    18d4:	ef 93       	push	r30
    18d6:	ff 93       	push	r31
    18d8:	a0 91 2a 05 	lds	r26, 0x052A
    18dc:	b0 91 2b 05 	lds	r27, 0x052B
    18e0:	0d b6       	in	r0, 0x3d	; 61
    18e2:	0d 92       	st	X+, r0
    18e4:	0e b6       	in	r0, 0x3e	; 62
    18e6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    18e8:	0e 94 d7 15 	call	0x2bae	; 0x2bae <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    18ec:	a0 91 2a 05 	lds	r26, 0x052A
    18f0:	b0 91 2b 05 	lds	r27, 0x052B
    18f4:	cd 91       	ld	r28, X+
    18f6:	cd bf       	out	0x3d, r28	; 61
    18f8:	dd 91       	ld	r29, X+
    18fa:	de bf       	out	0x3e, r29	; 62
    18fc:	ff 91       	pop	r31
    18fe:	ef 91       	pop	r30
    1900:	df 91       	pop	r29
    1902:	cf 91       	pop	r28
    1904:	bf 91       	pop	r27
    1906:	af 91       	pop	r26
    1908:	9f 91       	pop	r25
    190a:	8f 91       	pop	r24
    190c:	7f 91       	pop	r23
    190e:	6f 91       	pop	r22
    1910:	5f 91       	pop	r21
    1912:	4f 91       	pop	r20
    1914:	3f 91       	pop	r19
    1916:	2f 91       	pop	r18
    1918:	1f 91       	pop	r17
    191a:	0f 91       	pop	r16
    191c:	ff 90       	pop	r15
    191e:	ef 90       	pop	r14
    1920:	df 90       	pop	r13
    1922:	cf 90       	pop	r12
    1924:	bf 90       	pop	r11
    1926:	af 90       	pop	r10
    1928:	9f 90       	pop	r9
    192a:	8f 90       	pop	r8
    192c:	7f 90       	pop	r7
    192e:	6f 90       	pop	r6
    1930:	5f 90       	pop	r5
    1932:	4f 90       	pop	r4
    1934:	3f 90       	pop	r3
    1936:	2f 90       	pop	r2
    1938:	1f 90       	pop	r1
    193a:	0f 90       	pop	r0
    193c:	0f be       	out	0x3f, r0	; 63
    193e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1940:	08 95       	ret

00001942 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1942:	0f 92       	push	r0
    1944:	0f b6       	in	r0, 0x3f	; 63
    1946:	f8 94       	cli
    1948:	0f 92       	push	r0
    194a:	1f 92       	push	r1
    194c:	11 24       	eor	r1, r1
    194e:	2f 92       	push	r2
    1950:	3f 92       	push	r3
    1952:	4f 92       	push	r4
    1954:	5f 92       	push	r5
    1956:	6f 92       	push	r6
    1958:	7f 92       	push	r7
    195a:	8f 92       	push	r8
    195c:	9f 92       	push	r9
    195e:	af 92       	push	r10
    1960:	bf 92       	push	r11
    1962:	cf 92       	push	r12
    1964:	df 92       	push	r13
    1966:	ef 92       	push	r14
    1968:	ff 92       	push	r15
    196a:	0f 93       	push	r16
    196c:	1f 93       	push	r17
    196e:	2f 93       	push	r18
    1970:	3f 93       	push	r19
    1972:	4f 93       	push	r20
    1974:	5f 93       	push	r21
    1976:	6f 93       	push	r22
    1978:	7f 93       	push	r23
    197a:	8f 93       	push	r24
    197c:	9f 93       	push	r25
    197e:	af 93       	push	r26
    1980:	bf 93       	push	r27
    1982:	cf 93       	push	r28
    1984:	df 93       	push	r29
    1986:	ef 93       	push	r30
    1988:	ff 93       	push	r31
    198a:	a0 91 2a 05 	lds	r26, 0x052A
    198e:	b0 91 2b 05 	lds	r27, 0x052B
    1992:	0d b6       	in	r0, 0x3d	; 61
    1994:	0d 92       	st	X+, r0
    1996:	0e b6       	in	r0, 0x3e	; 62
    1998:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    199a:	0e 94 02 15 	call	0x2a04	; 0x2a04 <vTaskIncrementTick>
	vTaskSwitchContext();
    199e:	0e 94 d7 15 	call	0x2bae	; 0x2bae <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    19a2:	a0 91 2a 05 	lds	r26, 0x052A
    19a6:	b0 91 2b 05 	lds	r27, 0x052B
    19aa:	cd 91       	ld	r28, X+
    19ac:	cd bf       	out	0x3d, r28	; 61
    19ae:	dd 91       	ld	r29, X+
    19b0:	de bf       	out	0x3e, r29	; 62
    19b2:	ff 91       	pop	r31
    19b4:	ef 91       	pop	r30
    19b6:	df 91       	pop	r29
    19b8:	cf 91       	pop	r28
    19ba:	bf 91       	pop	r27
    19bc:	af 91       	pop	r26
    19be:	9f 91       	pop	r25
    19c0:	8f 91       	pop	r24
    19c2:	7f 91       	pop	r23
    19c4:	6f 91       	pop	r22
    19c6:	5f 91       	pop	r21
    19c8:	4f 91       	pop	r20
    19ca:	3f 91       	pop	r19
    19cc:	2f 91       	pop	r18
    19ce:	1f 91       	pop	r17
    19d0:	0f 91       	pop	r16
    19d2:	ff 90       	pop	r15
    19d4:	ef 90       	pop	r14
    19d6:	df 90       	pop	r13
    19d8:	cf 90       	pop	r12
    19da:	bf 90       	pop	r11
    19dc:	af 90       	pop	r10
    19de:	9f 90       	pop	r9
    19e0:	8f 90       	pop	r8
    19e2:	7f 90       	pop	r7
    19e4:	6f 90       	pop	r6
    19e6:	5f 90       	pop	r5
    19e8:	4f 90       	pop	r4
    19ea:	3f 90       	pop	r3
    19ec:	2f 90       	pop	r2
    19ee:	1f 90       	pop	r1
    19f0:	0f 90       	pop	r0
    19f2:	0f be       	out	0x3f, r0	; 63
    19f4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    19f6:	08 95       	ret

000019f8 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    19f8:	df 93       	push	r29
    19fa:	cf 93       	push	r28
    19fc:	00 d0       	rcall	.+0      	; 0x19fe <prvSetupTimerInterrupt+0x6>
    19fe:	00 d0       	rcall	.+0      	; 0x1a00 <prvSetupTimerInterrupt+0x8>
    1a00:	00 d0       	rcall	.+0      	; 0x1a02 <prvSetupTimerInterrupt+0xa>
    1a02:	cd b7       	in	r28, 0x3d	; 61
    1a04:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1a06:	80 e4       	ldi	r24, 0x40	; 64
    1a08:	9f e1       	ldi	r25, 0x1F	; 31
    1a0a:	a0 e0       	ldi	r26, 0x00	; 0
    1a0c:	b0 e0       	ldi	r27, 0x00	; 0
    1a0e:	8b 83       	std	Y+3, r24	; 0x03
    1a10:	9c 83       	std	Y+4, r25	; 0x04
    1a12:	ad 83       	std	Y+5, r26	; 0x05
    1a14:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1a16:	8b 81       	ldd	r24, Y+3	; 0x03
    1a18:	9c 81       	ldd	r25, Y+4	; 0x04
    1a1a:	ad 81       	ldd	r26, Y+5	; 0x05
    1a1c:	be 81       	ldd	r27, Y+6	; 0x06
    1a1e:	68 94       	set
    1a20:	15 f8       	bld	r1, 5
    1a22:	b6 95       	lsr	r27
    1a24:	a7 95       	ror	r26
    1a26:	97 95       	ror	r25
    1a28:	87 95       	ror	r24
    1a2a:	16 94       	lsr	r1
    1a2c:	d1 f7       	brne	.-12     	; 0x1a22 <prvSetupTimerInterrupt+0x2a>
    1a2e:	8b 83       	std	Y+3, r24	; 0x03
    1a30:	9c 83       	std	Y+4, r25	; 0x04
    1a32:	ad 83       	std	Y+5, r26	; 0x05
    1a34:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    1a36:	8b 81       	ldd	r24, Y+3	; 0x03
    1a38:	9c 81       	ldd	r25, Y+4	; 0x04
    1a3a:	ad 81       	ldd	r26, Y+5	; 0x05
    1a3c:	be 81       	ldd	r27, Y+6	; 0x06
    1a3e:	01 97       	sbiw	r24, 0x01	; 1
    1a40:	a1 09       	sbc	r26, r1
    1a42:	b1 09       	sbc	r27, r1
    1a44:	8b 83       	std	Y+3, r24	; 0x03
    1a46:	9c 83       	std	Y+4, r25	; 0x04
    1a48:	ad 83       	std	Y+5, r26	; 0x05
    1a4a:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1a4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a4e:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1a50:	8b 81       	ldd	r24, Y+3	; 0x03
    1a52:	9c 81       	ldd	r25, Y+4	; 0x04
    1a54:	ad 81       	ldd	r26, Y+5	; 0x05
    1a56:	be 81       	ldd	r27, Y+6	; 0x06
    1a58:	89 2f       	mov	r24, r25
    1a5a:	9a 2f       	mov	r25, r26
    1a5c:	ab 2f       	mov	r26, r27
    1a5e:	bb 27       	eor	r27, r27
    1a60:	8b 83       	std	Y+3, r24	; 0x03
    1a62:	9c 83       	std	Y+4, r25	; 0x04
    1a64:	ad 83       	std	Y+5, r26	; 0x05
    1a66:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1a68:	8b 81       	ldd	r24, Y+3	; 0x03
    1a6a:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1a6c:	eb e4       	ldi	r30, 0x4B	; 75
    1a6e:	f0 e0       	ldi	r31, 0x00	; 0
    1a70:	8a 81       	ldd	r24, Y+2	; 0x02
    1a72:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1a74:	ea e4       	ldi	r30, 0x4A	; 74
    1a76:	f0 e0       	ldi	r31, 0x00	; 0
    1a78:	89 81       	ldd	r24, Y+1	; 0x01
    1a7a:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1a7c:	8b e0       	ldi	r24, 0x0B	; 11
    1a7e:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1a80:	ee e4       	ldi	r30, 0x4E	; 78
    1a82:	f0 e0       	ldi	r31, 0x00	; 0
    1a84:	89 81       	ldd	r24, Y+1	; 0x01
    1a86:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1a88:	e9 e5       	ldi	r30, 0x59	; 89
    1a8a:	f0 e0       	ldi	r31, 0x00	; 0
    1a8c:	80 81       	ld	r24, Z
    1a8e:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1a90:	89 81       	ldd	r24, Y+1	; 0x01
    1a92:	80 61       	ori	r24, 0x10	; 16
    1a94:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1a96:	e9 e5       	ldi	r30, 0x59	; 89
    1a98:	f0 e0       	ldi	r31, 0x00	; 0
    1a9a:	89 81       	ldd	r24, Y+1	; 0x01
    1a9c:	80 83       	st	Z, r24
}
    1a9e:	26 96       	adiw	r28, 0x06	; 6
    1aa0:	0f b6       	in	r0, 0x3f	; 63
    1aa2:	f8 94       	cli
    1aa4:	de bf       	out	0x3e, r29	; 62
    1aa6:	0f be       	out	0x3f, r0	; 63
    1aa8:	cd bf       	out	0x3d, r28	; 61
    1aaa:	cf 91       	pop	r28
    1aac:	df 91       	pop	r29
    1aae:	08 95       	ret

00001ab0 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1ab0:	0e 94 a1 0c 	call	0x1942	; 0x1942 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1ab4:	18 95       	reti

00001ab6 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1ab6:	df 93       	push	r29
    1ab8:	cf 93       	push	r28
    1aba:	cd b7       	in	r28, 0x3d	; 61
    1abc:	de b7       	in	r29, 0x3e	; 62
    1abe:	28 97       	sbiw	r28, 0x08	; 8
    1ac0:	0f b6       	in	r0, 0x3f	; 63
    1ac2:	f8 94       	cli
    1ac4:	de bf       	out	0x3e, r29	; 62
    1ac6:	0f be       	out	0x3f, r0	; 63
    1ac8:	cd bf       	out	0x3d, r28	; 61
    1aca:	8f 83       	std	Y+7, r24	; 0x07
    1acc:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1ace:	1a 82       	std	Y+2, r1	; 0x02
    1ad0:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1ad2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ad4:	88 23       	and	r24, r24
    1ad6:	09 f4       	brne	.+2      	; 0x1ada <xQueueCreate+0x24>
    1ad8:	8c c0       	rjmp	.+280    	; 0x1bf2 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1ada:	8f e1       	ldi	r24, 0x1F	; 31
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <pvPortMalloc>
    1ae2:	9e 83       	std	Y+6, r25	; 0x06
    1ae4:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1ae6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ae8:	9e 81       	ldd	r25, Y+6	; 0x06
    1aea:	00 97       	sbiw	r24, 0x00	; 0
    1aec:	09 f4       	brne	.+2      	; 0x1af0 <xQueueCreate+0x3a>
    1aee:	81 c0       	rjmp	.+258    	; 0x1bf2 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1af0:	8f 81       	ldd	r24, Y+7	; 0x07
    1af2:	28 2f       	mov	r18, r24
    1af4:	30 e0       	ldi	r19, 0x00	; 0
    1af6:	88 85       	ldd	r24, Y+8	; 0x08
    1af8:	88 2f       	mov	r24, r24
    1afa:	90 e0       	ldi	r25, 0x00	; 0
    1afc:	ac 01       	movw	r20, r24
    1afe:	24 9f       	mul	r18, r20
    1b00:	c0 01       	movw	r24, r0
    1b02:	25 9f       	mul	r18, r21
    1b04:	90 0d       	add	r25, r0
    1b06:	34 9f       	mul	r19, r20
    1b08:	90 0d       	add	r25, r0
    1b0a:	11 24       	eor	r1, r1
    1b0c:	01 96       	adiw	r24, 0x01	; 1
    1b0e:	9c 83       	std	Y+4, r25	; 0x04
    1b10:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1b12:	8b 81       	ldd	r24, Y+3	; 0x03
    1b14:	9c 81       	ldd	r25, Y+4	; 0x04
    1b16:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <pvPortMalloc>
    1b1a:	ed 81       	ldd	r30, Y+5	; 0x05
    1b1c:	fe 81       	ldd	r31, Y+6	; 0x06
    1b1e:	91 83       	std	Z+1, r25	; 0x01
    1b20:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1b22:	ed 81       	ldd	r30, Y+5	; 0x05
    1b24:	fe 81       	ldd	r31, Y+6	; 0x06
    1b26:	80 81       	ld	r24, Z
    1b28:	91 81       	ldd	r25, Z+1	; 0x01
    1b2a:	00 97       	sbiw	r24, 0x00	; 0
    1b2c:	09 f4       	brne	.+2      	; 0x1b30 <xQueueCreate+0x7a>
    1b2e:	5d c0       	rjmp	.+186    	; 0x1bea <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1b30:	ed 81       	ldd	r30, Y+5	; 0x05
    1b32:	fe 81       	ldd	r31, Y+6	; 0x06
    1b34:	40 81       	ld	r20, Z
    1b36:	51 81       	ldd	r21, Z+1	; 0x01
    1b38:	8f 81       	ldd	r24, Y+7	; 0x07
    1b3a:	28 2f       	mov	r18, r24
    1b3c:	30 e0       	ldi	r19, 0x00	; 0
    1b3e:	88 85       	ldd	r24, Y+8	; 0x08
    1b40:	88 2f       	mov	r24, r24
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	bc 01       	movw	r22, r24
    1b46:	26 9f       	mul	r18, r22
    1b48:	c0 01       	movw	r24, r0
    1b4a:	27 9f       	mul	r18, r23
    1b4c:	90 0d       	add	r25, r0
    1b4e:	36 9f       	mul	r19, r22
    1b50:	90 0d       	add	r25, r0
    1b52:	11 24       	eor	r1, r1
    1b54:	84 0f       	add	r24, r20
    1b56:	95 1f       	adc	r25, r21
    1b58:	ed 81       	ldd	r30, Y+5	; 0x05
    1b5a:	fe 81       	ldd	r31, Y+6	; 0x06
    1b5c:	93 83       	std	Z+3, r25	; 0x03
    1b5e:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1b60:	ed 81       	ldd	r30, Y+5	; 0x05
    1b62:	fe 81       	ldd	r31, Y+6	; 0x06
    1b64:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1b66:	ed 81       	ldd	r30, Y+5	; 0x05
    1b68:	fe 81       	ldd	r31, Y+6	; 0x06
    1b6a:	80 81       	ld	r24, Z
    1b6c:	91 81       	ldd	r25, Z+1	; 0x01
    1b6e:	ed 81       	ldd	r30, Y+5	; 0x05
    1b70:	fe 81       	ldd	r31, Y+6	; 0x06
    1b72:	95 83       	std	Z+5, r25	; 0x05
    1b74:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1b76:	ed 81       	ldd	r30, Y+5	; 0x05
    1b78:	fe 81       	ldd	r31, Y+6	; 0x06
    1b7a:	40 81       	ld	r20, Z
    1b7c:	51 81       	ldd	r21, Z+1	; 0x01
    1b7e:	8f 81       	ldd	r24, Y+7	; 0x07
    1b80:	88 2f       	mov	r24, r24
    1b82:	90 e0       	ldi	r25, 0x00	; 0
    1b84:	9c 01       	movw	r18, r24
    1b86:	21 50       	subi	r18, 0x01	; 1
    1b88:	30 40       	sbci	r19, 0x00	; 0
    1b8a:	88 85       	ldd	r24, Y+8	; 0x08
    1b8c:	88 2f       	mov	r24, r24
    1b8e:	90 e0       	ldi	r25, 0x00	; 0
    1b90:	bc 01       	movw	r22, r24
    1b92:	26 9f       	mul	r18, r22
    1b94:	c0 01       	movw	r24, r0
    1b96:	27 9f       	mul	r18, r23
    1b98:	90 0d       	add	r25, r0
    1b9a:	36 9f       	mul	r19, r22
    1b9c:	90 0d       	add	r25, r0
    1b9e:	11 24       	eor	r1, r1
    1ba0:	84 0f       	add	r24, r20
    1ba2:	95 1f       	adc	r25, r21
    1ba4:	ed 81       	ldd	r30, Y+5	; 0x05
    1ba6:	fe 81       	ldd	r31, Y+6	; 0x06
    1ba8:	97 83       	std	Z+7, r25	; 0x07
    1baa:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1bac:	ed 81       	ldd	r30, Y+5	; 0x05
    1bae:	fe 81       	ldd	r31, Y+6	; 0x06
    1bb0:	8f 81       	ldd	r24, Y+7	; 0x07
    1bb2:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1bb4:	ed 81       	ldd	r30, Y+5	; 0x05
    1bb6:	fe 81       	ldd	r31, Y+6	; 0x06
    1bb8:	88 85       	ldd	r24, Y+8	; 0x08
    1bba:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1bbc:	ed 81       	ldd	r30, Y+5	; 0x05
    1bbe:	fe 81       	ldd	r31, Y+6	; 0x06
    1bc0:	8f ef       	ldi	r24, 0xFF	; 255
    1bc2:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1bc4:	ed 81       	ldd	r30, Y+5	; 0x05
    1bc6:	fe 81       	ldd	r31, Y+6	; 0x06
    1bc8:	8f ef       	ldi	r24, 0xFF	; 255
    1bca:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1bcc:	8d 81       	ldd	r24, Y+5	; 0x05
    1bce:	9e 81       	ldd	r25, Y+6	; 0x06
    1bd0:	08 96       	adiw	r24, 0x08	; 8
    1bd2:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1bd6:	8d 81       	ldd	r24, Y+5	; 0x05
    1bd8:	9e 81       	ldd	r25, Y+6	; 0x06
    1bda:	41 96       	adiw	r24, 0x11	; 17
    1bdc:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1be0:	8d 81       	ldd	r24, Y+5	; 0x05
    1be2:	9e 81       	ldd	r25, Y+6	; 0x06
    1be4:	9a 83       	std	Y+2, r25	; 0x02
    1be6:	89 83       	std	Y+1, r24	; 0x01
    1be8:	04 c0       	rjmp	.+8      	; 0x1bf2 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1bea:	8d 81       	ldd	r24, Y+5	; 0x05
    1bec:	9e 81       	ldd	r25, Y+6	; 0x06
    1bee:	0e 94 28 09 	call	0x1250	; 0x1250 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1bf2:	89 81       	ldd	r24, Y+1	; 0x01
    1bf4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1bf6:	28 96       	adiw	r28, 0x08	; 8
    1bf8:	0f b6       	in	r0, 0x3f	; 63
    1bfa:	f8 94       	cli
    1bfc:	de bf       	out	0x3e, r29	; 62
    1bfe:	0f be       	out	0x3f, r0	; 63
    1c00:	cd bf       	out	0x3d, r28	; 61
    1c02:	cf 91       	pop	r28
    1c04:	df 91       	pop	r29
    1c06:	08 95       	ret

00001c08 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
    1c08:	df 93       	push	r29
    1c0a:	cf 93       	push	r28
    1c0c:	00 d0       	rcall	.+0      	; 0x1c0e <xQueueCreateCountingSemaphore+0x6>
    1c0e:	00 d0       	rcall	.+0      	; 0x1c10 <xQueueCreateCountingSemaphore+0x8>
    1c10:	cd b7       	in	r28, 0x3d	; 61
    1c12:	de b7       	in	r29, 0x3e	; 62
    1c14:	8b 83       	std	Y+3, r24	; 0x03
    1c16:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    1c18:	8b 81       	ldd	r24, Y+3	; 0x03
    1c1a:	60 e0       	ldi	r22, 0x00	; 0
    1c1c:	0e 94 5b 0d 	call	0x1ab6	; 0x1ab6 <xQueueCreate>
    1c20:	9a 83       	std	Y+2, r25	; 0x02
    1c22:	89 83       	std	Y+1, r24	; 0x01

		if( pxHandle != NULL )
    1c24:	89 81       	ldd	r24, Y+1	; 0x01
    1c26:	9a 81       	ldd	r25, Y+2	; 0x02
    1c28:	00 97       	sbiw	r24, 0x00	; 0
    1c2a:	21 f0       	breq	.+8      	; 0x1c34 <xQueueCreateCountingSemaphore+0x2c>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
    1c2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1c30:	8c 81       	ldd	r24, Y+4	; 0x04
    1c32:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
    1c34:	89 81       	ldd	r24, Y+1	; 0x01
    1c36:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1c38:	0f 90       	pop	r0
    1c3a:	0f 90       	pop	r0
    1c3c:	0f 90       	pop	r0
    1c3e:	0f 90       	pop	r0
    1c40:	cf 91       	pop	r28
    1c42:	df 91       	pop	r29
    1c44:	08 95       	ret

00001c46 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1c46:	df 93       	push	r29
    1c48:	cf 93       	push	r28
    1c4a:	cd b7       	in	r28, 0x3d	; 61
    1c4c:	de b7       	in	r29, 0x3e	; 62
    1c4e:	2c 97       	sbiw	r28, 0x0c	; 12
    1c50:	0f b6       	in	r0, 0x3f	; 63
    1c52:	f8 94       	cli
    1c54:	de bf       	out	0x3e, r29	; 62
    1c56:	0f be       	out	0x3f, r0	; 63
    1c58:	cd bf       	out	0x3d, r28	; 61
    1c5a:	9e 83       	std	Y+6, r25	; 0x06
    1c5c:	8d 83       	std	Y+5, r24	; 0x05
    1c5e:	78 87       	std	Y+8, r23	; 0x08
    1c60:	6f 83       	std	Y+7, r22	; 0x07
    1c62:	5a 87       	std	Y+10, r21	; 0x0a
    1c64:	49 87       	std	Y+9, r20	; 0x09
    1c66:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1c68:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1c6a:	0f b6       	in	r0, 0x3f	; 63
    1c6c:	f8 94       	cli
    1c6e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1c70:	ed 81       	ldd	r30, Y+5	; 0x05
    1c72:	fe 81       	ldd	r31, Y+6	; 0x06
    1c74:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c76:	ed 81       	ldd	r30, Y+5	; 0x05
    1c78:	fe 81       	ldd	r31, Y+6	; 0x06
    1c7a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c7c:	98 17       	cp	r25, r24
    1c7e:	d8 f4       	brcc	.+54     	; 0x1cb6 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1c80:	8d 81       	ldd	r24, Y+5	; 0x05
    1c82:	9e 81       	ldd	r25, Y+6	; 0x06
    1c84:	2f 81       	ldd	r18, Y+7	; 0x07
    1c86:	38 85       	ldd	r19, Y+8	; 0x08
    1c88:	b9 01       	movw	r22, r18
    1c8a:	4b 85       	ldd	r20, Y+11	; 0x0b
    1c8c:	0e 94 5e 10 	call	0x20bc	; 0x20bc <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c90:	ed 81       	ldd	r30, Y+5	; 0x05
    1c92:	fe 81       	ldd	r31, Y+6	; 0x06
    1c94:	81 89       	ldd	r24, Z+17	; 0x11
    1c96:	88 23       	and	r24, r24
    1c98:	49 f0       	breq	.+18     	; 0x1cac <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1c9a:	8d 81       	ldd	r24, Y+5	; 0x05
    1c9c:	9e 81       	ldd	r25, Y+6	; 0x06
    1c9e:	41 96       	adiw	r24, 0x11	; 17
    1ca0:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <xTaskRemoveFromEventList>
    1ca4:	81 30       	cpi	r24, 0x01	; 1
    1ca6:	11 f4       	brne	.+4      	; 0x1cac <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1ca8:	0e 94 48 0c 	call	0x1890	; 0x1890 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1cac:	0f 90       	pop	r0
    1cae:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1cb0:	81 e0       	ldi	r24, 0x01	; 1
    1cb2:	8c 87       	std	Y+12, r24	; 0x0c
    1cb4:	5c c0       	rjmp	.+184    	; 0x1d6e <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1cb6:	89 85       	ldd	r24, Y+9	; 0x09
    1cb8:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cba:	00 97       	sbiw	r24, 0x00	; 0
    1cbc:	21 f4       	brne	.+8      	; 0x1cc6 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1cbe:	0f 90       	pop	r0
    1cc0:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1cc2:	1c 86       	std	Y+12, r1	; 0x0c
    1cc4:	54 c0       	rjmp	.+168    	; 0x1d6e <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1cc6:	89 81       	ldd	r24, Y+1	; 0x01
    1cc8:	88 23       	and	r24, r24
    1cca:	31 f4       	brne	.+12     	; 0x1cd8 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1ccc:	ce 01       	movw	r24, r28
    1cce:	02 96       	adiw	r24, 0x02	; 2
    1cd0:	0e 94 db 16 	call	0x2db6	; 0x2db6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1cd4:	81 e0       	ldi	r24, 0x01	; 1
    1cd6:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1cd8:	0f 90       	pop	r0
    1cda:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1cdc:	0e 94 37 14 	call	0x286e	; 0x286e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1ce0:	0f b6       	in	r0, 0x3f	; 63
    1ce2:	f8 94       	cli
    1ce4:	0f 92       	push	r0
    1ce6:	ed 81       	ldd	r30, Y+5	; 0x05
    1ce8:	fe 81       	ldd	r31, Y+6	; 0x06
    1cea:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cec:	8f 3f       	cpi	r24, 0xFF	; 255
    1cee:	19 f4       	brne	.+6      	; 0x1cf6 <xQueueGenericSend+0xb0>
    1cf0:	ed 81       	ldd	r30, Y+5	; 0x05
    1cf2:	fe 81       	ldd	r31, Y+6	; 0x06
    1cf4:	15 8e       	std	Z+29, r1	; 0x1d
    1cf6:	ed 81       	ldd	r30, Y+5	; 0x05
    1cf8:	fe 81       	ldd	r31, Y+6	; 0x06
    1cfa:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cfc:	8f 3f       	cpi	r24, 0xFF	; 255
    1cfe:	19 f4       	brne	.+6      	; 0x1d06 <xQueueGenericSend+0xc0>
    1d00:	ed 81       	ldd	r30, Y+5	; 0x05
    1d02:	fe 81       	ldd	r31, Y+6	; 0x06
    1d04:	16 8e       	std	Z+30, r1	; 0x1e
    1d06:	0f 90       	pop	r0
    1d08:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d0a:	ce 01       	movw	r24, r28
    1d0c:	02 96       	adiw	r24, 0x02	; 2
    1d0e:	9e 01       	movw	r18, r28
    1d10:	27 5f       	subi	r18, 0xF7	; 247
    1d12:	3f 4f       	sbci	r19, 0xFF	; 255
    1d14:	b9 01       	movw	r22, r18
    1d16:	0e 94 f4 16 	call	0x2de8	; 0x2de8 <xTaskCheckForTimeOut>
    1d1a:	88 23       	and	r24, r24
    1d1c:	09 f5       	brne	.+66     	; 0x1d60 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1d1e:	8d 81       	ldd	r24, Y+5	; 0x05
    1d20:	9e 81       	ldd	r25, Y+6	; 0x06
    1d22:	0e 94 c2 11 	call	0x2384	; 0x2384 <prvIsQueueFull>
    1d26:	88 23       	and	r24, r24
    1d28:	a1 f0       	breq	.+40     	; 0x1d52 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1d2a:	8d 81       	ldd	r24, Y+5	; 0x05
    1d2c:	9e 81       	ldd	r25, Y+6	; 0x06
    1d2e:	08 96       	adiw	r24, 0x08	; 8
    1d30:	29 85       	ldd	r18, Y+9	; 0x09
    1d32:	3a 85       	ldd	r19, Y+10	; 0x0a
    1d34:	b9 01       	movw	r22, r18
    1d36:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1d3a:	8d 81       	ldd	r24, Y+5	; 0x05
    1d3c:	9e 81       	ldd	r25, Y+6	; 0x06
    1d3e:	0e 94 3b 11 	call	0x2276	; 0x2276 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1d42:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskResumeAll>
    1d46:	88 23       	and	r24, r24
    1d48:	09 f0       	breq	.+2      	; 0x1d4c <xQueueGenericSend+0x106>
    1d4a:	8f cf       	rjmp	.-226    	; 0x1c6a <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1d4c:	0e 94 48 0c 	call	0x1890	; 0x1890 <vPortYield>
    1d50:	8c cf       	rjmp	.-232    	; 0x1c6a <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1d52:	8d 81       	ldd	r24, Y+5	; 0x05
    1d54:	9e 81       	ldd	r25, Y+6	; 0x06
    1d56:	0e 94 3b 11 	call	0x2276	; 0x2276 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d5a:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskResumeAll>
    1d5e:	85 cf       	rjmp	.-246    	; 0x1c6a <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1d60:	8d 81       	ldd	r24, Y+5	; 0x05
    1d62:	9e 81       	ldd	r25, Y+6	; 0x06
    1d64:	0e 94 3b 11 	call	0x2276	; 0x2276 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d68:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1d6c:	1c 86       	std	Y+12, r1	; 0x0c
    1d6e:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1d70:	2c 96       	adiw	r28, 0x0c	; 12
    1d72:	0f b6       	in	r0, 0x3f	; 63
    1d74:	f8 94       	cli
    1d76:	de bf       	out	0x3e, r29	; 62
    1d78:	0f be       	out	0x3f, r0	; 63
    1d7a:	cd bf       	out	0x3d, r28	; 61
    1d7c:	cf 91       	pop	r28
    1d7e:	df 91       	pop	r29
    1d80:	08 95       	ret

00001d82 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1d82:	df 93       	push	r29
    1d84:	cf 93       	push	r28
    1d86:	cd b7       	in	r28, 0x3d	; 61
    1d88:	de b7       	in	r29, 0x3e	; 62
    1d8a:	29 97       	sbiw	r28, 0x09	; 9
    1d8c:	0f b6       	in	r0, 0x3f	; 63
    1d8e:	f8 94       	cli
    1d90:	de bf       	out	0x3e, r29	; 62
    1d92:	0f be       	out	0x3f, r0	; 63
    1d94:	cd bf       	out	0x3d, r28	; 61
    1d96:	9c 83       	std	Y+4, r25	; 0x04
    1d98:	8b 83       	std	Y+3, r24	; 0x03
    1d9a:	7e 83       	std	Y+6, r23	; 0x06
    1d9c:	6d 83       	std	Y+5, r22	; 0x05
    1d9e:	58 87       	std	Y+8, r21	; 0x08
    1da0:	4f 83       	std	Y+7, r20	; 0x07
    1da2:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1da4:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1da6:	eb 81       	ldd	r30, Y+3	; 0x03
    1da8:	fc 81       	ldd	r31, Y+4	; 0x04
    1daa:	92 8d       	ldd	r25, Z+26	; 0x1a
    1dac:	eb 81       	ldd	r30, Y+3	; 0x03
    1dae:	fc 81       	ldd	r31, Y+4	; 0x04
    1db0:	83 8d       	ldd	r24, Z+27	; 0x1b
    1db2:	98 17       	cp	r25, r24
    1db4:	40 f5       	brcc	.+80     	; 0x1e06 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1db6:	8b 81       	ldd	r24, Y+3	; 0x03
    1db8:	9c 81       	ldd	r25, Y+4	; 0x04
    1dba:	2d 81       	ldd	r18, Y+5	; 0x05
    1dbc:	3e 81       	ldd	r19, Y+6	; 0x06
    1dbe:	b9 01       	movw	r22, r18
    1dc0:	49 85       	ldd	r20, Y+9	; 0x09
    1dc2:	0e 94 5e 10 	call	0x20bc	; 0x20bc <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1dc6:	eb 81       	ldd	r30, Y+3	; 0x03
    1dc8:	fc 81       	ldd	r31, Y+4	; 0x04
    1dca:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dcc:	8f 3f       	cpi	r24, 0xFF	; 255
    1dce:	89 f4       	brne	.+34     	; 0x1df2 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1dd0:	eb 81       	ldd	r30, Y+3	; 0x03
    1dd2:	fc 81       	ldd	r31, Y+4	; 0x04
    1dd4:	81 89       	ldd	r24, Z+17	; 0x11
    1dd6:	88 23       	and	r24, r24
    1dd8:	99 f0       	breq	.+38     	; 0x1e00 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1dda:	8b 81       	ldd	r24, Y+3	; 0x03
    1ddc:	9c 81       	ldd	r25, Y+4	; 0x04
    1dde:	41 96       	adiw	r24, 0x11	; 17
    1de0:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <xTaskRemoveFromEventList>
    1de4:	88 23       	and	r24, r24
    1de6:	61 f0       	breq	.+24     	; 0x1e00 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1de8:	ef 81       	ldd	r30, Y+7	; 0x07
    1dea:	f8 85       	ldd	r31, Y+8	; 0x08
    1dec:	81 e0       	ldi	r24, 0x01	; 1
    1dee:	80 83       	st	Z, r24
    1df0:	07 c0       	rjmp	.+14     	; 0x1e00 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1df2:	eb 81       	ldd	r30, Y+3	; 0x03
    1df4:	fc 81       	ldd	r31, Y+4	; 0x04
    1df6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1df8:	8f 5f       	subi	r24, 0xFF	; 255
    1dfa:	eb 81       	ldd	r30, Y+3	; 0x03
    1dfc:	fc 81       	ldd	r31, Y+4	; 0x04
    1dfe:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1e00:	81 e0       	ldi	r24, 0x01	; 1
    1e02:	8a 83       	std	Y+2, r24	; 0x02
    1e04:	01 c0       	rjmp	.+2      	; 0x1e08 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1e06:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1e08:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1e0a:	29 96       	adiw	r28, 0x09	; 9
    1e0c:	0f b6       	in	r0, 0x3f	; 63
    1e0e:	f8 94       	cli
    1e10:	de bf       	out	0x3e, r29	; 62
    1e12:	0f be       	out	0x3f, r0	; 63
    1e14:	cd bf       	out	0x3d, r28	; 61
    1e16:	cf 91       	pop	r28
    1e18:	df 91       	pop	r29
    1e1a:	08 95       	ret

00001e1c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1e1c:	df 93       	push	r29
    1e1e:	cf 93       	push	r28
    1e20:	cd b7       	in	r28, 0x3d	; 61
    1e22:	de b7       	in	r29, 0x3e	; 62
    1e24:	2e 97       	sbiw	r28, 0x0e	; 14
    1e26:	0f b6       	in	r0, 0x3f	; 63
    1e28:	f8 94       	cli
    1e2a:	de bf       	out	0x3e, r29	; 62
    1e2c:	0f be       	out	0x3f, r0	; 63
    1e2e:	cd bf       	out	0x3d, r28	; 61
    1e30:	98 87       	std	Y+8, r25	; 0x08
    1e32:	8f 83       	std	Y+7, r24	; 0x07
    1e34:	7a 87       	std	Y+10, r23	; 0x0a
    1e36:	69 87       	std	Y+9, r22	; 0x09
    1e38:	5c 87       	std	Y+12, r21	; 0x0c
    1e3a:	4b 87       	std	Y+11, r20	; 0x0b
    1e3c:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1e3e:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1e40:	0f b6       	in	r0, 0x3f	; 63
    1e42:	f8 94       	cli
    1e44:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1e46:	ef 81       	ldd	r30, Y+7	; 0x07
    1e48:	f8 85       	ldd	r31, Y+8	; 0x08
    1e4a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e4c:	88 23       	and	r24, r24
    1e4e:	09 f4       	brne	.+2      	; 0x1e52 <xQueueGenericReceive+0x36>
    1e50:	3f c0       	rjmp	.+126    	; 0x1ed0 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1e52:	ef 81       	ldd	r30, Y+7	; 0x07
    1e54:	f8 85       	ldd	r31, Y+8	; 0x08
    1e56:	86 81       	ldd	r24, Z+6	; 0x06
    1e58:	97 81       	ldd	r25, Z+7	; 0x07
    1e5a:	9a 83       	std	Y+2, r25	; 0x02
    1e5c:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1e5e:	8f 81       	ldd	r24, Y+7	; 0x07
    1e60:	98 85       	ldd	r25, Y+8	; 0x08
    1e62:	29 85       	ldd	r18, Y+9	; 0x09
    1e64:	3a 85       	ldd	r19, Y+10	; 0x0a
    1e66:	b9 01       	movw	r22, r18
    1e68:	0e 94 f3 10 	call	0x21e6	; 0x21e6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1e6c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e6e:	88 23       	and	r24, r24
    1e70:	b1 f4       	brne	.+44     	; 0x1e9e <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1e72:	ef 81       	ldd	r30, Y+7	; 0x07
    1e74:	f8 85       	ldd	r31, Y+8	; 0x08
    1e76:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e78:	81 50       	subi	r24, 0x01	; 1
    1e7a:	ef 81       	ldd	r30, Y+7	; 0x07
    1e7c:	f8 85       	ldd	r31, Y+8	; 0x08
    1e7e:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e80:	ef 81       	ldd	r30, Y+7	; 0x07
    1e82:	f8 85       	ldd	r31, Y+8	; 0x08
    1e84:	80 85       	ldd	r24, Z+8	; 0x08
    1e86:	88 23       	and	r24, r24
    1e88:	f1 f0       	breq	.+60     	; 0x1ec6 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1e8a:	8f 81       	ldd	r24, Y+7	; 0x07
    1e8c:	98 85       	ldd	r25, Y+8	; 0x08
    1e8e:	08 96       	adiw	r24, 0x08	; 8
    1e90:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <xTaskRemoveFromEventList>
    1e94:	81 30       	cpi	r24, 0x01	; 1
    1e96:	b9 f4       	brne	.+46     	; 0x1ec6 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1e98:	0e 94 48 0c 	call	0x1890	; 0x1890 <vPortYield>
    1e9c:	14 c0       	rjmp	.+40     	; 0x1ec6 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1e9e:	ef 81       	ldd	r30, Y+7	; 0x07
    1ea0:	f8 85       	ldd	r31, Y+8	; 0x08
    1ea2:	89 81       	ldd	r24, Y+1	; 0x01
    1ea4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ea6:	97 83       	std	Z+7, r25	; 0x07
    1ea8:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1eaa:	ef 81       	ldd	r30, Y+7	; 0x07
    1eac:	f8 85       	ldd	r31, Y+8	; 0x08
    1eae:	81 89       	ldd	r24, Z+17	; 0x11
    1eb0:	88 23       	and	r24, r24
    1eb2:	49 f0       	breq	.+18     	; 0x1ec6 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1eb4:	8f 81       	ldd	r24, Y+7	; 0x07
    1eb6:	98 85       	ldd	r25, Y+8	; 0x08
    1eb8:	41 96       	adiw	r24, 0x11	; 17
    1eba:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <xTaskRemoveFromEventList>
    1ebe:	88 23       	and	r24, r24
    1ec0:	11 f0       	breq	.+4      	; 0x1ec6 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1ec2:	0e 94 48 0c 	call	0x1890	; 0x1890 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1ec6:	0f 90       	pop	r0
    1ec8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1eca:	81 e0       	ldi	r24, 0x01	; 1
    1ecc:	8e 87       	std	Y+14, r24	; 0x0e
    1ece:	5c c0       	rjmp	.+184    	; 0x1f88 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1ed0:	8b 85       	ldd	r24, Y+11	; 0x0b
    1ed2:	9c 85       	ldd	r25, Y+12	; 0x0c
    1ed4:	00 97       	sbiw	r24, 0x00	; 0
    1ed6:	21 f4       	brne	.+8      	; 0x1ee0 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ed8:	0f 90       	pop	r0
    1eda:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1edc:	1e 86       	std	Y+14, r1	; 0x0e
    1ede:	54 c0       	rjmp	.+168    	; 0x1f88 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1ee0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee2:	88 23       	and	r24, r24
    1ee4:	31 f4       	brne	.+12     	; 0x1ef2 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1ee6:	ce 01       	movw	r24, r28
    1ee8:	04 96       	adiw	r24, 0x04	; 4
    1eea:	0e 94 db 16 	call	0x2db6	; 0x2db6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1eee:	81 e0       	ldi	r24, 0x01	; 1
    1ef0:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1ef2:	0f 90       	pop	r0
    1ef4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1ef6:	0e 94 37 14 	call	0x286e	; 0x286e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1efa:	0f b6       	in	r0, 0x3f	; 63
    1efc:	f8 94       	cli
    1efe:	0f 92       	push	r0
    1f00:	ef 81       	ldd	r30, Y+7	; 0x07
    1f02:	f8 85       	ldd	r31, Y+8	; 0x08
    1f04:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f06:	8f 3f       	cpi	r24, 0xFF	; 255
    1f08:	19 f4       	brne	.+6      	; 0x1f10 <xQueueGenericReceive+0xf4>
    1f0a:	ef 81       	ldd	r30, Y+7	; 0x07
    1f0c:	f8 85       	ldd	r31, Y+8	; 0x08
    1f0e:	15 8e       	std	Z+29, r1	; 0x1d
    1f10:	ef 81       	ldd	r30, Y+7	; 0x07
    1f12:	f8 85       	ldd	r31, Y+8	; 0x08
    1f14:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f16:	8f 3f       	cpi	r24, 0xFF	; 255
    1f18:	19 f4       	brne	.+6      	; 0x1f20 <xQueueGenericReceive+0x104>
    1f1a:	ef 81       	ldd	r30, Y+7	; 0x07
    1f1c:	f8 85       	ldd	r31, Y+8	; 0x08
    1f1e:	16 8e       	std	Z+30, r1	; 0x1e
    1f20:	0f 90       	pop	r0
    1f22:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f24:	ce 01       	movw	r24, r28
    1f26:	04 96       	adiw	r24, 0x04	; 4
    1f28:	9e 01       	movw	r18, r28
    1f2a:	25 5f       	subi	r18, 0xF5	; 245
    1f2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1f2e:	b9 01       	movw	r22, r18
    1f30:	0e 94 f4 16 	call	0x2de8	; 0x2de8 <xTaskCheckForTimeOut>
    1f34:	88 23       	and	r24, r24
    1f36:	09 f5       	brne	.+66     	; 0x1f7a <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1f38:	8f 81       	ldd	r24, Y+7	; 0x07
    1f3a:	98 85       	ldd	r25, Y+8	; 0x08
    1f3c:	0e 94 8f 11 	call	0x231e	; 0x231e <prvIsQueueEmpty>
    1f40:	88 23       	and	r24, r24
    1f42:	a1 f0       	breq	.+40     	; 0x1f6c <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f44:	8f 81       	ldd	r24, Y+7	; 0x07
    1f46:	98 85       	ldd	r25, Y+8	; 0x08
    1f48:	41 96       	adiw	r24, 0x11	; 17
    1f4a:	2b 85       	ldd	r18, Y+11	; 0x0b
    1f4c:	3c 85       	ldd	r19, Y+12	; 0x0c
    1f4e:	b9 01       	movw	r22, r18
    1f50:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1f54:	8f 81       	ldd	r24, Y+7	; 0x07
    1f56:	98 85       	ldd	r25, Y+8	; 0x08
    1f58:	0e 94 3b 11 	call	0x2276	; 0x2276 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1f5c:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskResumeAll>
    1f60:	88 23       	and	r24, r24
    1f62:	09 f0       	breq	.+2      	; 0x1f66 <xQueueGenericReceive+0x14a>
    1f64:	6d cf       	rjmp	.-294    	; 0x1e40 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1f66:	0e 94 48 0c 	call	0x1890	; 0x1890 <vPortYield>
    1f6a:	6a cf       	rjmp	.-300    	; 0x1e40 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1f6c:	8f 81       	ldd	r24, Y+7	; 0x07
    1f6e:	98 85       	ldd	r25, Y+8	; 0x08
    1f70:	0e 94 3b 11 	call	0x2276	; 0x2276 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1f74:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskResumeAll>
    1f78:	63 cf       	rjmp	.-314    	; 0x1e40 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1f7a:	8f 81       	ldd	r24, Y+7	; 0x07
    1f7c:	98 85       	ldd	r25, Y+8	; 0x08
    1f7e:	0e 94 3b 11 	call	0x2276	; 0x2276 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1f82:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1f86:	1e 86       	std	Y+14, r1	; 0x0e
    1f88:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1f8a:	2e 96       	adiw	r28, 0x0e	; 14
    1f8c:	0f b6       	in	r0, 0x3f	; 63
    1f8e:	f8 94       	cli
    1f90:	de bf       	out	0x3e, r29	; 62
    1f92:	0f be       	out	0x3f, r0	; 63
    1f94:	cd bf       	out	0x3d, r28	; 61
    1f96:	cf 91       	pop	r28
    1f98:	df 91       	pop	r29
    1f9a:	08 95       	ret

00001f9c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1f9c:	df 93       	push	r29
    1f9e:	cf 93       	push	r28
    1fa0:	cd b7       	in	r28, 0x3d	; 61
    1fa2:	de b7       	in	r29, 0x3e	; 62
    1fa4:	28 97       	sbiw	r28, 0x08	; 8
    1fa6:	0f b6       	in	r0, 0x3f	; 63
    1fa8:	f8 94       	cli
    1faa:	de bf       	out	0x3e, r29	; 62
    1fac:	0f be       	out	0x3f, r0	; 63
    1fae:	cd bf       	out	0x3d, r28	; 61
    1fb0:	9c 83       	std	Y+4, r25	; 0x04
    1fb2:	8b 83       	std	Y+3, r24	; 0x03
    1fb4:	7e 83       	std	Y+6, r23	; 0x06
    1fb6:	6d 83       	std	Y+5, r22	; 0x05
    1fb8:	58 87       	std	Y+8, r21	; 0x08
    1fba:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1fbc:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1fbe:	eb 81       	ldd	r30, Y+3	; 0x03
    1fc0:	fc 81       	ldd	r31, Y+4	; 0x04
    1fc2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fc4:	88 23       	and	r24, r24
    1fc6:	71 f1       	breq	.+92     	; 0x2024 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1fc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1fca:	9c 81       	ldd	r25, Y+4	; 0x04
    1fcc:	2d 81       	ldd	r18, Y+5	; 0x05
    1fce:	3e 81       	ldd	r19, Y+6	; 0x06
    1fd0:	b9 01       	movw	r22, r18
    1fd2:	0e 94 f3 10 	call	0x21e6	; 0x21e6 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1fd6:	eb 81       	ldd	r30, Y+3	; 0x03
    1fd8:	fc 81       	ldd	r31, Y+4	; 0x04
    1fda:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fdc:	81 50       	subi	r24, 0x01	; 1
    1fde:	eb 81       	ldd	r30, Y+3	; 0x03
    1fe0:	fc 81       	ldd	r31, Y+4	; 0x04
    1fe2:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1fe4:	eb 81       	ldd	r30, Y+3	; 0x03
    1fe6:	fc 81       	ldd	r31, Y+4	; 0x04
    1fe8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fea:	8f 3f       	cpi	r24, 0xFF	; 255
    1fec:	89 f4       	brne	.+34     	; 0x2010 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1fee:	eb 81       	ldd	r30, Y+3	; 0x03
    1ff0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ff2:	80 85       	ldd	r24, Z+8	; 0x08
    1ff4:	88 23       	and	r24, r24
    1ff6:	99 f0       	breq	.+38     	; 0x201e <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ff8:	8b 81       	ldd	r24, Y+3	; 0x03
    1ffa:	9c 81       	ldd	r25, Y+4	; 0x04
    1ffc:	08 96       	adiw	r24, 0x08	; 8
    1ffe:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <xTaskRemoveFromEventList>
    2002:	88 23       	and	r24, r24
    2004:	61 f0       	breq	.+24     	; 0x201e <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2006:	ef 81       	ldd	r30, Y+7	; 0x07
    2008:	f8 85       	ldd	r31, Y+8	; 0x08
    200a:	81 e0       	ldi	r24, 0x01	; 1
    200c:	80 83       	st	Z, r24
    200e:	07 c0       	rjmp	.+14     	; 0x201e <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2010:	eb 81       	ldd	r30, Y+3	; 0x03
    2012:	fc 81       	ldd	r31, Y+4	; 0x04
    2014:	85 8d       	ldd	r24, Z+29	; 0x1d
    2016:	8f 5f       	subi	r24, 0xFF	; 255
    2018:	eb 81       	ldd	r30, Y+3	; 0x03
    201a:	fc 81       	ldd	r31, Y+4	; 0x04
    201c:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    201e:	81 e0       	ldi	r24, 0x01	; 1
    2020:	8a 83       	std	Y+2, r24	; 0x02
    2022:	01 c0       	rjmp	.+2      	; 0x2026 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    2024:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2026:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2028:	28 96       	adiw	r28, 0x08	; 8
    202a:	0f b6       	in	r0, 0x3f	; 63
    202c:	f8 94       	cli
    202e:	de bf       	out	0x3e, r29	; 62
    2030:	0f be       	out	0x3f, r0	; 63
    2032:	cd bf       	out	0x3d, r28	; 61
    2034:	cf 91       	pop	r28
    2036:	df 91       	pop	r29
    2038:	08 95       	ret

0000203a <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    203a:	df 93       	push	r29
    203c:	cf 93       	push	r28
    203e:	00 d0       	rcall	.+0      	; 0x2040 <uxQueueMessagesWaiting+0x6>
    2040:	0f 92       	push	r0
    2042:	cd b7       	in	r28, 0x3d	; 61
    2044:	de b7       	in	r29, 0x3e	; 62
    2046:	9b 83       	std	Y+3, r25	; 0x03
    2048:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    204a:	0f b6       	in	r0, 0x3f	; 63
    204c:	f8 94       	cli
    204e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2050:	ea 81       	ldd	r30, Y+2	; 0x02
    2052:	fb 81       	ldd	r31, Y+3	; 0x03
    2054:	82 8d       	ldd	r24, Z+26	; 0x1a
    2056:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2058:	0f 90       	pop	r0
    205a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    205c:	89 81       	ldd	r24, Y+1	; 0x01
}
    205e:	0f 90       	pop	r0
    2060:	0f 90       	pop	r0
    2062:	0f 90       	pop	r0
    2064:	cf 91       	pop	r28
    2066:	df 91       	pop	r29
    2068:	08 95       	ret

0000206a <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    206a:	df 93       	push	r29
    206c:	cf 93       	push	r28
    206e:	00 d0       	rcall	.+0      	; 0x2070 <uxQueueMessagesWaitingFromISR+0x6>
    2070:	0f 92       	push	r0
    2072:	cd b7       	in	r28, 0x3d	; 61
    2074:	de b7       	in	r29, 0x3e	; 62
    2076:	9b 83       	std	Y+3, r25	; 0x03
    2078:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    207a:	ea 81       	ldd	r30, Y+2	; 0x02
    207c:	fb 81       	ldd	r31, Y+3	; 0x03
    207e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2080:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    2082:	89 81       	ldd	r24, Y+1	; 0x01
}
    2084:	0f 90       	pop	r0
    2086:	0f 90       	pop	r0
    2088:	0f 90       	pop	r0
    208a:	cf 91       	pop	r28
    208c:	df 91       	pop	r29
    208e:	08 95       	ret

00002090 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    2090:	df 93       	push	r29
    2092:	cf 93       	push	r28
    2094:	00 d0       	rcall	.+0      	; 0x2096 <vQueueDelete+0x6>
    2096:	cd b7       	in	r28, 0x3d	; 61
    2098:	de b7       	in	r29, 0x3e	; 62
    209a:	9a 83       	std	Y+2, r25	; 0x02
    209c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    209e:	e9 81       	ldd	r30, Y+1	; 0x01
    20a0:	fa 81       	ldd	r31, Y+2	; 0x02
    20a2:	80 81       	ld	r24, Z
    20a4:	91 81       	ldd	r25, Z+1	; 0x01
    20a6:	0e 94 28 09 	call	0x1250	; 0x1250 <vPortFree>
	vPortFree( pxQueue );
    20aa:	89 81       	ldd	r24, Y+1	; 0x01
    20ac:	9a 81       	ldd	r25, Y+2	; 0x02
    20ae:	0e 94 28 09 	call	0x1250	; 0x1250 <vPortFree>
}
    20b2:	0f 90       	pop	r0
    20b4:	0f 90       	pop	r0
    20b6:	cf 91       	pop	r28
    20b8:	df 91       	pop	r29
    20ba:	08 95       	ret

000020bc <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    20bc:	df 93       	push	r29
    20be:	cf 93       	push	r28
    20c0:	00 d0       	rcall	.+0      	; 0x20c2 <prvCopyDataToQueue+0x6>
    20c2:	00 d0       	rcall	.+0      	; 0x20c4 <prvCopyDataToQueue+0x8>
    20c4:	0f 92       	push	r0
    20c6:	cd b7       	in	r28, 0x3d	; 61
    20c8:	de b7       	in	r29, 0x3e	; 62
    20ca:	9a 83       	std	Y+2, r25	; 0x02
    20cc:	89 83       	std	Y+1, r24	; 0x01
    20ce:	7c 83       	std	Y+4, r23	; 0x04
    20d0:	6b 83       	std	Y+3, r22	; 0x03
    20d2:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    20d4:	e9 81       	ldd	r30, Y+1	; 0x01
    20d6:	fa 81       	ldd	r31, Y+2	; 0x02
    20d8:	84 8d       	ldd	r24, Z+28	; 0x1c
    20da:	88 23       	and	r24, r24
    20dc:	09 f4       	brne	.+2      	; 0x20e0 <prvCopyDataToQueue+0x24>
    20de:	74 c0       	rjmp	.+232    	; 0x21c8 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    20e0:	8d 81       	ldd	r24, Y+5	; 0x05
    20e2:	88 23       	and	r24, r24
    20e4:	99 f5       	brne	.+102    	; 0x214c <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    20e6:	e9 81       	ldd	r30, Y+1	; 0x01
    20e8:	fa 81       	ldd	r31, Y+2	; 0x02
    20ea:	64 81       	ldd	r22, Z+4	; 0x04
    20ec:	75 81       	ldd	r23, Z+5	; 0x05
    20ee:	e9 81       	ldd	r30, Y+1	; 0x01
    20f0:	fa 81       	ldd	r31, Y+2	; 0x02
    20f2:	84 8d       	ldd	r24, Z+28	; 0x1c
    20f4:	48 2f       	mov	r20, r24
    20f6:	50 e0       	ldi	r21, 0x00	; 0
    20f8:	2b 81       	ldd	r18, Y+3	; 0x03
    20fa:	3c 81       	ldd	r19, Y+4	; 0x04
    20fc:	cb 01       	movw	r24, r22
    20fe:	b9 01       	movw	r22, r18
    2100:	0e 94 c8 21 	call	0x4390	; 0x4390 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2104:	e9 81       	ldd	r30, Y+1	; 0x01
    2106:	fa 81       	ldd	r31, Y+2	; 0x02
    2108:	24 81       	ldd	r18, Z+4	; 0x04
    210a:	35 81       	ldd	r19, Z+5	; 0x05
    210c:	e9 81       	ldd	r30, Y+1	; 0x01
    210e:	fa 81       	ldd	r31, Y+2	; 0x02
    2110:	84 8d       	ldd	r24, Z+28	; 0x1c
    2112:	88 2f       	mov	r24, r24
    2114:	90 e0       	ldi	r25, 0x00	; 0
    2116:	82 0f       	add	r24, r18
    2118:	93 1f       	adc	r25, r19
    211a:	e9 81       	ldd	r30, Y+1	; 0x01
    211c:	fa 81       	ldd	r31, Y+2	; 0x02
    211e:	95 83       	std	Z+5, r25	; 0x05
    2120:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2122:	e9 81       	ldd	r30, Y+1	; 0x01
    2124:	fa 81       	ldd	r31, Y+2	; 0x02
    2126:	24 81       	ldd	r18, Z+4	; 0x04
    2128:	35 81       	ldd	r19, Z+5	; 0x05
    212a:	e9 81       	ldd	r30, Y+1	; 0x01
    212c:	fa 81       	ldd	r31, Y+2	; 0x02
    212e:	82 81       	ldd	r24, Z+2	; 0x02
    2130:	93 81       	ldd	r25, Z+3	; 0x03
    2132:	28 17       	cp	r18, r24
    2134:	39 07       	cpc	r19, r25
    2136:	08 f4       	brcc	.+2      	; 0x213a <prvCopyDataToQueue+0x7e>
    2138:	47 c0       	rjmp	.+142    	; 0x21c8 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    213a:	e9 81       	ldd	r30, Y+1	; 0x01
    213c:	fa 81       	ldd	r31, Y+2	; 0x02
    213e:	80 81       	ld	r24, Z
    2140:	91 81       	ldd	r25, Z+1	; 0x01
    2142:	e9 81       	ldd	r30, Y+1	; 0x01
    2144:	fa 81       	ldd	r31, Y+2	; 0x02
    2146:	95 83       	std	Z+5, r25	; 0x05
    2148:	84 83       	std	Z+4, r24	; 0x04
    214a:	3e c0       	rjmp	.+124    	; 0x21c8 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    214c:	e9 81       	ldd	r30, Y+1	; 0x01
    214e:	fa 81       	ldd	r31, Y+2	; 0x02
    2150:	66 81       	ldd	r22, Z+6	; 0x06
    2152:	77 81       	ldd	r23, Z+7	; 0x07
    2154:	e9 81       	ldd	r30, Y+1	; 0x01
    2156:	fa 81       	ldd	r31, Y+2	; 0x02
    2158:	84 8d       	ldd	r24, Z+28	; 0x1c
    215a:	48 2f       	mov	r20, r24
    215c:	50 e0       	ldi	r21, 0x00	; 0
    215e:	2b 81       	ldd	r18, Y+3	; 0x03
    2160:	3c 81       	ldd	r19, Y+4	; 0x04
    2162:	cb 01       	movw	r24, r22
    2164:	b9 01       	movw	r22, r18
    2166:	0e 94 c8 21 	call	0x4390	; 0x4390 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    216a:	e9 81       	ldd	r30, Y+1	; 0x01
    216c:	fa 81       	ldd	r31, Y+2	; 0x02
    216e:	26 81       	ldd	r18, Z+6	; 0x06
    2170:	37 81       	ldd	r19, Z+7	; 0x07
    2172:	e9 81       	ldd	r30, Y+1	; 0x01
    2174:	fa 81       	ldd	r31, Y+2	; 0x02
    2176:	84 8d       	ldd	r24, Z+28	; 0x1c
    2178:	88 2f       	mov	r24, r24
    217a:	90 e0       	ldi	r25, 0x00	; 0
    217c:	90 95       	com	r25
    217e:	81 95       	neg	r24
    2180:	9f 4f       	sbci	r25, 0xFF	; 255
    2182:	82 0f       	add	r24, r18
    2184:	93 1f       	adc	r25, r19
    2186:	e9 81       	ldd	r30, Y+1	; 0x01
    2188:	fa 81       	ldd	r31, Y+2	; 0x02
    218a:	97 83       	std	Z+7, r25	; 0x07
    218c:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    218e:	e9 81       	ldd	r30, Y+1	; 0x01
    2190:	fa 81       	ldd	r31, Y+2	; 0x02
    2192:	26 81       	ldd	r18, Z+6	; 0x06
    2194:	37 81       	ldd	r19, Z+7	; 0x07
    2196:	e9 81       	ldd	r30, Y+1	; 0x01
    2198:	fa 81       	ldd	r31, Y+2	; 0x02
    219a:	80 81       	ld	r24, Z
    219c:	91 81       	ldd	r25, Z+1	; 0x01
    219e:	28 17       	cp	r18, r24
    21a0:	39 07       	cpc	r19, r25
    21a2:	90 f4       	brcc	.+36     	; 0x21c8 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    21a4:	e9 81       	ldd	r30, Y+1	; 0x01
    21a6:	fa 81       	ldd	r31, Y+2	; 0x02
    21a8:	22 81       	ldd	r18, Z+2	; 0x02
    21aa:	33 81       	ldd	r19, Z+3	; 0x03
    21ac:	e9 81       	ldd	r30, Y+1	; 0x01
    21ae:	fa 81       	ldd	r31, Y+2	; 0x02
    21b0:	84 8d       	ldd	r24, Z+28	; 0x1c
    21b2:	88 2f       	mov	r24, r24
    21b4:	90 e0       	ldi	r25, 0x00	; 0
    21b6:	90 95       	com	r25
    21b8:	81 95       	neg	r24
    21ba:	9f 4f       	sbci	r25, 0xFF	; 255
    21bc:	82 0f       	add	r24, r18
    21be:	93 1f       	adc	r25, r19
    21c0:	e9 81       	ldd	r30, Y+1	; 0x01
    21c2:	fa 81       	ldd	r31, Y+2	; 0x02
    21c4:	97 83       	std	Z+7, r25	; 0x07
    21c6:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    21c8:	e9 81       	ldd	r30, Y+1	; 0x01
    21ca:	fa 81       	ldd	r31, Y+2	; 0x02
    21cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    21ce:	8f 5f       	subi	r24, 0xFF	; 255
    21d0:	e9 81       	ldd	r30, Y+1	; 0x01
    21d2:	fa 81       	ldd	r31, Y+2	; 0x02
    21d4:	82 8f       	std	Z+26, r24	; 0x1a
}
    21d6:	0f 90       	pop	r0
    21d8:	0f 90       	pop	r0
    21da:	0f 90       	pop	r0
    21dc:	0f 90       	pop	r0
    21de:	0f 90       	pop	r0
    21e0:	cf 91       	pop	r28
    21e2:	df 91       	pop	r29
    21e4:	08 95       	ret

000021e6 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    21e6:	df 93       	push	r29
    21e8:	cf 93       	push	r28
    21ea:	00 d0       	rcall	.+0      	; 0x21ec <prvCopyDataFromQueue+0x6>
    21ec:	00 d0       	rcall	.+0      	; 0x21ee <prvCopyDataFromQueue+0x8>
    21ee:	cd b7       	in	r28, 0x3d	; 61
    21f0:	de b7       	in	r29, 0x3e	; 62
    21f2:	9a 83       	std	Y+2, r25	; 0x02
    21f4:	89 83       	std	Y+1, r24	; 0x01
    21f6:	7c 83       	std	Y+4, r23	; 0x04
    21f8:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    21fa:	e9 81       	ldd	r30, Y+1	; 0x01
    21fc:	fa 81       	ldd	r31, Y+2	; 0x02
    21fe:	80 81       	ld	r24, Z
    2200:	91 81       	ldd	r25, Z+1	; 0x01
    2202:	00 97       	sbiw	r24, 0x00	; 0
    2204:	89 f1       	breq	.+98     	; 0x2268 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    2206:	e9 81       	ldd	r30, Y+1	; 0x01
    2208:	fa 81       	ldd	r31, Y+2	; 0x02
    220a:	26 81       	ldd	r18, Z+6	; 0x06
    220c:	37 81       	ldd	r19, Z+7	; 0x07
    220e:	e9 81       	ldd	r30, Y+1	; 0x01
    2210:	fa 81       	ldd	r31, Y+2	; 0x02
    2212:	84 8d       	ldd	r24, Z+28	; 0x1c
    2214:	88 2f       	mov	r24, r24
    2216:	90 e0       	ldi	r25, 0x00	; 0
    2218:	82 0f       	add	r24, r18
    221a:	93 1f       	adc	r25, r19
    221c:	e9 81       	ldd	r30, Y+1	; 0x01
    221e:	fa 81       	ldd	r31, Y+2	; 0x02
    2220:	97 83       	std	Z+7, r25	; 0x07
    2222:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    2224:	e9 81       	ldd	r30, Y+1	; 0x01
    2226:	fa 81       	ldd	r31, Y+2	; 0x02
    2228:	26 81       	ldd	r18, Z+6	; 0x06
    222a:	37 81       	ldd	r19, Z+7	; 0x07
    222c:	e9 81       	ldd	r30, Y+1	; 0x01
    222e:	fa 81       	ldd	r31, Y+2	; 0x02
    2230:	82 81       	ldd	r24, Z+2	; 0x02
    2232:	93 81       	ldd	r25, Z+3	; 0x03
    2234:	28 17       	cp	r18, r24
    2236:	39 07       	cpc	r19, r25
    2238:	40 f0       	brcs	.+16     	; 0x224a <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    223a:	e9 81       	ldd	r30, Y+1	; 0x01
    223c:	fa 81       	ldd	r31, Y+2	; 0x02
    223e:	80 81       	ld	r24, Z
    2240:	91 81       	ldd	r25, Z+1	; 0x01
    2242:	e9 81       	ldd	r30, Y+1	; 0x01
    2244:	fa 81       	ldd	r31, Y+2	; 0x02
    2246:	97 83       	std	Z+7, r25	; 0x07
    2248:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    224a:	e9 81       	ldd	r30, Y+1	; 0x01
    224c:	fa 81       	ldd	r31, Y+2	; 0x02
    224e:	46 81       	ldd	r20, Z+6	; 0x06
    2250:	57 81       	ldd	r21, Z+7	; 0x07
    2252:	e9 81       	ldd	r30, Y+1	; 0x01
    2254:	fa 81       	ldd	r31, Y+2	; 0x02
    2256:	84 8d       	ldd	r24, Z+28	; 0x1c
    2258:	28 2f       	mov	r18, r24
    225a:	30 e0       	ldi	r19, 0x00	; 0
    225c:	8b 81       	ldd	r24, Y+3	; 0x03
    225e:	9c 81       	ldd	r25, Y+4	; 0x04
    2260:	ba 01       	movw	r22, r20
    2262:	a9 01       	movw	r20, r18
    2264:	0e 94 c8 21 	call	0x4390	; 0x4390 <memcpy>
	}
}
    2268:	0f 90       	pop	r0
    226a:	0f 90       	pop	r0
    226c:	0f 90       	pop	r0
    226e:	0f 90       	pop	r0
    2270:	cf 91       	pop	r28
    2272:	df 91       	pop	r29
    2274:	08 95       	ret

00002276 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    2276:	df 93       	push	r29
    2278:	cf 93       	push	r28
    227a:	00 d0       	rcall	.+0      	; 0x227c <prvUnlockQueue+0x6>
    227c:	cd b7       	in	r28, 0x3d	; 61
    227e:	de b7       	in	r29, 0x3e	; 62
    2280:	9a 83       	std	Y+2, r25	; 0x02
    2282:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2284:	0f b6       	in	r0, 0x3f	; 63
    2286:	f8 94       	cli
    2288:	0f 92       	push	r0
    228a:	15 c0       	rjmp	.+42     	; 0x22b6 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    228c:	e9 81       	ldd	r30, Y+1	; 0x01
    228e:	fa 81       	ldd	r31, Y+2	; 0x02
    2290:	81 89       	ldd	r24, Z+17	; 0x11
    2292:	88 23       	and	r24, r24
    2294:	a9 f0       	breq	.+42     	; 0x22c0 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2296:	89 81       	ldd	r24, Y+1	; 0x01
    2298:	9a 81       	ldd	r25, Y+2	; 0x02
    229a:	41 96       	adiw	r24, 0x11	; 17
    229c:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <xTaskRemoveFromEventList>
    22a0:	88 23       	and	r24, r24
    22a2:	11 f0       	breq	.+4      	; 0x22a8 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    22a4:	0e 94 51 17 	call	0x2ea2	; 0x2ea2 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    22a8:	e9 81       	ldd	r30, Y+1	; 0x01
    22aa:	fa 81       	ldd	r31, Y+2	; 0x02
    22ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    22ae:	81 50       	subi	r24, 0x01	; 1
    22b0:	e9 81       	ldd	r30, Y+1	; 0x01
    22b2:	fa 81       	ldd	r31, Y+2	; 0x02
    22b4:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    22b6:	e9 81       	ldd	r30, Y+1	; 0x01
    22b8:	fa 81       	ldd	r31, Y+2	; 0x02
    22ba:	86 8d       	ldd	r24, Z+30	; 0x1e
    22bc:	18 16       	cp	r1, r24
    22be:	34 f3       	brlt	.-52     	; 0x228c <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    22c0:	e9 81       	ldd	r30, Y+1	; 0x01
    22c2:	fa 81       	ldd	r31, Y+2	; 0x02
    22c4:	8f ef       	ldi	r24, 0xFF	; 255
    22c6:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    22c8:	0f 90       	pop	r0
    22ca:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    22cc:	0f b6       	in	r0, 0x3f	; 63
    22ce:	f8 94       	cli
    22d0:	0f 92       	push	r0
    22d2:	15 c0       	rjmp	.+42     	; 0x22fe <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    22d4:	e9 81       	ldd	r30, Y+1	; 0x01
    22d6:	fa 81       	ldd	r31, Y+2	; 0x02
    22d8:	80 85       	ldd	r24, Z+8	; 0x08
    22da:	88 23       	and	r24, r24
    22dc:	a9 f0       	breq	.+42     	; 0x2308 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    22de:	89 81       	ldd	r24, Y+1	; 0x01
    22e0:	9a 81       	ldd	r25, Y+2	; 0x02
    22e2:	08 96       	adiw	r24, 0x08	; 8
    22e4:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <xTaskRemoveFromEventList>
    22e8:	88 23       	and	r24, r24
    22ea:	11 f0       	breq	.+4      	; 0x22f0 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    22ec:	0e 94 51 17 	call	0x2ea2	; 0x2ea2 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    22f0:	e9 81       	ldd	r30, Y+1	; 0x01
    22f2:	fa 81       	ldd	r31, Y+2	; 0x02
    22f4:	85 8d       	ldd	r24, Z+29	; 0x1d
    22f6:	81 50       	subi	r24, 0x01	; 1
    22f8:	e9 81       	ldd	r30, Y+1	; 0x01
    22fa:	fa 81       	ldd	r31, Y+2	; 0x02
    22fc:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    22fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2300:	fa 81       	ldd	r31, Y+2	; 0x02
    2302:	85 8d       	ldd	r24, Z+29	; 0x1d
    2304:	18 16       	cp	r1, r24
    2306:	34 f3       	brlt	.-52     	; 0x22d4 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2308:	e9 81       	ldd	r30, Y+1	; 0x01
    230a:	fa 81       	ldd	r31, Y+2	; 0x02
    230c:	8f ef       	ldi	r24, 0xFF	; 255
    230e:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2310:	0f 90       	pop	r0
    2312:	0f be       	out	0x3f, r0	; 63
}
    2314:	0f 90       	pop	r0
    2316:	0f 90       	pop	r0
    2318:	cf 91       	pop	r28
    231a:	df 91       	pop	r29
    231c:	08 95       	ret

0000231e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    231e:	df 93       	push	r29
    2320:	cf 93       	push	r28
    2322:	00 d0       	rcall	.+0      	; 0x2324 <prvIsQueueEmpty+0x6>
    2324:	0f 92       	push	r0
    2326:	cd b7       	in	r28, 0x3d	; 61
    2328:	de b7       	in	r29, 0x3e	; 62
    232a:	9b 83       	std	Y+3, r25	; 0x03
    232c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    232e:	0f b6       	in	r0, 0x3f	; 63
    2330:	f8 94       	cli
    2332:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2334:	ea 81       	ldd	r30, Y+2	; 0x02
    2336:	fb 81       	ldd	r31, Y+3	; 0x03
    2338:	82 8d       	ldd	r24, Z+26	; 0x1a
    233a:	19 82       	std	Y+1, r1	; 0x01
    233c:	88 23       	and	r24, r24
    233e:	11 f4       	brne	.+4      	; 0x2344 <prvIsQueueEmpty+0x26>
    2340:	81 e0       	ldi	r24, 0x01	; 1
    2342:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2344:	0f 90       	pop	r0
    2346:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2348:	89 81       	ldd	r24, Y+1	; 0x01
}
    234a:	0f 90       	pop	r0
    234c:	0f 90       	pop	r0
    234e:	0f 90       	pop	r0
    2350:	cf 91       	pop	r28
    2352:	df 91       	pop	r29
    2354:	08 95       	ret

00002356 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    2356:	df 93       	push	r29
    2358:	cf 93       	push	r28
    235a:	00 d0       	rcall	.+0      	; 0x235c <xQueueIsQueueEmptyFromISR+0x6>
    235c:	0f 92       	push	r0
    235e:	cd b7       	in	r28, 0x3d	; 61
    2360:	de b7       	in	r29, 0x3e	; 62
    2362:	9b 83       	std	Y+3, r25	; 0x03
    2364:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2366:	ea 81       	ldd	r30, Y+2	; 0x02
    2368:	fb 81       	ldd	r31, Y+3	; 0x03
    236a:	82 8d       	ldd	r24, Z+26	; 0x1a
    236c:	19 82       	std	Y+1, r1	; 0x01
    236e:	88 23       	and	r24, r24
    2370:	11 f4       	brne	.+4      	; 0x2376 <xQueueIsQueueEmptyFromISR+0x20>
    2372:	81 e0       	ldi	r24, 0x01	; 1
    2374:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2376:	89 81       	ldd	r24, Y+1	; 0x01
}
    2378:	0f 90       	pop	r0
    237a:	0f 90       	pop	r0
    237c:	0f 90       	pop	r0
    237e:	cf 91       	pop	r28
    2380:	df 91       	pop	r29
    2382:	08 95       	ret

00002384 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    2384:	df 93       	push	r29
    2386:	cf 93       	push	r28
    2388:	00 d0       	rcall	.+0      	; 0x238a <prvIsQueueFull+0x6>
    238a:	0f 92       	push	r0
    238c:	cd b7       	in	r28, 0x3d	; 61
    238e:	de b7       	in	r29, 0x3e	; 62
    2390:	9b 83       	std	Y+3, r25	; 0x03
    2392:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2394:	0f b6       	in	r0, 0x3f	; 63
    2396:	f8 94       	cli
    2398:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    239a:	ea 81       	ldd	r30, Y+2	; 0x02
    239c:	fb 81       	ldd	r31, Y+3	; 0x03
    239e:	92 8d       	ldd	r25, Z+26	; 0x1a
    23a0:	ea 81       	ldd	r30, Y+2	; 0x02
    23a2:	fb 81       	ldd	r31, Y+3	; 0x03
    23a4:	83 8d       	ldd	r24, Z+27	; 0x1b
    23a6:	19 82       	std	Y+1, r1	; 0x01
    23a8:	98 17       	cp	r25, r24
    23aa:	11 f4       	brne	.+4      	; 0x23b0 <prvIsQueueFull+0x2c>
    23ac:	81 e0       	ldi	r24, 0x01	; 1
    23ae:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    23b0:	0f 90       	pop	r0
    23b2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    23b4:	89 81       	ldd	r24, Y+1	; 0x01
}
    23b6:	0f 90       	pop	r0
    23b8:	0f 90       	pop	r0
    23ba:	0f 90       	pop	r0
    23bc:	cf 91       	pop	r28
    23be:	df 91       	pop	r29
    23c0:	08 95       	ret

000023c2 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    23c2:	df 93       	push	r29
    23c4:	cf 93       	push	r28
    23c6:	00 d0       	rcall	.+0      	; 0x23c8 <xQueueIsQueueFullFromISR+0x6>
    23c8:	0f 92       	push	r0
    23ca:	cd b7       	in	r28, 0x3d	; 61
    23cc:	de b7       	in	r29, 0x3e	; 62
    23ce:	9b 83       	std	Y+3, r25	; 0x03
    23d0:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    23d2:	ea 81       	ldd	r30, Y+2	; 0x02
    23d4:	fb 81       	ldd	r31, Y+3	; 0x03
    23d6:	92 8d       	ldd	r25, Z+26	; 0x1a
    23d8:	ea 81       	ldd	r30, Y+2	; 0x02
    23da:	fb 81       	ldd	r31, Y+3	; 0x03
    23dc:	83 8d       	ldd	r24, Z+27	; 0x1b
    23de:	19 82       	std	Y+1, r1	; 0x01
    23e0:	98 17       	cp	r25, r24
    23e2:	11 f4       	brne	.+4      	; 0x23e8 <xQueueIsQueueFullFromISR+0x26>
    23e4:	81 e0       	ldi	r24, 0x01	; 1
    23e6:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    23e8:	89 81       	ldd	r24, Y+1	; 0x01
}
    23ea:	0f 90       	pop	r0
    23ec:	0f 90       	pop	r0
    23ee:	0f 90       	pop	r0
    23f0:	cf 91       	pop	r28
    23f2:	df 91       	pop	r29
    23f4:	08 95       	ret

000023f6 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    23f6:	af 92       	push	r10
    23f8:	bf 92       	push	r11
    23fa:	cf 92       	push	r12
    23fc:	df 92       	push	r13
    23fe:	ef 92       	push	r14
    2400:	ff 92       	push	r15
    2402:	0f 93       	push	r16
    2404:	1f 93       	push	r17
    2406:	df 93       	push	r29
    2408:	cf 93       	push	r28
    240a:	cd b7       	in	r28, 0x3d	; 61
    240c:	de b7       	in	r29, 0x3e	; 62
    240e:	64 97       	sbiw	r28, 0x14	; 20
    2410:	0f b6       	in	r0, 0x3f	; 63
    2412:	f8 94       	cli
    2414:	de bf       	out	0x3e, r29	; 62
    2416:	0f be       	out	0x3f, r0	; 63
    2418:	cd bf       	out	0x3d, r28	; 61
    241a:	9f 83       	std	Y+7, r25	; 0x07
    241c:	8e 83       	std	Y+6, r24	; 0x06
    241e:	79 87       	std	Y+9, r23	; 0x09
    2420:	68 87       	std	Y+8, r22	; 0x08
    2422:	5b 87       	std	Y+11, r21	; 0x0b
    2424:	4a 87       	std	Y+10, r20	; 0x0a
    2426:	3d 87       	std	Y+13, r19	; 0x0d
    2428:	2c 87       	std	Y+12, r18	; 0x0c
    242a:	0e 87       	std	Y+14, r16	; 0x0e
    242c:	f8 8a       	std	Y+16, r15	; 0x10
    242e:	ef 86       	std	Y+15, r14	; 0x0f
    2430:	da 8a       	std	Y+18, r13	; 0x12
    2432:	c9 8a       	std	Y+17, r12	; 0x11
    2434:	bc 8a       	std	Y+20, r11	; 0x14
    2436:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    2438:	8a 85       	ldd	r24, Y+10	; 0x0a
    243a:	9b 85       	ldd	r25, Y+11	; 0x0b
    243c:	29 89       	ldd	r18, Y+17	; 0x11
    243e:	3a 89       	ldd	r19, Y+18	; 0x12
    2440:	b9 01       	movw	r22, r18
    2442:	0e 94 80 18 	call	0x3100	; 0x3100 <prvAllocateTCBAndStack>
    2446:	9c 83       	std	Y+4, r25	; 0x04
    2448:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    244a:	8b 81       	ldd	r24, Y+3	; 0x03
    244c:	9c 81       	ldd	r25, Y+4	; 0x04
    244e:	00 97       	sbiw	r24, 0x00	; 0
    2450:	09 f4       	brne	.+2      	; 0x2454 <xTaskGenericCreate+0x5e>
    2452:	99 c0       	rjmp	.+306    	; 0x2586 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    2454:	eb 81       	ldd	r30, Y+3	; 0x03
    2456:	fc 81       	ldd	r31, Y+4	; 0x04
    2458:	27 89       	ldd	r18, Z+23	; 0x17
    245a:	30 8d       	ldd	r19, Z+24	; 0x18
    245c:	8a 85       	ldd	r24, Y+10	; 0x0a
    245e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2460:	01 97       	sbiw	r24, 0x01	; 1
    2462:	82 0f       	add	r24, r18
    2464:	93 1f       	adc	r25, r19
    2466:	9a 83       	std	Y+2, r25	; 0x02
    2468:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    246a:	8b 81       	ldd	r24, Y+3	; 0x03
    246c:	9c 81       	ldd	r25, Y+4	; 0x04
    246e:	28 85       	ldd	r18, Y+8	; 0x08
    2470:	39 85       	ldd	r19, Y+9	; 0x09
    2472:	eb 89       	ldd	r30, Y+19	; 0x13
    2474:	fc 89       	ldd	r31, Y+20	; 0x14
    2476:	aa 85       	ldd	r26, Y+10	; 0x0a
    2478:	bb 85       	ldd	r27, Y+11	; 0x0b
    247a:	b9 01       	movw	r22, r18
    247c:	4e 85       	ldd	r20, Y+14	; 0x0e
    247e:	9f 01       	movw	r18, r30
    2480:	8d 01       	movw	r16, r26
    2482:	0e 94 65 17 	call	0x2eca	; 0x2eca <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2486:	89 81       	ldd	r24, Y+1	; 0x01
    2488:	9a 81       	ldd	r25, Y+2	; 0x02
    248a:	2e 81       	ldd	r18, Y+6	; 0x06
    248c:	3f 81       	ldd	r19, Y+7	; 0x07
    248e:	4c 85       	ldd	r20, Y+12	; 0x0c
    2490:	5d 85       	ldd	r21, Y+13	; 0x0d
    2492:	b9 01       	movw	r22, r18
    2494:	0e 94 89 0a 	call	0x1512	; 0x1512 <pxPortInitialiseStack>
    2498:	eb 81       	ldd	r30, Y+3	; 0x03
    249a:	fc 81       	ldd	r31, Y+4	; 0x04
    249c:	91 83       	std	Z+1, r25	; 0x01
    249e:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    24a0:	8f 85       	ldd	r24, Y+15	; 0x0f
    24a2:	98 89       	ldd	r25, Y+16	; 0x10
    24a4:	00 97       	sbiw	r24, 0x00	; 0
    24a6:	31 f0       	breq	.+12     	; 0x24b4 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    24a8:	ef 85       	ldd	r30, Y+15	; 0x0f
    24aa:	f8 89       	ldd	r31, Y+16	; 0x10
    24ac:	8b 81       	ldd	r24, Y+3	; 0x03
    24ae:	9c 81       	ldd	r25, Y+4	; 0x04
    24b0:	91 83       	std	Z+1, r25	; 0x01
    24b2:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    24b4:	0f b6       	in	r0, 0x3f	; 63
    24b6:	f8 94       	cli
    24b8:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    24ba:	80 91 2d 05 	lds	r24, 0x052D
    24be:	8f 5f       	subi	r24, 0xFF	; 255
    24c0:	80 93 2d 05 	sts	0x052D, r24
			if( pxCurrentTCB == NULL )
    24c4:	80 91 2a 05 	lds	r24, 0x052A
    24c8:	90 91 2b 05 	lds	r25, 0x052B
    24cc:	00 97       	sbiw	r24, 0x00	; 0
    24ce:	69 f4       	brne	.+26     	; 0x24ea <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    24d0:	8b 81       	ldd	r24, Y+3	; 0x03
    24d2:	9c 81       	ldd	r25, Y+4	; 0x04
    24d4:	90 93 2b 05 	sts	0x052B, r25
    24d8:	80 93 2a 05 	sts	0x052A, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    24dc:	80 91 2d 05 	lds	r24, 0x052D
    24e0:	81 30       	cpi	r24, 0x01	; 1
    24e2:	a9 f4       	brne	.+42     	; 0x250e <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    24e4:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <prvInitialiseTaskLists>
    24e8:	12 c0       	rjmp	.+36     	; 0x250e <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    24ea:	80 91 32 05 	lds	r24, 0x0532
    24ee:	88 23       	and	r24, r24
    24f0:	71 f4       	brne	.+28     	; 0x250e <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    24f2:	e0 91 2a 05 	lds	r30, 0x052A
    24f6:	f0 91 2b 05 	lds	r31, 0x052B
    24fa:	96 89       	ldd	r25, Z+22	; 0x16
    24fc:	8e 85       	ldd	r24, Y+14	; 0x0e
    24fe:	89 17       	cp	r24, r25
    2500:	30 f0       	brcs	.+12     	; 0x250e <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    2502:	8b 81       	ldd	r24, Y+3	; 0x03
    2504:	9c 81       	ldd	r25, Y+4	; 0x04
    2506:	90 93 2b 05 	sts	0x052B, r25
    250a:	80 93 2a 05 	sts	0x052A, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    250e:	eb 81       	ldd	r30, Y+3	; 0x03
    2510:	fc 81       	ldd	r31, Y+4	; 0x04
    2512:	96 89       	ldd	r25, Z+22	; 0x16
    2514:	80 91 30 05 	lds	r24, 0x0530
    2518:	89 17       	cp	r24, r25
    251a:	28 f4       	brcc	.+10     	; 0x2526 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    251c:	eb 81       	ldd	r30, Y+3	; 0x03
    251e:	fc 81       	ldd	r31, Y+4	; 0x04
    2520:	86 89       	ldd	r24, Z+22	; 0x16
    2522:	80 93 30 05 	sts	0x0530, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2526:	80 91 37 05 	lds	r24, 0x0537
    252a:	8f 5f       	subi	r24, 0xFF	; 255
    252c:	80 93 37 05 	sts	0x0537, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    2530:	eb 81       	ldd	r30, Y+3	; 0x03
    2532:	fc 81       	ldd	r31, Y+4	; 0x04
    2534:	96 89       	ldd	r25, Z+22	; 0x16
    2536:	80 91 31 05 	lds	r24, 0x0531
    253a:	89 17       	cp	r24, r25
    253c:	28 f4       	brcc	.+10     	; 0x2548 <xTaskGenericCreate+0x152>
    253e:	eb 81       	ldd	r30, Y+3	; 0x03
    2540:	fc 81       	ldd	r31, Y+4	; 0x04
    2542:	86 89       	ldd	r24, Z+22	; 0x16
    2544:	80 93 31 05 	sts	0x0531, r24
    2548:	eb 81       	ldd	r30, Y+3	; 0x03
    254a:	fc 81       	ldd	r31, Y+4	; 0x04
    254c:	86 89       	ldd	r24, Z+22	; 0x16
    254e:	28 2f       	mov	r18, r24
    2550:	30 e0       	ldi	r19, 0x00	; 0
    2552:	c9 01       	movw	r24, r18
    2554:	88 0f       	add	r24, r24
    2556:	99 1f       	adc	r25, r25
    2558:	88 0f       	add	r24, r24
    255a:	99 1f       	adc	r25, r25
    255c:	88 0f       	add	r24, r24
    255e:	99 1f       	adc	r25, r25
    2560:	82 0f       	add	r24, r18
    2562:	93 1f       	adc	r25, r19
    2564:	ac 01       	movw	r20, r24
    2566:	48 5c       	subi	r20, 0xC8	; 200
    2568:	5a 4f       	sbci	r21, 0xFA	; 250
    256a:	8b 81       	ldd	r24, Y+3	; 0x03
    256c:	9c 81       	ldd	r25, Y+4	; 0x04
    256e:	9c 01       	movw	r18, r24
    2570:	2e 5f       	subi	r18, 0xFE	; 254
    2572:	3f 4f       	sbci	r19, 0xFF	; 255
    2574:	ca 01       	movw	r24, r20
    2576:	b9 01       	movw	r22, r18
    2578:	0e 94 88 09 	call	0x1310	; 0x1310 <vListInsertEnd>

			xReturn = pdPASS;
    257c:	81 e0       	ldi	r24, 0x01	; 1
    257e:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2580:	0f 90       	pop	r0
    2582:	0f be       	out	0x3f, r0	; 63
    2584:	02 c0       	rjmp	.+4      	; 0x258a <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2586:	8f ef       	ldi	r24, 0xFF	; 255
    2588:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    258a:	8d 81       	ldd	r24, Y+5	; 0x05
    258c:	81 30       	cpi	r24, 0x01	; 1
    258e:	71 f4       	brne	.+28     	; 0x25ac <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    2590:	80 91 32 05 	lds	r24, 0x0532
    2594:	88 23       	and	r24, r24
    2596:	51 f0       	breq	.+20     	; 0x25ac <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2598:	e0 91 2a 05 	lds	r30, 0x052A
    259c:	f0 91 2b 05 	lds	r31, 0x052B
    25a0:	96 89       	ldd	r25, Z+22	; 0x16
    25a2:	8e 85       	ldd	r24, Y+14	; 0x0e
    25a4:	98 17       	cp	r25, r24
    25a6:	10 f4       	brcc	.+4      	; 0x25ac <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    25a8:	0e 94 48 0c 	call	0x1890	; 0x1890 <vPortYield>
			}
		}
	}

	return xReturn;
    25ac:	8d 81       	ldd	r24, Y+5	; 0x05
}
    25ae:	64 96       	adiw	r28, 0x14	; 20
    25b0:	0f b6       	in	r0, 0x3f	; 63
    25b2:	f8 94       	cli
    25b4:	de bf       	out	0x3e, r29	; 62
    25b6:	0f be       	out	0x3f, r0	; 63
    25b8:	cd bf       	out	0x3d, r28	; 61
    25ba:	cf 91       	pop	r28
    25bc:	df 91       	pop	r29
    25be:	1f 91       	pop	r17
    25c0:	0f 91       	pop	r16
    25c2:	ff 90       	pop	r15
    25c4:	ef 90       	pop	r14
    25c6:	df 90       	pop	r13
    25c8:	cf 90       	pop	r12
    25ca:	bf 90       	pop	r11
    25cc:	af 90       	pop	r10
    25ce:	08 95       	ret

000025d0 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    25d0:	df 93       	push	r29
    25d2:	cf 93       	push	r28
    25d4:	00 d0       	rcall	.+0      	; 0x25d6 <vTaskDelete+0x6>
    25d6:	00 d0       	rcall	.+0      	; 0x25d8 <vTaskDelete+0x8>
    25d8:	00 d0       	rcall	.+0      	; 0x25da <vTaskDelete+0xa>
    25da:	cd b7       	in	r28, 0x3d	; 61
    25dc:	de b7       	in	r29, 0x3e	; 62
    25de:	9c 83       	std	Y+4, r25	; 0x04
    25e0:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    25e2:	0f b6       	in	r0, 0x3f	; 63
    25e4:	f8 94       	cli
    25e6:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    25e8:	20 91 2a 05 	lds	r18, 0x052A
    25ec:	30 91 2b 05 	lds	r19, 0x052B
    25f0:	8b 81       	ldd	r24, Y+3	; 0x03
    25f2:	9c 81       	ldd	r25, Y+4	; 0x04
    25f4:	82 17       	cp	r24, r18
    25f6:	93 07       	cpc	r25, r19
    25f8:	11 f4       	brne	.+4      	; 0x25fe <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    25fa:	1c 82       	std	Y+4, r1	; 0x04
    25fc:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    25fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2600:	9c 81       	ldd	r25, Y+4	; 0x04
    2602:	00 97       	sbiw	r24, 0x00	; 0
    2604:	39 f4       	brne	.+14     	; 0x2614 <vTaskDelete+0x44>
    2606:	80 91 2a 05 	lds	r24, 0x052A
    260a:	90 91 2b 05 	lds	r25, 0x052B
    260e:	9e 83       	std	Y+6, r25	; 0x06
    2610:	8d 83       	std	Y+5, r24	; 0x05
    2612:	04 c0       	rjmp	.+8      	; 0x261c <vTaskDelete+0x4c>
    2614:	8b 81       	ldd	r24, Y+3	; 0x03
    2616:	9c 81       	ldd	r25, Y+4	; 0x04
    2618:	9e 83       	std	Y+6, r25	; 0x06
    261a:	8d 83       	std	Y+5, r24	; 0x05
    261c:	8d 81       	ldd	r24, Y+5	; 0x05
    261e:	9e 81       	ldd	r25, Y+6	; 0x06
    2620:	9a 83       	std	Y+2, r25	; 0x02
    2622:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2624:	89 81       	ldd	r24, Y+1	; 0x01
    2626:	9a 81       	ldd	r25, Y+2	; 0x02
    2628:	02 96       	adiw	r24, 0x02	; 2
    262a:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    262e:	e9 81       	ldd	r30, Y+1	; 0x01
    2630:	fa 81       	ldd	r31, Y+2	; 0x02
    2632:	84 89       	ldd	r24, Z+20	; 0x14
    2634:	95 89       	ldd	r25, Z+21	; 0x15
    2636:	00 97       	sbiw	r24, 0x00	; 0
    2638:	29 f0       	breq	.+10     	; 0x2644 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    263a:	89 81       	ldd	r24, Y+1	; 0x01
    263c:	9a 81       	ldd	r25, Y+2	; 0x02
    263e:	0c 96       	adiw	r24, 0x0c	; 12
    2640:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2644:	89 81       	ldd	r24, Y+1	; 0x01
    2646:	9a 81       	ldd	r25, Y+2	; 0x02
    2648:	9c 01       	movw	r18, r24
    264a:	2e 5f       	subi	r18, 0xFE	; 254
    264c:	3f 4f       	sbci	r19, 0xFF	; 255
    264e:	8b e7       	ldi	r24, 0x7B	; 123
    2650:	95 e0       	ldi	r25, 0x05	; 5
    2652:	b9 01       	movw	r22, r18
    2654:	0e 94 88 09 	call	0x1310	; 0x1310 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    2658:	80 91 2c 05 	lds	r24, 0x052C
    265c:	8f 5f       	subi	r24, 0xFF	; 255
    265e:	80 93 2c 05 	sts	0x052C, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    2662:	80 91 37 05 	lds	r24, 0x0537
    2666:	8f 5f       	subi	r24, 0xFF	; 255
    2668:	80 93 37 05 	sts	0x0537, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    266c:	0f 90       	pop	r0
    266e:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    2670:	80 91 32 05 	lds	r24, 0x0532
    2674:	88 23       	and	r24, r24
    2676:	31 f0       	breq	.+12     	; 0x2684 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    2678:	8b 81       	ldd	r24, Y+3	; 0x03
    267a:	9c 81       	ldd	r25, Y+4	; 0x04
    267c:	00 97       	sbiw	r24, 0x00	; 0
    267e:	11 f4       	brne	.+4      	; 0x2684 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    2680:	0e 94 48 0c 	call	0x1890	; 0x1890 <vPortYield>
			}
		}
	}
    2684:	26 96       	adiw	r28, 0x06	; 6
    2686:	0f b6       	in	r0, 0x3f	; 63
    2688:	f8 94       	cli
    268a:	de bf       	out	0x3e, r29	; 62
    268c:	0f be       	out	0x3f, r0	; 63
    268e:	cd bf       	out	0x3d, r28	; 61
    2690:	cf 91       	pop	r28
    2692:	df 91       	pop	r29
    2694:	08 95       	ret

00002696 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2696:	df 93       	push	r29
    2698:	cf 93       	push	r28
    269a:	cd b7       	in	r28, 0x3d	; 61
    269c:	de b7       	in	r29, 0x3e	; 62
    269e:	28 97       	sbiw	r28, 0x08	; 8
    26a0:	0f b6       	in	r0, 0x3f	; 63
    26a2:	f8 94       	cli
    26a4:	de bf       	out	0x3e, r29	; 62
    26a6:	0f be       	out	0x3f, r0	; 63
    26a8:	cd bf       	out	0x3d, r28	; 61
    26aa:	9e 83       	std	Y+6, r25	; 0x06
    26ac:	8d 83       	std	Y+5, r24	; 0x05
    26ae:	78 87       	std	Y+8, r23	; 0x08
    26b0:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    26b2:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    26b4:	0e 94 37 14 	call	0x286e	; 0x286e <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    26b8:	ed 81       	ldd	r30, Y+5	; 0x05
    26ba:	fe 81       	ldd	r31, Y+6	; 0x06
    26bc:	20 81       	ld	r18, Z
    26be:	31 81       	ldd	r19, Z+1	; 0x01
    26c0:	8f 81       	ldd	r24, Y+7	; 0x07
    26c2:	98 85       	ldd	r25, Y+8	; 0x08
    26c4:	82 0f       	add	r24, r18
    26c6:	93 1f       	adc	r25, r19
    26c8:	9c 83       	std	Y+4, r25	; 0x04
    26ca:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    26cc:	ed 81       	ldd	r30, Y+5	; 0x05
    26ce:	fe 81       	ldd	r31, Y+6	; 0x06
    26d0:	20 81       	ld	r18, Z
    26d2:	31 81       	ldd	r19, Z+1	; 0x01
    26d4:	80 91 2e 05 	lds	r24, 0x052E
    26d8:	90 91 2f 05 	lds	r25, 0x052F
    26dc:	82 17       	cp	r24, r18
    26de:	93 07       	cpc	r25, r19
    26e0:	a8 f4       	brcc	.+42     	; 0x270c <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    26e2:	ed 81       	ldd	r30, Y+5	; 0x05
    26e4:	fe 81       	ldd	r31, Y+6	; 0x06
    26e6:	20 81       	ld	r18, Z
    26e8:	31 81       	ldd	r19, Z+1	; 0x01
    26ea:	8b 81       	ldd	r24, Y+3	; 0x03
    26ec:	9c 81       	ldd	r25, Y+4	; 0x04
    26ee:	82 17       	cp	r24, r18
    26f0:	93 07       	cpc	r25, r19
    26f2:	00 f5       	brcc	.+64     	; 0x2734 <vTaskDelayUntil+0x9e>
    26f4:	20 91 2e 05 	lds	r18, 0x052E
    26f8:	30 91 2f 05 	lds	r19, 0x052F
    26fc:	8b 81       	ldd	r24, Y+3	; 0x03
    26fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2700:	28 17       	cp	r18, r24
    2702:	39 07       	cpc	r19, r25
    2704:	b8 f4       	brcc	.+46     	; 0x2734 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2706:	81 e0       	ldi	r24, 0x01	; 1
    2708:	89 83       	std	Y+1, r24	; 0x01
    270a:	14 c0       	rjmp	.+40     	; 0x2734 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    270c:	ed 81       	ldd	r30, Y+5	; 0x05
    270e:	fe 81       	ldd	r31, Y+6	; 0x06
    2710:	20 81       	ld	r18, Z
    2712:	31 81       	ldd	r19, Z+1	; 0x01
    2714:	8b 81       	ldd	r24, Y+3	; 0x03
    2716:	9c 81       	ldd	r25, Y+4	; 0x04
    2718:	82 17       	cp	r24, r18
    271a:	93 07       	cpc	r25, r19
    271c:	48 f0       	brcs	.+18     	; 0x2730 <vTaskDelayUntil+0x9a>
    271e:	20 91 2e 05 	lds	r18, 0x052E
    2722:	30 91 2f 05 	lds	r19, 0x052F
    2726:	8b 81       	ldd	r24, Y+3	; 0x03
    2728:	9c 81       	ldd	r25, Y+4	; 0x04
    272a:	28 17       	cp	r18, r24
    272c:	39 07       	cpc	r19, r25
    272e:	10 f4       	brcc	.+4      	; 0x2734 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2730:	81 e0       	ldi	r24, 0x01	; 1
    2732:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2734:	ed 81       	ldd	r30, Y+5	; 0x05
    2736:	fe 81       	ldd	r31, Y+6	; 0x06
    2738:	8b 81       	ldd	r24, Y+3	; 0x03
    273a:	9c 81       	ldd	r25, Y+4	; 0x04
    273c:	91 83       	std	Z+1, r25	; 0x01
    273e:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2740:	89 81       	ldd	r24, Y+1	; 0x01
    2742:	88 23       	and	r24, r24
    2744:	59 f0       	breq	.+22     	; 0x275c <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2746:	80 91 2a 05 	lds	r24, 0x052A
    274a:	90 91 2b 05 	lds	r25, 0x052B
    274e:	02 96       	adiw	r24, 0x02	; 2
    2750:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2754:	8b 81       	ldd	r24, Y+3	; 0x03
    2756:	9c 81       	ldd	r25, Y+4	; 0x04
    2758:	0e 94 37 18 	call	0x306e	; 0x306e <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    275c:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskResumeAll>
    2760:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2762:	8a 81       	ldd	r24, Y+2	; 0x02
    2764:	88 23       	and	r24, r24
    2766:	11 f4       	brne	.+4      	; 0x276c <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    2768:	0e 94 48 0c 	call	0x1890	; 0x1890 <vPortYield>
		}
	}
    276c:	28 96       	adiw	r28, 0x08	; 8
    276e:	0f b6       	in	r0, 0x3f	; 63
    2770:	f8 94       	cli
    2772:	de bf       	out	0x3e, r29	; 62
    2774:	0f be       	out	0x3f, r0	; 63
    2776:	cd bf       	out	0x3d, r28	; 61
    2778:	cf 91       	pop	r28
    277a:	df 91       	pop	r29
    277c:	08 95       	ret

0000277e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    277e:	df 93       	push	r29
    2780:	cf 93       	push	r28
    2782:	00 d0       	rcall	.+0      	; 0x2784 <vTaskDelay+0x6>
    2784:	00 d0       	rcall	.+0      	; 0x2786 <vTaskDelay+0x8>
    2786:	0f 92       	push	r0
    2788:	cd b7       	in	r28, 0x3d	; 61
    278a:	de b7       	in	r29, 0x3e	; 62
    278c:	9d 83       	std	Y+5, r25	; 0x05
    278e:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2790:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2792:	8c 81       	ldd	r24, Y+4	; 0x04
    2794:	9d 81       	ldd	r25, Y+5	; 0x05
    2796:	00 97       	sbiw	r24, 0x00	; 0
    2798:	d1 f0       	breq	.+52     	; 0x27ce <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    279a:	0e 94 37 14 	call	0x286e	; 0x286e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    279e:	20 91 2e 05 	lds	r18, 0x052E
    27a2:	30 91 2f 05 	lds	r19, 0x052F
    27a6:	8c 81       	ldd	r24, Y+4	; 0x04
    27a8:	9d 81       	ldd	r25, Y+5	; 0x05
    27aa:	82 0f       	add	r24, r18
    27ac:	93 1f       	adc	r25, r19
    27ae:	9b 83       	std	Y+3, r25	; 0x03
    27b0:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    27b2:	80 91 2a 05 	lds	r24, 0x052A
    27b6:	90 91 2b 05 	lds	r25, 0x052B
    27ba:	02 96       	adiw	r24, 0x02	; 2
    27bc:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    27c0:	8a 81       	ldd	r24, Y+2	; 0x02
    27c2:	9b 81       	ldd	r25, Y+3	; 0x03
    27c4:	0e 94 37 18 	call	0x306e	; 0x306e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    27c8:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskResumeAll>
    27cc:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    27ce:	89 81       	ldd	r24, Y+1	; 0x01
    27d0:	88 23       	and	r24, r24
    27d2:	11 f4       	brne	.+4      	; 0x27d8 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    27d4:	0e 94 48 0c 	call	0x1890	; 0x1890 <vPortYield>
		}
	}
    27d8:	0f 90       	pop	r0
    27da:	0f 90       	pop	r0
    27dc:	0f 90       	pop	r0
    27de:	0f 90       	pop	r0
    27e0:	0f 90       	pop	r0
    27e2:	cf 91       	pop	r28
    27e4:	df 91       	pop	r29
    27e6:	08 95       	ret

000027e8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    27e8:	af 92       	push	r10
    27ea:	bf 92       	push	r11
    27ec:	cf 92       	push	r12
    27ee:	df 92       	push	r13
    27f0:	ef 92       	push	r14
    27f2:	ff 92       	push	r15
    27f4:	0f 93       	push	r16
    27f6:	df 93       	push	r29
    27f8:	cf 93       	push	r28
    27fa:	0f 92       	push	r0
    27fc:	cd b7       	in	r28, 0x3d	; 61
    27fe:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2800:	20 e6       	ldi	r18, 0x60	; 96
    2802:	30 e0       	ldi	r19, 0x00	; 0
    2804:	8b e5       	ldi	r24, 0x5B	; 91
    2806:	97 e1       	ldi	r25, 0x17	; 23
    2808:	b9 01       	movw	r22, r18
    280a:	45 e5       	ldi	r20, 0x55	; 85
    280c:	50 e0       	ldi	r21, 0x00	; 0
    280e:	20 e0       	ldi	r18, 0x00	; 0
    2810:	30 e0       	ldi	r19, 0x00	; 0
    2812:	00 e0       	ldi	r16, 0x00	; 0
    2814:	ee 24       	eor	r14, r14
    2816:	ff 24       	eor	r15, r15
    2818:	cc 24       	eor	r12, r12
    281a:	dd 24       	eor	r13, r13
    281c:	aa 24       	eor	r10, r10
    281e:	bb 24       	eor	r11, r11
    2820:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <xTaskGenericCreate>
    2824:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2826:	89 81       	ldd	r24, Y+1	; 0x01
    2828:	81 30       	cpi	r24, 0x01	; 1
    282a:	51 f4       	brne	.+20     	; 0x2840 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    282c:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    282e:	81 e0       	ldi	r24, 0x01	; 1
    2830:	80 93 32 05 	sts	0x0532, r24
		xTickCount = ( portTickType ) 0U;
    2834:	10 92 2f 05 	sts	0x052F, r1
    2838:	10 92 2e 05 	sts	0x052E, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    283c:	0e 94 0c 0c 	call	0x1818	; 0x1818 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2840:	0f 90       	pop	r0
    2842:	cf 91       	pop	r28
    2844:	df 91       	pop	r29
    2846:	0f 91       	pop	r16
    2848:	ff 90       	pop	r15
    284a:	ef 90       	pop	r14
    284c:	df 90       	pop	r13
    284e:	cf 90       	pop	r12
    2850:	bf 90       	pop	r11
    2852:	af 90       	pop	r10
    2854:	08 95       	ret

00002856 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2856:	df 93       	push	r29
    2858:	cf 93       	push	r28
    285a:	cd b7       	in	r28, 0x3d	; 61
    285c:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    285e:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2860:	10 92 32 05 	sts	0x0532, r1
	vPortEndScheduler();
    2864:	0e 94 41 0c 	call	0x1882	; 0x1882 <vPortEndScheduler>
}
    2868:	cf 91       	pop	r28
    286a:	df 91       	pop	r29
    286c:	08 95       	ret

0000286e <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    286e:	df 93       	push	r29
    2870:	cf 93       	push	r28
    2872:	cd b7       	in	r28, 0x3d	; 61
    2874:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2876:	80 91 33 05 	lds	r24, 0x0533
    287a:	8f 5f       	subi	r24, 0xFF	; 255
    287c:	80 93 33 05 	sts	0x0533, r24
}
    2880:	cf 91       	pop	r28
    2882:	df 91       	pop	r29
    2884:	08 95       	ret

00002886 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2886:	df 93       	push	r29
    2888:	cf 93       	push	r28
    288a:	00 d0       	rcall	.+0      	; 0x288c <xTaskResumeAll+0x6>
    288c:	00 d0       	rcall	.+0      	; 0x288e <xTaskResumeAll+0x8>
    288e:	cd b7       	in	r28, 0x3d	; 61
    2890:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2892:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2894:	0f b6       	in	r0, 0x3f	; 63
    2896:	f8 94       	cli
    2898:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    289a:	80 91 33 05 	lds	r24, 0x0533
    289e:	81 50       	subi	r24, 0x01	; 1
    28a0:	80 93 33 05 	sts	0x0533, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    28a4:	80 91 33 05 	lds	r24, 0x0533
    28a8:	88 23       	and	r24, r24
    28aa:	09 f0       	breq	.+2      	; 0x28ae <xTaskResumeAll+0x28>
    28ac:	6c c0       	rjmp	.+216    	; 0x2986 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    28ae:	80 91 2d 05 	lds	r24, 0x052D
    28b2:	88 23       	and	r24, r24
    28b4:	09 f4       	brne	.+2      	; 0x28b8 <xTaskResumeAll+0x32>
    28b6:	67 c0       	rjmp	.+206    	; 0x2986 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    28b8:	19 82       	std	Y+1, r1	; 0x01
    28ba:	41 c0       	rjmp	.+130    	; 0x293e <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    28bc:	e0 91 77 05 	lds	r30, 0x0577
    28c0:	f0 91 78 05 	lds	r31, 0x0578
    28c4:	86 81       	ldd	r24, Z+6	; 0x06
    28c6:	97 81       	ldd	r25, Z+7	; 0x07
    28c8:	9c 83       	std	Y+4, r25	; 0x04
    28ca:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    28cc:	8b 81       	ldd	r24, Y+3	; 0x03
    28ce:	9c 81       	ldd	r25, Y+4	; 0x04
    28d0:	0c 96       	adiw	r24, 0x0c	; 12
    28d2:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    28d6:	8b 81       	ldd	r24, Y+3	; 0x03
    28d8:	9c 81       	ldd	r25, Y+4	; 0x04
    28da:	02 96       	adiw	r24, 0x02	; 2
    28dc:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    28e0:	eb 81       	ldd	r30, Y+3	; 0x03
    28e2:	fc 81       	ldd	r31, Y+4	; 0x04
    28e4:	96 89       	ldd	r25, Z+22	; 0x16
    28e6:	80 91 31 05 	lds	r24, 0x0531
    28ea:	89 17       	cp	r24, r25
    28ec:	28 f4       	brcc	.+10     	; 0x28f8 <xTaskResumeAll+0x72>
    28ee:	eb 81       	ldd	r30, Y+3	; 0x03
    28f0:	fc 81       	ldd	r31, Y+4	; 0x04
    28f2:	86 89       	ldd	r24, Z+22	; 0x16
    28f4:	80 93 31 05 	sts	0x0531, r24
    28f8:	eb 81       	ldd	r30, Y+3	; 0x03
    28fa:	fc 81       	ldd	r31, Y+4	; 0x04
    28fc:	86 89       	ldd	r24, Z+22	; 0x16
    28fe:	28 2f       	mov	r18, r24
    2900:	30 e0       	ldi	r19, 0x00	; 0
    2902:	c9 01       	movw	r24, r18
    2904:	88 0f       	add	r24, r24
    2906:	99 1f       	adc	r25, r25
    2908:	88 0f       	add	r24, r24
    290a:	99 1f       	adc	r25, r25
    290c:	88 0f       	add	r24, r24
    290e:	99 1f       	adc	r25, r25
    2910:	82 0f       	add	r24, r18
    2912:	93 1f       	adc	r25, r19
    2914:	88 5c       	subi	r24, 0xC8	; 200
    2916:	9a 4f       	sbci	r25, 0xFA	; 250
    2918:	2b 81       	ldd	r18, Y+3	; 0x03
    291a:	3c 81       	ldd	r19, Y+4	; 0x04
    291c:	2e 5f       	subi	r18, 0xFE	; 254
    291e:	3f 4f       	sbci	r19, 0xFF	; 255
    2920:	b9 01       	movw	r22, r18
    2922:	0e 94 88 09 	call	0x1310	; 0x1310 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2926:	eb 81       	ldd	r30, Y+3	; 0x03
    2928:	fc 81       	ldd	r31, Y+4	; 0x04
    292a:	96 89       	ldd	r25, Z+22	; 0x16
    292c:	e0 91 2a 05 	lds	r30, 0x052A
    2930:	f0 91 2b 05 	lds	r31, 0x052B
    2934:	86 89       	ldd	r24, Z+22	; 0x16
    2936:	98 17       	cp	r25, r24
    2938:	10 f0       	brcs	.+4      	; 0x293e <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    293a:	81 e0       	ldi	r24, 0x01	; 1
    293c:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    293e:	80 91 72 05 	lds	r24, 0x0572
    2942:	88 23       	and	r24, r24
    2944:	09 f0       	breq	.+2      	; 0x2948 <xTaskResumeAll+0xc2>
    2946:	ba cf       	rjmp	.-140    	; 0x28bc <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2948:	80 91 34 05 	lds	r24, 0x0534
    294c:	88 23       	and	r24, r24
    294e:	71 f0       	breq	.+28     	; 0x296c <xTaskResumeAll+0xe6>
    2950:	07 c0       	rjmp	.+14     	; 0x2960 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    2952:	0e 94 02 15 	call	0x2a04	; 0x2a04 <vTaskIncrementTick>
						--uxMissedTicks;
    2956:	80 91 34 05 	lds	r24, 0x0534
    295a:	81 50       	subi	r24, 0x01	; 1
    295c:	80 93 34 05 	sts	0x0534, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2960:	80 91 34 05 	lds	r24, 0x0534
    2964:	88 23       	and	r24, r24
    2966:	a9 f7       	brne	.-22     	; 0x2952 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    2968:	81 e0       	ldi	r24, 0x01	; 1
    296a:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    296c:	89 81       	ldd	r24, Y+1	; 0x01
    296e:	81 30       	cpi	r24, 0x01	; 1
    2970:	21 f0       	breq	.+8      	; 0x297a <xTaskResumeAll+0xf4>
    2972:	80 91 35 05 	lds	r24, 0x0535
    2976:	81 30       	cpi	r24, 0x01	; 1
    2978:	31 f4       	brne	.+12     	; 0x2986 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    297a:	81 e0       	ldi	r24, 0x01	; 1
    297c:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    297e:	10 92 35 05 	sts	0x0535, r1
					portYIELD_WITHIN_API();
    2982:	0e 94 48 0c 	call	0x1890	; 0x1890 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2986:	0f 90       	pop	r0
    2988:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    298a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    298c:	0f 90       	pop	r0
    298e:	0f 90       	pop	r0
    2990:	0f 90       	pop	r0
    2992:	0f 90       	pop	r0
    2994:	cf 91       	pop	r28
    2996:	df 91       	pop	r29
    2998:	08 95       	ret

0000299a <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    299a:	df 93       	push	r29
    299c:	cf 93       	push	r28
    299e:	00 d0       	rcall	.+0      	; 0x29a0 <xTaskGetTickCount+0x6>
    29a0:	cd b7       	in	r28, 0x3d	; 61
    29a2:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    29a4:	0f b6       	in	r0, 0x3f	; 63
    29a6:	f8 94       	cli
    29a8:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    29aa:	80 91 2e 05 	lds	r24, 0x052E
    29ae:	90 91 2f 05 	lds	r25, 0x052F
    29b2:	9a 83       	std	Y+2, r25	; 0x02
    29b4:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    29b6:	0f 90       	pop	r0
    29b8:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    29ba:	89 81       	ldd	r24, Y+1	; 0x01
    29bc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    29be:	0f 90       	pop	r0
    29c0:	0f 90       	pop	r0
    29c2:	cf 91       	pop	r28
    29c4:	df 91       	pop	r29
    29c6:	08 95       	ret

000029c8 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    29c8:	df 93       	push	r29
    29ca:	cf 93       	push	r28
    29cc:	00 d0       	rcall	.+0      	; 0x29ce <xTaskGetTickCountFromISR+0x6>
    29ce:	0f 92       	push	r0
    29d0:	cd b7       	in	r28, 0x3d	; 61
    29d2:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    29d4:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    29d6:	80 91 2e 05 	lds	r24, 0x052E
    29da:	90 91 2f 05 	lds	r25, 0x052F
    29de:	9b 83       	std	Y+3, r25	; 0x03
    29e0:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    29e2:	8a 81       	ldd	r24, Y+2	; 0x02
    29e4:	9b 81       	ldd	r25, Y+3	; 0x03
}
    29e6:	0f 90       	pop	r0
    29e8:	0f 90       	pop	r0
    29ea:	0f 90       	pop	r0
    29ec:	cf 91       	pop	r28
    29ee:	df 91       	pop	r29
    29f0:	08 95       	ret

000029f2 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    29f2:	df 93       	push	r29
    29f4:	cf 93       	push	r28
    29f6:	cd b7       	in	r28, 0x3d	; 61
    29f8:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    29fa:	80 91 2d 05 	lds	r24, 0x052D
}
    29fe:	cf 91       	pop	r28
    2a00:	df 91       	pop	r29
    2a02:	08 95       	ret

00002a04 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2a04:	df 93       	push	r29
    2a06:	cf 93       	push	r28
    2a08:	00 d0       	rcall	.+0      	; 0x2a0a <vTaskIncrementTick+0x6>
    2a0a:	00 d0       	rcall	.+0      	; 0x2a0c <vTaskIncrementTick+0x8>
    2a0c:	00 d0       	rcall	.+0      	; 0x2a0e <vTaskIncrementTick+0xa>
    2a0e:	cd b7       	in	r28, 0x3d	; 61
    2a10:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2a12:	80 91 33 05 	lds	r24, 0x0533
    2a16:	88 23       	and	r24, r24
    2a18:	09 f0       	breq	.+2      	; 0x2a1c <vTaskIncrementTick+0x18>
    2a1a:	bb c0       	rjmp	.+374    	; 0x2b92 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    2a1c:	80 91 2e 05 	lds	r24, 0x052E
    2a20:	90 91 2f 05 	lds	r25, 0x052F
    2a24:	01 96       	adiw	r24, 0x01	; 1
    2a26:	90 93 2f 05 	sts	0x052F, r25
    2a2a:	80 93 2e 05 	sts	0x052E, r24
		if( xTickCount == ( portTickType ) 0U )
    2a2e:	80 91 2e 05 	lds	r24, 0x052E
    2a32:	90 91 2f 05 	lds	r25, 0x052F
    2a36:	00 97       	sbiw	r24, 0x00	; 0
    2a38:	d1 f5       	brne	.+116    	; 0x2aae <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2a3a:	80 91 6e 05 	lds	r24, 0x056E
    2a3e:	90 91 6f 05 	lds	r25, 0x056F
    2a42:	9c 83       	std	Y+4, r25	; 0x04
    2a44:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2a46:	80 91 70 05 	lds	r24, 0x0570
    2a4a:	90 91 71 05 	lds	r25, 0x0571
    2a4e:	90 93 6f 05 	sts	0x056F, r25
    2a52:	80 93 6e 05 	sts	0x056E, r24
			pxOverflowDelayedTaskList = pxTemp;
    2a56:	8b 81       	ldd	r24, Y+3	; 0x03
    2a58:	9c 81       	ldd	r25, Y+4	; 0x04
    2a5a:	90 93 71 05 	sts	0x0571, r25
    2a5e:	80 93 70 05 	sts	0x0570, r24
			xNumOfOverflows++;
    2a62:	80 91 36 05 	lds	r24, 0x0536
    2a66:	8f 5f       	subi	r24, 0xFF	; 255
    2a68:	80 93 36 05 	sts	0x0536, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2a6c:	e0 91 6e 05 	lds	r30, 0x056E
    2a70:	f0 91 6f 05 	lds	r31, 0x056F
    2a74:	80 81       	ld	r24, Z
    2a76:	88 23       	and	r24, r24
    2a78:	39 f4       	brne	.+14     	; 0x2a88 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2a7a:	8f ef       	ldi	r24, 0xFF	; 255
    2a7c:	9f ef       	ldi	r25, 0xFF	; 255
    2a7e:	90 93 6e 00 	sts	0x006E, r25
    2a82:	80 93 6d 00 	sts	0x006D, r24
    2a86:	13 c0       	rjmp	.+38     	; 0x2aae <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2a88:	e0 91 6e 05 	lds	r30, 0x056E
    2a8c:	f0 91 6f 05 	lds	r31, 0x056F
    2a90:	05 80       	ldd	r0, Z+5	; 0x05
    2a92:	f6 81       	ldd	r31, Z+6	; 0x06
    2a94:	e0 2d       	mov	r30, r0
    2a96:	86 81       	ldd	r24, Z+6	; 0x06
    2a98:	97 81       	ldd	r25, Z+7	; 0x07
    2a9a:	9e 83       	std	Y+6, r25	; 0x06
    2a9c:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2a9e:	ed 81       	ldd	r30, Y+5	; 0x05
    2aa0:	fe 81       	ldd	r31, Y+6	; 0x06
    2aa2:	82 81       	ldd	r24, Z+2	; 0x02
    2aa4:	93 81       	ldd	r25, Z+3	; 0x03
    2aa6:	90 93 6e 00 	sts	0x006E, r25
    2aaa:	80 93 6d 00 	sts	0x006D, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2aae:	20 91 2e 05 	lds	r18, 0x052E
    2ab2:	30 91 2f 05 	lds	r19, 0x052F
    2ab6:	80 91 6d 00 	lds	r24, 0x006D
    2aba:	90 91 6e 00 	lds	r25, 0x006E
    2abe:	28 17       	cp	r18, r24
    2ac0:	39 07       	cpc	r19, r25
    2ac2:	08 f4       	brcc	.+2      	; 0x2ac6 <vTaskIncrementTick+0xc2>
    2ac4:	6b c0       	rjmp	.+214    	; 0x2b9c <vTaskIncrementTick+0x198>
    2ac6:	e0 91 6e 05 	lds	r30, 0x056E
    2aca:	f0 91 6f 05 	lds	r31, 0x056F
    2ace:	80 81       	ld	r24, Z
    2ad0:	88 23       	and	r24, r24
    2ad2:	39 f4       	brne	.+14     	; 0x2ae2 <vTaskIncrementTick+0xde>
    2ad4:	8f ef       	ldi	r24, 0xFF	; 255
    2ad6:	9f ef       	ldi	r25, 0xFF	; 255
    2ad8:	90 93 6e 00 	sts	0x006E, r25
    2adc:	80 93 6d 00 	sts	0x006D, r24
    2ae0:	5d c0       	rjmp	.+186    	; 0x2b9c <vTaskIncrementTick+0x198>
    2ae2:	e0 91 6e 05 	lds	r30, 0x056E
    2ae6:	f0 91 6f 05 	lds	r31, 0x056F
    2aea:	05 80       	ldd	r0, Z+5	; 0x05
    2aec:	f6 81       	ldd	r31, Z+6	; 0x06
    2aee:	e0 2d       	mov	r30, r0
    2af0:	86 81       	ldd	r24, Z+6	; 0x06
    2af2:	97 81       	ldd	r25, Z+7	; 0x07
    2af4:	9e 83       	std	Y+6, r25	; 0x06
    2af6:	8d 83       	std	Y+5, r24	; 0x05
    2af8:	ed 81       	ldd	r30, Y+5	; 0x05
    2afa:	fe 81       	ldd	r31, Y+6	; 0x06
    2afc:	82 81       	ldd	r24, Z+2	; 0x02
    2afe:	93 81       	ldd	r25, Z+3	; 0x03
    2b00:	9a 83       	std	Y+2, r25	; 0x02
    2b02:	89 83       	std	Y+1, r24	; 0x01
    2b04:	20 91 2e 05 	lds	r18, 0x052E
    2b08:	30 91 2f 05 	lds	r19, 0x052F
    2b0c:	89 81       	ldd	r24, Y+1	; 0x01
    2b0e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b10:	28 17       	cp	r18, r24
    2b12:	39 07       	cpc	r19, r25
    2b14:	38 f4       	brcc	.+14     	; 0x2b24 <vTaskIncrementTick+0x120>
    2b16:	89 81       	ldd	r24, Y+1	; 0x01
    2b18:	9a 81       	ldd	r25, Y+2	; 0x02
    2b1a:	90 93 6e 00 	sts	0x006E, r25
    2b1e:	80 93 6d 00 	sts	0x006D, r24
    2b22:	3c c0       	rjmp	.+120    	; 0x2b9c <vTaskIncrementTick+0x198>
    2b24:	8d 81       	ldd	r24, Y+5	; 0x05
    2b26:	9e 81       	ldd	r25, Y+6	; 0x06
    2b28:	02 96       	adiw	r24, 0x02	; 2
    2b2a:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>
    2b2e:	ed 81       	ldd	r30, Y+5	; 0x05
    2b30:	fe 81       	ldd	r31, Y+6	; 0x06
    2b32:	84 89       	ldd	r24, Z+20	; 0x14
    2b34:	95 89       	ldd	r25, Z+21	; 0x15
    2b36:	00 97       	sbiw	r24, 0x00	; 0
    2b38:	29 f0       	breq	.+10     	; 0x2b44 <vTaskIncrementTick+0x140>
    2b3a:	8d 81       	ldd	r24, Y+5	; 0x05
    2b3c:	9e 81       	ldd	r25, Y+6	; 0x06
    2b3e:	0c 96       	adiw	r24, 0x0c	; 12
    2b40:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>
    2b44:	ed 81       	ldd	r30, Y+5	; 0x05
    2b46:	fe 81       	ldd	r31, Y+6	; 0x06
    2b48:	96 89       	ldd	r25, Z+22	; 0x16
    2b4a:	80 91 31 05 	lds	r24, 0x0531
    2b4e:	89 17       	cp	r24, r25
    2b50:	28 f4       	brcc	.+10     	; 0x2b5c <vTaskIncrementTick+0x158>
    2b52:	ed 81       	ldd	r30, Y+5	; 0x05
    2b54:	fe 81       	ldd	r31, Y+6	; 0x06
    2b56:	86 89       	ldd	r24, Z+22	; 0x16
    2b58:	80 93 31 05 	sts	0x0531, r24
    2b5c:	ed 81       	ldd	r30, Y+5	; 0x05
    2b5e:	fe 81       	ldd	r31, Y+6	; 0x06
    2b60:	86 89       	ldd	r24, Z+22	; 0x16
    2b62:	28 2f       	mov	r18, r24
    2b64:	30 e0       	ldi	r19, 0x00	; 0
    2b66:	c9 01       	movw	r24, r18
    2b68:	88 0f       	add	r24, r24
    2b6a:	99 1f       	adc	r25, r25
    2b6c:	88 0f       	add	r24, r24
    2b6e:	99 1f       	adc	r25, r25
    2b70:	88 0f       	add	r24, r24
    2b72:	99 1f       	adc	r25, r25
    2b74:	82 0f       	add	r24, r18
    2b76:	93 1f       	adc	r25, r19
    2b78:	ac 01       	movw	r20, r24
    2b7a:	48 5c       	subi	r20, 0xC8	; 200
    2b7c:	5a 4f       	sbci	r21, 0xFA	; 250
    2b7e:	8d 81       	ldd	r24, Y+5	; 0x05
    2b80:	9e 81       	ldd	r25, Y+6	; 0x06
    2b82:	9c 01       	movw	r18, r24
    2b84:	2e 5f       	subi	r18, 0xFE	; 254
    2b86:	3f 4f       	sbci	r19, 0xFF	; 255
    2b88:	ca 01       	movw	r24, r20
    2b8a:	b9 01       	movw	r22, r18
    2b8c:	0e 94 88 09 	call	0x1310	; 0x1310 <vListInsertEnd>
    2b90:	9a cf       	rjmp	.-204    	; 0x2ac6 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2b92:	80 91 34 05 	lds	r24, 0x0534
    2b96:	8f 5f       	subi	r24, 0xFF	; 255
    2b98:	80 93 34 05 	sts	0x0534, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2b9c:	26 96       	adiw	r28, 0x06	; 6
    2b9e:	0f b6       	in	r0, 0x3f	; 63
    2ba0:	f8 94       	cli
    2ba2:	de bf       	out	0x3e, r29	; 62
    2ba4:	0f be       	out	0x3f, r0	; 63
    2ba6:	cd bf       	out	0x3d, r28	; 61
    2ba8:	cf 91       	pop	r28
    2baa:	df 91       	pop	r29
    2bac:	08 95       	ret

00002bae <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2bae:	df 93       	push	r29
    2bb0:	cf 93       	push	r28
    2bb2:	00 d0       	rcall	.+0      	; 0x2bb4 <vTaskSwitchContext+0x6>
    2bb4:	cd b7       	in	r28, 0x3d	; 61
    2bb6:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2bb8:	80 91 33 05 	lds	r24, 0x0533
    2bbc:	88 23       	and	r24, r24
    2bbe:	49 f0       	breq	.+18     	; 0x2bd2 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2bc0:	81 e0       	ldi	r24, 0x01	; 1
    2bc2:	80 93 35 05 	sts	0x0535, r24
    2bc6:	54 c0       	rjmp	.+168    	; 0x2c70 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2bc8:	80 91 31 05 	lds	r24, 0x0531
    2bcc:	81 50       	subi	r24, 0x01	; 1
    2bce:	80 93 31 05 	sts	0x0531, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2bd2:	80 91 31 05 	lds	r24, 0x0531
    2bd6:	28 2f       	mov	r18, r24
    2bd8:	30 e0       	ldi	r19, 0x00	; 0
    2bda:	c9 01       	movw	r24, r18
    2bdc:	88 0f       	add	r24, r24
    2bde:	99 1f       	adc	r25, r25
    2be0:	88 0f       	add	r24, r24
    2be2:	99 1f       	adc	r25, r25
    2be4:	88 0f       	add	r24, r24
    2be6:	99 1f       	adc	r25, r25
    2be8:	82 0f       	add	r24, r18
    2bea:	93 1f       	adc	r25, r19
    2bec:	fc 01       	movw	r30, r24
    2bee:	e8 5c       	subi	r30, 0xC8	; 200
    2bf0:	fa 4f       	sbci	r31, 0xFA	; 250
    2bf2:	80 81       	ld	r24, Z
    2bf4:	88 23       	and	r24, r24
    2bf6:	41 f3       	breq	.-48     	; 0x2bc8 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2bf8:	80 91 31 05 	lds	r24, 0x0531
    2bfc:	28 2f       	mov	r18, r24
    2bfe:	30 e0       	ldi	r19, 0x00	; 0
    2c00:	c9 01       	movw	r24, r18
    2c02:	88 0f       	add	r24, r24
    2c04:	99 1f       	adc	r25, r25
    2c06:	88 0f       	add	r24, r24
    2c08:	99 1f       	adc	r25, r25
    2c0a:	88 0f       	add	r24, r24
    2c0c:	99 1f       	adc	r25, r25
    2c0e:	82 0f       	add	r24, r18
    2c10:	93 1f       	adc	r25, r19
    2c12:	88 5c       	subi	r24, 0xC8	; 200
    2c14:	9a 4f       	sbci	r25, 0xFA	; 250
    2c16:	9a 83       	std	Y+2, r25	; 0x02
    2c18:	89 83       	std	Y+1, r24	; 0x01
    2c1a:	e9 81       	ldd	r30, Y+1	; 0x01
    2c1c:	fa 81       	ldd	r31, Y+2	; 0x02
    2c1e:	01 80       	ldd	r0, Z+1	; 0x01
    2c20:	f2 81       	ldd	r31, Z+2	; 0x02
    2c22:	e0 2d       	mov	r30, r0
    2c24:	82 81       	ldd	r24, Z+2	; 0x02
    2c26:	93 81       	ldd	r25, Z+3	; 0x03
    2c28:	e9 81       	ldd	r30, Y+1	; 0x01
    2c2a:	fa 81       	ldd	r31, Y+2	; 0x02
    2c2c:	92 83       	std	Z+2, r25	; 0x02
    2c2e:	81 83       	std	Z+1, r24	; 0x01
    2c30:	e9 81       	ldd	r30, Y+1	; 0x01
    2c32:	fa 81       	ldd	r31, Y+2	; 0x02
    2c34:	21 81       	ldd	r18, Z+1	; 0x01
    2c36:	32 81       	ldd	r19, Z+2	; 0x02
    2c38:	89 81       	ldd	r24, Y+1	; 0x01
    2c3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c3c:	03 96       	adiw	r24, 0x03	; 3
    2c3e:	28 17       	cp	r18, r24
    2c40:	39 07       	cpc	r19, r25
    2c42:	59 f4       	brne	.+22     	; 0x2c5a <vTaskSwitchContext+0xac>
    2c44:	e9 81       	ldd	r30, Y+1	; 0x01
    2c46:	fa 81       	ldd	r31, Y+2	; 0x02
    2c48:	01 80       	ldd	r0, Z+1	; 0x01
    2c4a:	f2 81       	ldd	r31, Z+2	; 0x02
    2c4c:	e0 2d       	mov	r30, r0
    2c4e:	82 81       	ldd	r24, Z+2	; 0x02
    2c50:	93 81       	ldd	r25, Z+3	; 0x03
    2c52:	e9 81       	ldd	r30, Y+1	; 0x01
    2c54:	fa 81       	ldd	r31, Y+2	; 0x02
    2c56:	92 83       	std	Z+2, r25	; 0x02
    2c58:	81 83       	std	Z+1, r24	; 0x01
    2c5a:	e9 81       	ldd	r30, Y+1	; 0x01
    2c5c:	fa 81       	ldd	r31, Y+2	; 0x02
    2c5e:	01 80       	ldd	r0, Z+1	; 0x01
    2c60:	f2 81       	ldd	r31, Z+2	; 0x02
    2c62:	e0 2d       	mov	r30, r0
    2c64:	86 81       	ldd	r24, Z+6	; 0x06
    2c66:	97 81       	ldd	r25, Z+7	; 0x07
    2c68:	90 93 2b 05 	sts	0x052B, r25
    2c6c:	80 93 2a 05 	sts	0x052A, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2c70:	0f 90       	pop	r0
    2c72:	0f 90       	pop	r0
    2c74:	cf 91       	pop	r28
    2c76:	df 91       	pop	r29
    2c78:	08 95       	ret

00002c7a <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2c7a:	df 93       	push	r29
    2c7c:	cf 93       	push	r28
    2c7e:	00 d0       	rcall	.+0      	; 0x2c80 <vTaskPlaceOnEventList+0x6>
    2c80:	00 d0       	rcall	.+0      	; 0x2c82 <vTaskPlaceOnEventList+0x8>
    2c82:	00 d0       	rcall	.+0      	; 0x2c84 <vTaskPlaceOnEventList+0xa>
    2c84:	cd b7       	in	r28, 0x3d	; 61
    2c86:	de b7       	in	r29, 0x3e	; 62
    2c88:	9c 83       	std	Y+4, r25	; 0x04
    2c8a:	8b 83       	std	Y+3, r24	; 0x03
    2c8c:	7e 83       	std	Y+6, r23	; 0x06
    2c8e:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2c90:	4b 81       	ldd	r20, Y+3	; 0x03
    2c92:	5c 81       	ldd	r21, Y+4	; 0x04
    2c94:	80 91 2a 05 	lds	r24, 0x052A
    2c98:	90 91 2b 05 	lds	r25, 0x052B
    2c9c:	9c 01       	movw	r18, r24
    2c9e:	24 5f       	subi	r18, 0xF4	; 244
    2ca0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ca2:	ca 01       	movw	r24, r20
    2ca4:	b9 01       	movw	r22, r18
    2ca6:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2caa:	80 91 2a 05 	lds	r24, 0x052A
    2cae:	90 91 2b 05 	lds	r25, 0x052B
    2cb2:	02 96       	adiw	r24, 0x02	; 2
    2cb4:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2cb8:	20 91 2e 05 	lds	r18, 0x052E
    2cbc:	30 91 2f 05 	lds	r19, 0x052F
    2cc0:	8d 81       	ldd	r24, Y+5	; 0x05
    2cc2:	9e 81       	ldd	r25, Y+6	; 0x06
    2cc4:	82 0f       	add	r24, r18
    2cc6:	93 1f       	adc	r25, r19
    2cc8:	9a 83       	std	Y+2, r25	; 0x02
    2cca:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2ccc:	89 81       	ldd	r24, Y+1	; 0x01
    2cce:	9a 81       	ldd	r25, Y+2	; 0x02
    2cd0:	0e 94 37 18 	call	0x306e	; 0x306e <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2cd4:	26 96       	adiw	r28, 0x06	; 6
    2cd6:	0f b6       	in	r0, 0x3f	; 63
    2cd8:	f8 94       	cli
    2cda:	de bf       	out	0x3e, r29	; 62
    2cdc:	0f be       	out	0x3f, r0	; 63
    2cde:	cd bf       	out	0x3d, r28	; 61
    2ce0:	cf 91       	pop	r28
    2ce2:	df 91       	pop	r29
    2ce4:	08 95       	ret

00002ce6 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2ce6:	df 93       	push	r29
    2ce8:	cf 93       	push	r28
    2cea:	00 d0       	rcall	.+0      	; 0x2cec <xTaskRemoveFromEventList+0x6>
    2cec:	00 d0       	rcall	.+0      	; 0x2cee <xTaskRemoveFromEventList+0x8>
    2cee:	0f 92       	push	r0
    2cf0:	cd b7       	in	r28, 0x3d	; 61
    2cf2:	de b7       	in	r29, 0x3e	; 62
    2cf4:	9d 83       	std	Y+5, r25	; 0x05
    2cf6:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2cf8:	ec 81       	ldd	r30, Y+4	; 0x04
    2cfa:	fd 81       	ldd	r31, Y+5	; 0x05
    2cfc:	05 80       	ldd	r0, Z+5	; 0x05
    2cfe:	f6 81       	ldd	r31, Z+6	; 0x06
    2d00:	e0 2d       	mov	r30, r0
    2d02:	86 81       	ldd	r24, Z+6	; 0x06
    2d04:	97 81       	ldd	r25, Z+7	; 0x07
    2d06:	9b 83       	std	Y+3, r25	; 0x03
    2d08:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2d0a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d0c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d0e:	0c 96       	adiw	r24, 0x0c	; 12
    2d10:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2d14:	80 91 33 05 	lds	r24, 0x0533
    2d18:	88 23       	and	r24, r24
    2d1a:	61 f5       	brne	.+88     	; 0x2d74 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2d1c:	8a 81       	ldd	r24, Y+2	; 0x02
    2d1e:	9b 81       	ldd	r25, Y+3	; 0x03
    2d20:	02 96       	adiw	r24, 0x02	; 2
    2d22:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2d26:	ea 81       	ldd	r30, Y+2	; 0x02
    2d28:	fb 81       	ldd	r31, Y+3	; 0x03
    2d2a:	96 89       	ldd	r25, Z+22	; 0x16
    2d2c:	80 91 31 05 	lds	r24, 0x0531
    2d30:	89 17       	cp	r24, r25
    2d32:	28 f4       	brcc	.+10     	; 0x2d3e <xTaskRemoveFromEventList+0x58>
    2d34:	ea 81       	ldd	r30, Y+2	; 0x02
    2d36:	fb 81       	ldd	r31, Y+3	; 0x03
    2d38:	86 89       	ldd	r24, Z+22	; 0x16
    2d3a:	80 93 31 05 	sts	0x0531, r24
    2d3e:	ea 81       	ldd	r30, Y+2	; 0x02
    2d40:	fb 81       	ldd	r31, Y+3	; 0x03
    2d42:	86 89       	ldd	r24, Z+22	; 0x16
    2d44:	28 2f       	mov	r18, r24
    2d46:	30 e0       	ldi	r19, 0x00	; 0
    2d48:	c9 01       	movw	r24, r18
    2d4a:	88 0f       	add	r24, r24
    2d4c:	99 1f       	adc	r25, r25
    2d4e:	88 0f       	add	r24, r24
    2d50:	99 1f       	adc	r25, r25
    2d52:	88 0f       	add	r24, r24
    2d54:	99 1f       	adc	r25, r25
    2d56:	82 0f       	add	r24, r18
    2d58:	93 1f       	adc	r25, r19
    2d5a:	ac 01       	movw	r20, r24
    2d5c:	48 5c       	subi	r20, 0xC8	; 200
    2d5e:	5a 4f       	sbci	r21, 0xFA	; 250
    2d60:	8a 81       	ldd	r24, Y+2	; 0x02
    2d62:	9b 81       	ldd	r25, Y+3	; 0x03
    2d64:	9c 01       	movw	r18, r24
    2d66:	2e 5f       	subi	r18, 0xFE	; 254
    2d68:	3f 4f       	sbci	r19, 0xFF	; 255
    2d6a:	ca 01       	movw	r24, r20
    2d6c:	b9 01       	movw	r22, r18
    2d6e:	0e 94 88 09 	call	0x1310	; 0x1310 <vListInsertEnd>
    2d72:	0a c0       	rjmp	.+20     	; 0x2d88 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2d74:	8a 81       	ldd	r24, Y+2	; 0x02
    2d76:	9b 81       	ldd	r25, Y+3	; 0x03
    2d78:	9c 01       	movw	r18, r24
    2d7a:	24 5f       	subi	r18, 0xF4	; 244
    2d7c:	3f 4f       	sbci	r19, 0xFF	; 255
    2d7e:	82 e7       	ldi	r24, 0x72	; 114
    2d80:	95 e0       	ldi	r25, 0x05	; 5
    2d82:	b9 01       	movw	r22, r18
    2d84:	0e 94 88 09 	call	0x1310	; 0x1310 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2d88:	ea 81       	ldd	r30, Y+2	; 0x02
    2d8a:	fb 81       	ldd	r31, Y+3	; 0x03
    2d8c:	96 89       	ldd	r25, Z+22	; 0x16
    2d8e:	e0 91 2a 05 	lds	r30, 0x052A
    2d92:	f0 91 2b 05 	lds	r31, 0x052B
    2d96:	86 89       	ldd	r24, Z+22	; 0x16
    2d98:	98 17       	cp	r25, r24
    2d9a:	18 f0       	brcs	.+6      	; 0x2da2 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2d9c:	81 e0       	ldi	r24, 0x01	; 1
    2d9e:	89 83       	std	Y+1, r24	; 0x01
    2da0:	01 c0       	rjmp	.+2      	; 0x2da4 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    2da2:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2da4:	89 81       	ldd	r24, Y+1	; 0x01
}
    2da6:	0f 90       	pop	r0
    2da8:	0f 90       	pop	r0
    2daa:	0f 90       	pop	r0
    2dac:	0f 90       	pop	r0
    2dae:	0f 90       	pop	r0
    2db0:	cf 91       	pop	r28
    2db2:	df 91       	pop	r29
    2db4:	08 95       	ret

00002db6 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2db6:	df 93       	push	r29
    2db8:	cf 93       	push	r28
    2dba:	00 d0       	rcall	.+0      	; 0x2dbc <vTaskSetTimeOutState+0x6>
    2dbc:	cd b7       	in	r28, 0x3d	; 61
    2dbe:	de b7       	in	r29, 0x3e	; 62
    2dc0:	9a 83       	std	Y+2, r25	; 0x02
    2dc2:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2dc4:	80 91 36 05 	lds	r24, 0x0536
    2dc8:	e9 81       	ldd	r30, Y+1	; 0x01
    2dca:	fa 81       	ldd	r31, Y+2	; 0x02
    2dcc:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2dce:	80 91 2e 05 	lds	r24, 0x052E
    2dd2:	90 91 2f 05 	lds	r25, 0x052F
    2dd6:	e9 81       	ldd	r30, Y+1	; 0x01
    2dd8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dda:	92 83       	std	Z+2, r25	; 0x02
    2ddc:	81 83       	std	Z+1, r24	; 0x01
}
    2dde:	0f 90       	pop	r0
    2de0:	0f 90       	pop	r0
    2de2:	cf 91       	pop	r28
    2de4:	df 91       	pop	r29
    2de6:	08 95       	ret

00002de8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2de8:	df 93       	push	r29
    2dea:	cf 93       	push	r28
    2dec:	00 d0       	rcall	.+0      	; 0x2dee <xTaskCheckForTimeOut+0x6>
    2dee:	00 d0       	rcall	.+0      	; 0x2df0 <xTaskCheckForTimeOut+0x8>
    2df0:	0f 92       	push	r0
    2df2:	cd b7       	in	r28, 0x3d	; 61
    2df4:	de b7       	in	r29, 0x3e	; 62
    2df6:	9b 83       	std	Y+3, r25	; 0x03
    2df8:	8a 83       	std	Y+2, r24	; 0x02
    2dfa:	7d 83       	std	Y+5, r23	; 0x05
    2dfc:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2dfe:	0f b6       	in	r0, 0x3f	; 63
    2e00:	f8 94       	cli
    2e02:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2e04:	ea 81       	ldd	r30, Y+2	; 0x02
    2e06:	fb 81       	ldd	r31, Y+3	; 0x03
    2e08:	90 81       	ld	r25, Z
    2e0a:	80 91 36 05 	lds	r24, 0x0536
    2e0e:	98 17       	cp	r25, r24
    2e10:	71 f0       	breq	.+28     	; 0x2e2e <xTaskCheckForTimeOut+0x46>
    2e12:	ea 81       	ldd	r30, Y+2	; 0x02
    2e14:	fb 81       	ldd	r31, Y+3	; 0x03
    2e16:	21 81       	ldd	r18, Z+1	; 0x01
    2e18:	32 81       	ldd	r19, Z+2	; 0x02
    2e1a:	80 91 2e 05 	lds	r24, 0x052E
    2e1e:	90 91 2f 05 	lds	r25, 0x052F
    2e22:	82 17       	cp	r24, r18
    2e24:	93 07       	cpc	r25, r19
    2e26:	18 f0       	brcs	.+6      	; 0x2e2e <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2e28:	81 e0       	ldi	r24, 0x01	; 1
    2e2a:	89 83       	std	Y+1, r24	; 0x01
    2e2c:	2f c0       	rjmp	.+94     	; 0x2e8c <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2e2e:	20 91 2e 05 	lds	r18, 0x052E
    2e32:	30 91 2f 05 	lds	r19, 0x052F
    2e36:	ea 81       	ldd	r30, Y+2	; 0x02
    2e38:	fb 81       	ldd	r31, Y+3	; 0x03
    2e3a:	81 81       	ldd	r24, Z+1	; 0x01
    2e3c:	92 81       	ldd	r25, Z+2	; 0x02
    2e3e:	28 1b       	sub	r18, r24
    2e40:	39 0b       	sbc	r19, r25
    2e42:	ec 81       	ldd	r30, Y+4	; 0x04
    2e44:	fd 81       	ldd	r31, Y+5	; 0x05
    2e46:	80 81       	ld	r24, Z
    2e48:	91 81       	ldd	r25, Z+1	; 0x01
    2e4a:	28 17       	cp	r18, r24
    2e4c:	39 07       	cpc	r19, r25
    2e4e:	e0 f4       	brcc	.+56     	; 0x2e88 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2e50:	ec 81       	ldd	r30, Y+4	; 0x04
    2e52:	fd 81       	ldd	r31, Y+5	; 0x05
    2e54:	40 81       	ld	r20, Z
    2e56:	51 81       	ldd	r21, Z+1	; 0x01
    2e58:	ea 81       	ldd	r30, Y+2	; 0x02
    2e5a:	fb 81       	ldd	r31, Y+3	; 0x03
    2e5c:	21 81       	ldd	r18, Z+1	; 0x01
    2e5e:	32 81       	ldd	r19, Z+2	; 0x02
    2e60:	80 91 2e 05 	lds	r24, 0x052E
    2e64:	90 91 2f 05 	lds	r25, 0x052F
    2e68:	b9 01       	movw	r22, r18
    2e6a:	68 1b       	sub	r22, r24
    2e6c:	79 0b       	sbc	r23, r25
    2e6e:	cb 01       	movw	r24, r22
    2e70:	84 0f       	add	r24, r20
    2e72:	95 1f       	adc	r25, r21
    2e74:	ec 81       	ldd	r30, Y+4	; 0x04
    2e76:	fd 81       	ldd	r31, Y+5	; 0x05
    2e78:	91 83       	std	Z+1, r25	; 0x01
    2e7a:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    2e7c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e7e:	9b 81       	ldd	r25, Y+3	; 0x03
    2e80:	0e 94 db 16 	call	0x2db6	; 0x2db6 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2e84:	19 82       	std	Y+1, r1	; 0x01
    2e86:	02 c0       	rjmp	.+4      	; 0x2e8c <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2e88:	81 e0       	ldi	r24, 0x01	; 1
    2e8a:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2e8c:	0f 90       	pop	r0
    2e8e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2e90:	89 81       	ldd	r24, Y+1	; 0x01
}
    2e92:	0f 90       	pop	r0
    2e94:	0f 90       	pop	r0
    2e96:	0f 90       	pop	r0
    2e98:	0f 90       	pop	r0
    2e9a:	0f 90       	pop	r0
    2e9c:	cf 91       	pop	r28
    2e9e:	df 91       	pop	r29
    2ea0:	08 95       	ret

00002ea2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2ea2:	df 93       	push	r29
    2ea4:	cf 93       	push	r28
    2ea6:	cd b7       	in	r28, 0x3d	; 61
    2ea8:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2eaa:	81 e0       	ldi	r24, 0x01	; 1
    2eac:	80 93 35 05 	sts	0x0535, r24
}
    2eb0:	cf 91       	pop	r28
    2eb2:	df 91       	pop	r29
    2eb4:	08 95       	ret

00002eb6 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2eb6:	df 93       	push	r29
    2eb8:	cf 93       	push	r28
    2eba:	00 d0       	rcall	.+0      	; 0x2ebc <prvIdleTask+0x6>
    2ebc:	cd b7       	in	r28, 0x3d	; 61
    2ebe:	de b7       	in	r29, 0x3e	; 62
    2ec0:	9a 83       	std	Y+2, r25	; 0x02
    2ec2:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2ec4:	0e 94 f9 17 	call	0x2ff2	; 0x2ff2 <prvCheckTasksWaitingTermination>
    2ec8:	fd cf       	rjmp	.-6      	; 0x2ec4 <prvIdleTask+0xe>

00002eca <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2eca:	0f 93       	push	r16
    2ecc:	1f 93       	push	r17
    2ece:	df 93       	push	r29
    2ed0:	cf 93       	push	r28
    2ed2:	cd b7       	in	r28, 0x3d	; 61
    2ed4:	de b7       	in	r29, 0x3e	; 62
    2ed6:	29 97       	sbiw	r28, 0x09	; 9
    2ed8:	0f b6       	in	r0, 0x3f	; 63
    2eda:	f8 94       	cli
    2edc:	de bf       	out	0x3e, r29	; 62
    2ede:	0f be       	out	0x3f, r0	; 63
    2ee0:	cd bf       	out	0x3d, r28	; 61
    2ee2:	9a 83       	std	Y+2, r25	; 0x02
    2ee4:	89 83       	std	Y+1, r24	; 0x01
    2ee6:	7c 83       	std	Y+4, r23	; 0x04
    2ee8:	6b 83       	std	Y+3, r22	; 0x03
    2eea:	4d 83       	std	Y+5, r20	; 0x05
    2eec:	3f 83       	std	Y+7, r19	; 0x07
    2eee:	2e 83       	std	Y+6, r18	; 0x06
    2ef0:	19 87       	std	Y+9, r17	; 0x09
    2ef2:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2ef4:	89 81       	ldd	r24, Y+1	; 0x01
    2ef6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ef8:	49 96       	adiw	r24, 0x19	; 25
    2efa:	2b 81       	ldd	r18, Y+3	; 0x03
    2efc:	3c 81       	ldd	r19, Y+4	; 0x04
    2efe:	b9 01       	movw	r22, r18
    2f00:	48 e0       	ldi	r20, 0x08	; 8
    2f02:	50 e0       	ldi	r21, 0x00	; 0
    2f04:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2f08:	e9 81       	ldd	r30, Y+1	; 0x01
    2f0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f0c:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    2f0e:	8d 81       	ldd	r24, Y+5	; 0x05
    2f10:	84 30       	cpi	r24, 0x04	; 4
    2f12:	10 f0       	brcs	.+4      	; 0x2f18 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2f14:	83 e0       	ldi	r24, 0x03	; 3
    2f16:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2f18:	e9 81       	ldd	r30, Y+1	; 0x01
    2f1a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f1c:	8d 81       	ldd	r24, Y+5	; 0x05
    2f1e:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2f20:	89 81       	ldd	r24, Y+1	; 0x01
    2f22:	9a 81       	ldd	r25, Y+2	; 0x02
    2f24:	02 96       	adiw	r24, 0x02	; 2
    2f26:	0e 94 78 09 	call	0x12f0	; 0x12f0 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2f2a:	89 81       	ldd	r24, Y+1	; 0x01
    2f2c:	9a 81       	ldd	r25, Y+2	; 0x02
    2f2e:	0c 96       	adiw	r24, 0x0c	; 12
    2f30:	0e 94 78 09 	call	0x12f0	; 0x12f0 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2f34:	e9 81       	ldd	r30, Y+1	; 0x01
    2f36:	fa 81       	ldd	r31, Y+2	; 0x02
    2f38:	89 81       	ldd	r24, Y+1	; 0x01
    2f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2f3c:	91 87       	std	Z+9, r25	; 0x09
    2f3e:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2f40:	8d 81       	ldd	r24, Y+5	; 0x05
    2f42:	28 2f       	mov	r18, r24
    2f44:	30 e0       	ldi	r19, 0x00	; 0
    2f46:	84 e0       	ldi	r24, 0x04	; 4
    2f48:	90 e0       	ldi	r25, 0x00	; 0
    2f4a:	82 1b       	sub	r24, r18
    2f4c:	93 0b       	sbc	r25, r19
    2f4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f50:	fa 81       	ldd	r31, Y+2	; 0x02
    2f52:	95 87       	std	Z+13, r25	; 0x0d
    2f54:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2f56:	e9 81       	ldd	r30, Y+1	; 0x01
    2f58:	fa 81       	ldd	r31, Y+2	; 0x02
    2f5a:	89 81       	ldd	r24, Y+1	; 0x01
    2f5c:	9a 81       	ldd	r25, Y+2	; 0x02
    2f5e:	93 8b       	std	Z+19, r25	; 0x13
    2f60:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2f62:	29 96       	adiw	r28, 0x09	; 9
    2f64:	0f b6       	in	r0, 0x3f	; 63
    2f66:	f8 94       	cli
    2f68:	de bf       	out	0x3e, r29	; 62
    2f6a:	0f be       	out	0x3f, r0	; 63
    2f6c:	cd bf       	out	0x3d, r28	; 61
    2f6e:	cf 91       	pop	r28
    2f70:	df 91       	pop	r29
    2f72:	1f 91       	pop	r17
    2f74:	0f 91       	pop	r16
    2f76:	08 95       	ret

00002f78 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2f78:	df 93       	push	r29
    2f7a:	cf 93       	push	r28
    2f7c:	0f 92       	push	r0
    2f7e:	cd b7       	in	r28, 0x3d	; 61
    2f80:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2f82:	19 82       	std	Y+1, r1	; 0x01
    2f84:	13 c0       	rjmp	.+38     	; 0x2fac <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2f86:	89 81       	ldd	r24, Y+1	; 0x01
    2f88:	28 2f       	mov	r18, r24
    2f8a:	30 e0       	ldi	r19, 0x00	; 0
    2f8c:	c9 01       	movw	r24, r18
    2f8e:	88 0f       	add	r24, r24
    2f90:	99 1f       	adc	r25, r25
    2f92:	88 0f       	add	r24, r24
    2f94:	99 1f       	adc	r25, r25
    2f96:	88 0f       	add	r24, r24
    2f98:	99 1f       	adc	r25, r25
    2f9a:	82 0f       	add	r24, r18
    2f9c:	93 1f       	adc	r25, r19
    2f9e:	88 5c       	subi	r24, 0xC8	; 200
    2fa0:	9a 4f       	sbci	r25, 0xFA	; 250
    2fa2:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2fa6:	89 81       	ldd	r24, Y+1	; 0x01
    2fa8:	8f 5f       	subi	r24, 0xFF	; 255
    2faa:	89 83       	std	Y+1, r24	; 0x01
    2fac:	89 81       	ldd	r24, Y+1	; 0x01
    2fae:	84 30       	cpi	r24, 0x04	; 4
    2fb0:	50 f3       	brcs	.-44     	; 0x2f86 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2fb2:	8c e5       	ldi	r24, 0x5C	; 92
    2fb4:	95 e0       	ldi	r25, 0x05	; 5
    2fb6:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2fba:	85 e6       	ldi	r24, 0x65	; 101
    2fbc:	95 e0       	ldi	r25, 0x05	; 5
    2fbe:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2fc2:	82 e7       	ldi	r24, 0x72	; 114
    2fc4:	95 e0       	ldi	r25, 0x05	; 5
    2fc6:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2fca:	8b e7       	ldi	r24, 0x7B	; 123
    2fcc:	95 e0       	ldi	r25, 0x05	; 5
    2fce:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2fd2:	8c e5       	ldi	r24, 0x5C	; 92
    2fd4:	95 e0       	ldi	r25, 0x05	; 5
    2fd6:	90 93 6f 05 	sts	0x056F, r25
    2fda:	80 93 6e 05 	sts	0x056E, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2fde:	85 e6       	ldi	r24, 0x65	; 101
    2fe0:	95 e0       	ldi	r25, 0x05	; 5
    2fe2:	90 93 71 05 	sts	0x0571, r25
    2fe6:	80 93 70 05 	sts	0x0570, r24
}
    2fea:	0f 90       	pop	r0
    2fec:	cf 91       	pop	r28
    2fee:	df 91       	pop	r29
    2ff0:	08 95       	ret

00002ff2 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2ff2:	df 93       	push	r29
    2ff4:	cf 93       	push	r28
    2ff6:	00 d0       	rcall	.+0      	; 0x2ff8 <prvCheckTasksWaitingTermination+0x6>
    2ff8:	0f 92       	push	r0
    2ffa:	cd b7       	in	r28, 0x3d	; 61
    2ffc:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    2ffe:	80 91 2c 05 	lds	r24, 0x052C
    3002:	88 23       	and	r24, r24
    3004:	71 f1       	breq	.+92     	; 0x3062 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    3006:	0e 94 37 14 	call	0x286e	; 0x286e <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    300a:	80 91 7b 05 	lds	r24, 0x057B
    300e:	1b 82       	std	Y+3, r1	; 0x03
    3010:	88 23       	and	r24, r24
    3012:	11 f4       	brne	.+4      	; 0x3018 <prvCheckTasksWaitingTermination+0x26>
    3014:	81 e0       	ldi	r24, 0x01	; 1
    3016:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    3018:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    301c:	8b 81       	ldd	r24, Y+3	; 0x03
    301e:	88 23       	and	r24, r24
    3020:	01 f5       	brne	.+64     	; 0x3062 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    3022:	0f b6       	in	r0, 0x3f	; 63
    3024:	f8 94       	cli
    3026:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    3028:	e0 91 80 05 	lds	r30, 0x0580
    302c:	f0 91 81 05 	lds	r31, 0x0581
    3030:	86 81       	ldd	r24, Z+6	; 0x06
    3032:	97 81       	ldd	r25, Z+7	; 0x07
    3034:	9a 83       	std	Y+2, r25	; 0x02
    3036:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    3038:	89 81       	ldd	r24, Y+1	; 0x01
    303a:	9a 81       	ldd	r25, Y+2	; 0x02
    303c:	02 96       	adiw	r24, 0x02	; 2
    303e:	0e 94 40 0a 	call	0x1480	; 0x1480 <vListRemove>
					--uxCurrentNumberOfTasks;
    3042:	80 91 2d 05 	lds	r24, 0x052D
    3046:	81 50       	subi	r24, 0x01	; 1
    3048:	80 93 2d 05 	sts	0x052D, r24
					--uxTasksDeleted;
    304c:	80 91 2c 05 	lds	r24, 0x052C
    3050:	81 50       	subi	r24, 0x01	; 1
    3052:	80 93 2c 05 	sts	0x052C, r24
				}
				taskEXIT_CRITICAL();
    3056:	0f 90       	pop	r0
    3058:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    305a:	89 81       	ldd	r24, Y+1	; 0x01
    305c:	9a 81       	ldd	r25, Y+2	; 0x02
    305e:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    3062:	0f 90       	pop	r0
    3064:	0f 90       	pop	r0
    3066:	0f 90       	pop	r0
    3068:	cf 91       	pop	r28
    306a:	df 91       	pop	r29
    306c:	08 95       	ret

0000306e <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    306e:	df 93       	push	r29
    3070:	cf 93       	push	r28
    3072:	00 d0       	rcall	.+0      	; 0x3074 <prvAddCurrentTaskToDelayedList+0x6>
    3074:	cd b7       	in	r28, 0x3d	; 61
    3076:	de b7       	in	r29, 0x3e	; 62
    3078:	9a 83       	std	Y+2, r25	; 0x02
    307a:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    307c:	e0 91 2a 05 	lds	r30, 0x052A
    3080:	f0 91 2b 05 	lds	r31, 0x052B
    3084:	89 81       	ldd	r24, Y+1	; 0x01
    3086:	9a 81       	ldd	r25, Y+2	; 0x02
    3088:	93 83       	std	Z+3, r25	; 0x03
    308a:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    308c:	20 91 2e 05 	lds	r18, 0x052E
    3090:	30 91 2f 05 	lds	r19, 0x052F
    3094:	89 81       	ldd	r24, Y+1	; 0x01
    3096:	9a 81       	ldd	r25, Y+2	; 0x02
    3098:	82 17       	cp	r24, r18
    309a:	93 07       	cpc	r25, r19
    309c:	70 f4       	brcc	.+28     	; 0x30ba <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    309e:	80 91 70 05 	lds	r24, 0x0570
    30a2:	90 91 71 05 	lds	r25, 0x0571
    30a6:	20 91 2a 05 	lds	r18, 0x052A
    30aa:	30 91 2b 05 	lds	r19, 0x052B
    30ae:	2e 5f       	subi	r18, 0xFE	; 254
    30b0:	3f 4f       	sbci	r19, 0xFF	; 255
    30b2:	b9 01       	movw	r22, r18
    30b4:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <vListInsert>
    30b8:	1e c0       	rjmp	.+60     	; 0x30f6 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    30ba:	40 91 6e 05 	lds	r20, 0x056E
    30be:	50 91 6f 05 	lds	r21, 0x056F
    30c2:	80 91 2a 05 	lds	r24, 0x052A
    30c6:	90 91 2b 05 	lds	r25, 0x052B
    30ca:	9c 01       	movw	r18, r24
    30cc:	2e 5f       	subi	r18, 0xFE	; 254
    30ce:	3f 4f       	sbci	r19, 0xFF	; 255
    30d0:	ca 01       	movw	r24, r20
    30d2:	b9 01       	movw	r22, r18
    30d4:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    30d8:	20 91 6d 00 	lds	r18, 0x006D
    30dc:	30 91 6e 00 	lds	r19, 0x006E
    30e0:	89 81       	ldd	r24, Y+1	; 0x01
    30e2:	9a 81       	ldd	r25, Y+2	; 0x02
    30e4:	82 17       	cp	r24, r18
    30e6:	93 07       	cpc	r25, r19
    30e8:	30 f4       	brcc	.+12     	; 0x30f6 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    30ea:	89 81       	ldd	r24, Y+1	; 0x01
    30ec:	9a 81       	ldd	r25, Y+2	; 0x02
    30ee:	90 93 6e 00 	sts	0x006E, r25
    30f2:	80 93 6d 00 	sts	0x006D, r24
		}
	}
}
    30f6:	0f 90       	pop	r0
    30f8:	0f 90       	pop	r0
    30fa:	cf 91       	pop	r28
    30fc:	df 91       	pop	r29
    30fe:	08 95       	ret

00003100 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    3100:	df 93       	push	r29
    3102:	cf 93       	push	r28
    3104:	cd b7       	in	r28, 0x3d	; 61
    3106:	de b7       	in	r29, 0x3e	; 62
    3108:	28 97       	sbiw	r28, 0x08	; 8
    310a:	0f b6       	in	r0, 0x3f	; 63
    310c:	f8 94       	cli
    310e:	de bf       	out	0x3e, r29	; 62
    3110:	0f be       	out	0x3f, r0	; 63
    3112:	cd bf       	out	0x3d, r28	; 61
    3114:	9c 83       	std	Y+4, r25	; 0x04
    3116:	8b 83       	std	Y+3, r24	; 0x03
    3118:	7e 83       	std	Y+6, r23	; 0x06
    311a:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    311c:	81 e2       	ldi	r24, 0x21	; 33
    311e:	90 e0       	ldi	r25, 0x00	; 0
    3120:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <pvPortMalloc>
    3124:	9a 83       	std	Y+2, r25	; 0x02
    3126:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    3128:	89 81       	ldd	r24, Y+1	; 0x01
    312a:	9a 81       	ldd	r25, Y+2	; 0x02
    312c:	00 97       	sbiw	r24, 0x00	; 0
    312e:	69 f1       	breq	.+90     	; 0x318a <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    3130:	8d 81       	ldd	r24, Y+5	; 0x05
    3132:	9e 81       	ldd	r25, Y+6	; 0x06
    3134:	00 97       	sbiw	r24, 0x00	; 0
    3136:	39 f4       	brne	.+14     	; 0x3146 <prvAllocateTCBAndStack+0x46>
    3138:	8b 81       	ldd	r24, Y+3	; 0x03
    313a:	9c 81       	ldd	r25, Y+4	; 0x04
    313c:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <pvPortMalloc>
    3140:	98 87       	std	Y+8, r25	; 0x08
    3142:	8f 83       	std	Y+7, r24	; 0x07
    3144:	04 c0       	rjmp	.+8      	; 0x314e <prvAllocateTCBAndStack+0x4e>
    3146:	8d 81       	ldd	r24, Y+5	; 0x05
    3148:	9e 81       	ldd	r25, Y+6	; 0x06
    314a:	98 87       	std	Y+8, r25	; 0x08
    314c:	8f 83       	std	Y+7, r24	; 0x07
    314e:	e9 81       	ldd	r30, Y+1	; 0x01
    3150:	fa 81       	ldd	r31, Y+2	; 0x02
    3152:	8f 81       	ldd	r24, Y+7	; 0x07
    3154:	98 85       	ldd	r25, Y+8	; 0x08
    3156:	90 8f       	std	Z+24, r25	; 0x18
    3158:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    315a:	e9 81       	ldd	r30, Y+1	; 0x01
    315c:	fa 81       	ldd	r31, Y+2	; 0x02
    315e:	87 89       	ldd	r24, Z+23	; 0x17
    3160:	90 8d       	ldd	r25, Z+24	; 0x18
    3162:	00 97       	sbiw	r24, 0x00	; 0
    3164:	39 f4       	brne	.+14     	; 0x3174 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    3166:	89 81       	ldd	r24, Y+1	; 0x01
    3168:	9a 81       	ldd	r25, Y+2	; 0x02
    316a:	0e 94 28 09 	call	0x1250	; 0x1250 <vPortFree>
			pxNewTCB = NULL;
    316e:	1a 82       	std	Y+2, r1	; 0x02
    3170:	19 82       	std	Y+1, r1	; 0x01
    3172:	0b c0       	rjmp	.+22     	; 0x318a <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    3174:	e9 81       	ldd	r30, Y+1	; 0x01
    3176:	fa 81       	ldd	r31, Y+2	; 0x02
    3178:	87 89       	ldd	r24, Z+23	; 0x17
    317a:	90 8d       	ldd	r25, Z+24	; 0x18
    317c:	2b 81       	ldd	r18, Y+3	; 0x03
    317e:	3c 81       	ldd	r19, Y+4	; 0x04
    3180:	65 ea       	ldi	r22, 0xA5	; 165
    3182:	70 e0       	ldi	r23, 0x00	; 0
    3184:	a9 01       	movw	r20, r18
    3186:	0e 94 d1 21 	call	0x43a2	; 0x43a2 <memset>
		}
	}

	return pxNewTCB;
    318a:	89 81       	ldd	r24, Y+1	; 0x01
    318c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    318e:	28 96       	adiw	r28, 0x08	; 8
    3190:	0f b6       	in	r0, 0x3f	; 63
    3192:	f8 94       	cli
    3194:	de bf       	out	0x3e, r29	; 62
    3196:	0f be       	out	0x3f, r0	; 63
    3198:	cd bf       	out	0x3d, r28	; 61
    319a:	cf 91       	pop	r28
    319c:	df 91       	pop	r29
    319e:	08 95       	ret

000031a0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    31a0:	df 93       	push	r29
    31a2:	cf 93       	push	r28
    31a4:	00 d0       	rcall	.+0      	; 0x31a6 <prvDeleteTCB+0x6>
    31a6:	cd b7       	in	r28, 0x3d	; 61
    31a8:	de b7       	in	r29, 0x3e	; 62
    31aa:	9a 83       	std	Y+2, r25	; 0x02
    31ac:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    31ae:	e9 81       	ldd	r30, Y+1	; 0x01
    31b0:	fa 81       	ldd	r31, Y+2	; 0x02
    31b2:	87 89       	ldd	r24, Z+23	; 0x17
    31b4:	90 8d       	ldd	r25, Z+24	; 0x18
    31b6:	0e 94 28 09 	call	0x1250	; 0x1250 <vPortFree>
		vPortFree( pxTCB );
    31ba:	89 81       	ldd	r24, Y+1	; 0x01
    31bc:	9a 81       	ldd	r25, Y+2	; 0x02
    31be:	0e 94 28 09 	call	0x1250	; 0x1250 <vPortFree>
	}
    31c2:	0f 90       	pop	r0
    31c4:	0f 90       	pop	r0
    31c6:	cf 91       	pop	r28
    31c8:	df 91       	pop	r29
    31ca:	08 95       	ret

000031cc <MCAL_DIO_SetPortDirection>:
 * 	@ RetVal	 - Std_Return.
 *	  Note		 - This API return "OK" when no error occurred,
 *	  			   return "INVALID_PORT" when the entered port is not valid,
 *	  			   return "UNKNOWN"	when there's unknown error.
 * ==================================================================== */
Std_Return MCAL_DIO_SetPortDirection(DIO_PortType DIO_Port){
    31cc:	df 93       	push	r29
    31ce:	cf 93       	push	r28
    31d0:	00 d0       	rcall	.+0      	; 0x31d2 <MCAL_DIO_SetPortDirection+0x6>
    31d2:	00 d0       	rcall	.+0      	; 0x31d4 <MCAL_DIO_SetPortDirection+0x8>
    31d4:	0f 92       	push	r0
    31d6:	cd b7       	in	r28, 0x3d	; 61
    31d8:	de b7       	in	r29, 0x3e	; 62
    31da:	9b 83       	std	Y+3, r25	; 0x03
    31dc:	8a 83       	std	Y+2, r24	; 0x02

	/*---------- Return Values ----------*/
	// Initialize error status with no errors
	Std_Return DIO_ReturnError = OK;
    31de:	19 82       	std	Y+1, r1	; 0x01

	// Check if there is any errors in the parameter
	if(((DIO_Port.Port) > Port_D) || ((DIO_Port.Port) < 0)) DIO_ReturnError = INVALID_PORT;
    31e0:	8a 81       	ldd	r24, Y+2	; 0x02
    31e2:	84 30       	cpi	r24, 0x04	; 4
    31e4:	18 f0       	brcs	.+6      	; 0x31ec <MCAL_DIO_SetPortDirection+0x20>
    31e6:	82 e0       	ldi	r24, 0x02	; 2
    31e8:	89 83       	std	Y+1, r24	; 0x01
    31ea:	07 c0       	rjmp	.+14     	; 0x31fa <MCAL_DIO_SetPortDirection+0x2e>
	else if((DIO_Port.Port) <= Port_D) DIO_ReturnError = OK;
    31ec:	8a 81       	ldd	r24, Y+2	; 0x02
    31ee:	84 30       	cpi	r24, 0x04	; 4
    31f0:	10 f4       	brcc	.+4      	; 0x31f6 <MCAL_DIO_SetPortDirection+0x2a>
    31f2:	19 82       	std	Y+1, r1	; 0x01
    31f4:	02 c0       	rjmp	.+4      	; 0x31fa <MCAL_DIO_SetPortDirection+0x2e>
	else DIO_ReturnError = UNKNOWN;
    31f6:	81 e0       	ldi	r24, 0x01	; 1
    31f8:	89 83       	std	Y+1, r24	; 0x01




	/*------- Set Port Direction -------*/
	if(DIO_Port.Direction == DIO_Output) DIO_Port.Direction = 0xFF;
    31fa:	8b 81       	ldd	r24, Y+3	; 0x03
    31fc:	81 30       	cpi	r24, 0x01	; 1
    31fe:	11 f4       	brne	.+4      	; 0x3204 <MCAL_DIO_SetPortDirection+0x38>
    3200:	8f ef       	ldi	r24, 0xFF	; 255
    3202:	8b 83       	std	Y+3, r24	; 0x03
	if(DIO_ReturnError == OK) {
    3204:	89 81       	ldd	r24, Y+1	; 0x01
    3206:	88 23       	and	r24, r24
    3208:	91 f5       	brne	.+100    	; 0x326e <MCAL_DIO_SetPortDirection+0xa2>
		switch(DIO_Port.Port){
    320a:	8a 81       	ldd	r24, Y+2	; 0x02
    320c:	28 2f       	mov	r18, r24
    320e:	30 e0       	ldi	r19, 0x00	; 0
    3210:	3d 83       	std	Y+5, r19	; 0x05
    3212:	2c 83       	std	Y+4, r18	; 0x04
    3214:	8c 81       	ldd	r24, Y+4	; 0x04
    3216:	9d 81       	ldd	r25, Y+5	; 0x05
    3218:	81 30       	cpi	r24, 0x01	; 1
    321a:	91 05       	cpc	r25, r1
    321c:	d1 f0       	breq	.+52     	; 0x3252 <MCAL_DIO_SetPortDirection+0x86>
    321e:	2c 81       	ldd	r18, Y+4	; 0x04
    3220:	3d 81       	ldd	r19, Y+5	; 0x05
    3222:	22 30       	cpi	r18, 0x02	; 2
    3224:	31 05       	cpc	r19, r1
    3226:	2c f4       	brge	.+10     	; 0x3232 <MCAL_DIO_SetPortDirection+0x66>
    3228:	8c 81       	ldd	r24, Y+4	; 0x04
    322a:	9d 81       	ldd	r25, Y+5	; 0x05
    322c:	00 97       	sbiw	r24, 0x00	; 0
    322e:	61 f0       	breq	.+24     	; 0x3248 <MCAL_DIO_SetPortDirection+0x7c>
    3230:	1e c0       	rjmp	.+60     	; 0x326e <MCAL_DIO_SetPortDirection+0xa2>
    3232:	2c 81       	ldd	r18, Y+4	; 0x04
    3234:	3d 81       	ldd	r19, Y+5	; 0x05
    3236:	22 30       	cpi	r18, 0x02	; 2
    3238:	31 05       	cpc	r19, r1
    323a:	81 f0       	breq	.+32     	; 0x325c <MCAL_DIO_SetPortDirection+0x90>
    323c:	8c 81       	ldd	r24, Y+4	; 0x04
    323e:	9d 81       	ldd	r25, Y+5	; 0x05
    3240:	83 30       	cpi	r24, 0x03	; 3
    3242:	91 05       	cpc	r25, r1
    3244:	81 f0       	breq	.+32     	; 0x3266 <MCAL_DIO_SetPortDirection+0x9a>
    3246:	13 c0       	rjmp	.+38     	; 0x326e <MCAL_DIO_SetPortDirection+0xa2>

		case Port_A: DDRA = (DIO_Port.Direction); break;
    3248:	ea e3       	ldi	r30, 0x3A	; 58
    324a:	f0 e0       	ldi	r31, 0x00	; 0
    324c:	8b 81       	ldd	r24, Y+3	; 0x03
    324e:	80 83       	st	Z, r24
    3250:	0e c0       	rjmp	.+28     	; 0x326e <MCAL_DIO_SetPortDirection+0xa2>
		case Port_B: DDRB = (DIO_Port.Direction); break;
    3252:	e7 e3       	ldi	r30, 0x37	; 55
    3254:	f0 e0       	ldi	r31, 0x00	; 0
    3256:	8b 81       	ldd	r24, Y+3	; 0x03
    3258:	80 83       	st	Z, r24
    325a:	09 c0       	rjmp	.+18     	; 0x326e <MCAL_DIO_SetPortDirection+0xa2>
		case Port_C: DDRC = (DIO_Port.Direction); break;
    325c:	e4 e3       	ldi	r30, 0x34	; 52
    325e:	f0 e0       	ldi	r31, 0x00	; 0
    3260:	8b 81       	ldd	r24, Y+3	; 0x03
    3262:	80 83       	st	Z, r24
    3264:	04 c0       	rjmp	.+8      	; 0x326e <MCAL_DIO_SetPortDirection+0xa2>
		case Port_D: DDRD = (DIO_Port.Direction); break;
    3266:	e1 e3       	ldi	r30, 0x31	; 49
    3268:	f0 e0       	ldi	r31, 0x00	; 0
    326a:	8b 81       	ldd	r24, Y+3	; 0x03
    326c:	80 83       	st	Z, r24

		}
	}

	return DIO_ReturnError;
    326e:	89 81       	ldd	r24, Y+1	; 0x01

}
    3270:	0f 90       	pop	r0
    3272:	0f 90       	pop	r0
    3274:	0f 90       	pop	r0
    3276:	0f 90       	pop	r0
    3278:	0f 90       	pop	r0
    327a:	cf 91       	pop	r28
    327c:	df 91       	pop	r29
    327e:	08 95       	ret

00003280 <MCAL_DIO_SetPinDirection>:
 *	  Note		 - This API return "OK" when no error occurred,
 *	  			   return "INVALID_PORT" when the entered port is not valid,
 *	  			   return "WRONG_PIN" when the entered pin is not valid,
 *	  			   return "UNKNOWN"	when there's unknown error.
 * ==================================================================== */
Std_Return MCAL_DIO_SetPinDirection(DIO_PinType DIO_Pin){
    3280:	df 93       	push	r29
    3282:	cf 93       	push	r28
    3284:	cd b7       	in	r28, 0x3d	; 61
    3286:	de b7       	in	r29, 0x3e	; 62
    3288:	2e 97       	sbiw	r28, 0x0e	; 14
    328a:	0f b6       	in	r0, 0x3f	; 63
    328c:	f8 94       	cli
    328e:	de bf       	out	0x3e, r29	; 62
    3290:	0f be       	out	0x3f, r0	; 63
    3292:	cd bf       	out	0x3d, r28	; 61
    3294:	6a 83       	std	Y+2, r22	; 0x02
    3296:	7b 83       	std	Y+3, r23	; 0x03
    3298:	8c 83       	std	Y+4, r24	; 0x04

	/*---------- Return Values ----------*/
	// Initialize error status with no errors
	Std_Return DIO_ReturnError = OK;
    329a:	19 82       	std	Y+1, r1	; 0x01

	// Check if there is any error in the parameter
	if(((DIO_Pin.Port) > Port_D) || ((DIO_Pin.Port) < 0)) DIO_ReturnError = INVALID_PORT;
    329c:	8a 81       	ldd	r24, Y+2	; 0x02
    329e:	84 30       	cpi	r24, 0x04	; 4
    32a0:	18 f0       	brcs	.+6      	; 0x32a8 <MCAL_DIO_SetPinDirection+0x28>
    32a2:	82 e0       	ldi	r24, 0x02	; 2
    32a4:	89 83       	std	Y+1, r24	; 0x01
    32a6:	0d c0       	rjmp	.+26     	; 0x32c2 <MCAL_DIO_SetPinDirection+0x42>
	else if(((DIO_Pin.Pin_Number) > 7) || ((DIO_Pin.Pin_Number) < 0)) DIO_ReturnError = WRONG_PIN;
    32a8:	8b 81       	ldd	r24, Y+3	; 0x03
    32aa:	88 30       	cpi	r24, 0x08	; 8
    32ac:	18 f0       	brcs	.+6      	; 0x32b4 <MCAL_DIO_SetPinDirection+0x34>
    32ae:	83 e0       	ldi	r24, 0x03	; 3
    32b0:	89 83       	std	Y+1, r24	; 0x01
    32b2:	07 c0       	rjmp	.+14     	; 0x32c2 <MCAL_DIO_SetPinDirection+0x42>
	else if((DIO_Pin.Port) <= Port_D) DIO_ReturnError = OK;
    32b4:	8a 81       	ldd	r24, Y+2	; 0x02
    32b6:	84 30       	cpi	r24, 0x04	; 4
    32b8:	10 f4       	brcc	.+4      	; 0x32be <MCAL_DIO_SetPinDirection+0x3e>
    32ba:	19 82       	std	Y+1, r1	; 0x01
    32bc:	02 c0       	rjmp	.+4      	; 0x32c2 <MCAL_DIO_SetPinDirection+0x42>
	else DIO_ReturnError = UNKNOWN;
    32be:	81 e0       	ldi	r24, 0x01	; 1
    32c0:	89 83       	std	Y+1, r24	; 0x01




	/*-------- Set Pin Direction -------*/
	if(DIO_ReturnError == OK) {
    32c2:	89 81       	ldd	r24, Y+1	; 0x01
    32c4:	88 23       	and	r24, r24
    32c6:	09 f0       	breq	.+2      	; 0x32ca <MCAL_DIO_SetPinDirection+0x4a>
    32c8:	00 c1       	rjmp	.+512    	; 0x34ca <MCAL_DIO_SetPinDirection+0x24a>
		switch(DIO_Pin.Port){
    32ca:	8a 81       	ldd	r24, Y+2	; 0x02
    32cc:	28 2f       	mov	r18, r24
    32ce:	30 e0       	ldi	r19, 0x00	; 0
    32d0:	3e 87       	std	Y+14, r19	; 0x0e
    32d2:	2d 87       	std	Y+13, r18	; 0x0d
    32d4:	8d 85       	ldd	r24, Y+13	; 0x0d
    32d6:	9e 85       	ldd	r25, Y+14	; 0x0e
    32d8:	81 30       	cpi	r24, 0x01	; 1
    32da:	91 05       	cpc	r25, r1
    32dc:	09 f4       	brne	.+2      	; 0x32e0 <MCAL_DIO_SetPinDirection+0x60>
    32de:	4f c0       	rjmp	.+158    	; 0x337e <MCAL_DIO_SetPinDirection+0xfe>
    32e0:	2d 85       	ldd	r18, Y+13	; 0x0d
    32e2:	3e 85       	ldd	r19, Y+14	; 0x0e
    32e4:	22 30       	cpi	r18, 0x02	; 2
    32e6:	31 05       	cpc	r19, r1
    32e8:	2c f4       	brge	.+10     	; 0x32f4 <MCAL_DIO_SetPinDirection+0x74>
    32ea:	8d 85       	ldd	r24, Y+13	; 0x0d
    32ec:	9e 85       	ldd	r25, Y+14	; 0x0e
    32ee:	00 97       	sbiw	r24, 0x00	; 0
    32f0:	71 f0       	breq	.+28     	; 0x330e <MCAL_DIO_SetPinDirection+0x8e>
    32f2:	eb c0       	rjmp	.+470    	; 0x34ca <MCAL_DIO_SetPinDirection+0x24a>
    32f4:	2d 85       	ldd	r18, Y+13	; 0x0d
    32f6:	3e 85       	ldd	r19, Y+14	; 0x0e
    32f8:	22 30       	cpi	r18, 0x02	; 2
    32fa:	31 05       	cpc	r19, r1
    32fc:	09 f4       	brne	.+2      	; 0x3300 <MCAL_DIO_SetPinDirection+0x80>
    32fe:	77 c0       	rjmp	.+238    	; 0x33ee <MCAL_DIO_SetPinDirection+0x16e>
    3300:	8d 85       	ldd	r24, Y+13	; 0x0d
    3302:	9e 85       	ldd	r25, Y+14	; 0x0e
    3304:	83 30       	cpi	r24, 0x03	; 3
    3306:	91 05       	cpc	r25, r1
    3308:	09 f4       	brne	.+2      	; 0x330c <MCAL_DIO_SetPinDirection+0x8c>
    330a:	a9 c0       	rjmp	.+338    	; 0x345e <MCAL_DIO_SetPinDirection+0x1de>
    330c:	de c0       	rjmp	.+444    	; 0x34ca <MCAL_DIO_SetPinDirection+0x24a>

		case Port_A:
			switch(DIO_Pin.Direction){
    330e:	8c 81       	ldd	r24, Y+4	; 0x04
    3310:	28 2f       	mov	r18, r24
    3312:	30 e0       	ldi	r19, 0x00	; 0
    3314:	3c 87       	std	Y+12, r19	; 0x0c
    3316:	2b 87       	std	Y+11, r18	; 0x0b
    3318:	8b 85       	ldd	r24, Y+11	; 0x0b
    331a:	9c 85       	ldd	r25, Y+12	; 0x0c
    331c:	00 97       	sbiw	r24, 0x00	; 0
    331e:	d1 f0       	breq	.+52     	; 0x3354 <MCAL_DIO_SetPinDirection+0xd4>
    3320:	2b 85       	ldd	r18, Y+11	; 0x0b
    3322:	3c 85       	ldd	r19, Y+12	; 0x0c
    3324:	21 30       	cpi	r18, 0x01	; 1
    3326:	31 05       	cpc	r19, r1
    3328:	09 f0       	breq	.+2      	; 0x332c <MCAL_DIO_SetPinDirection+0xac>
    332a:	cf c0       	rjmp	.+414    	; 0x34ca <MCAL_DIO_SetPinDirection+0x24a>
			case DIO_Output: SET_BIT(DDRA,DIO_Pin.Pin_Number); break;
    332c:	aa e3       	ldi	r26, 0x3A	; 58
    332e:	b0 e0       	ldi	r27, 0x00	; 0
    3330:	ea e3       	ldi	r30, 0x3A	; 58
    3332:	f0 e0       	ldi	r31, 0x00	; 0
    3334:	80 81       	ld	r24, Z
    3336:	48 2f       	mov	r20, r24
    3338:	8b 81       	ldd	r24, Y+3	; 0x03
    333a:	28 2f       	mov	r18, r24
    333c:	30 e0       	ldi	r19, 0x00	; 0
    333e:	81 e0       	ldi	r24, 0x01	; 1
    3340:	90 e0       	ldi	r25, 0x00	; 0
    3342:	02 2e       	mov	r0, r18
    3344:	02 c0       	rjmp	.+4      	; 0x334a <MCAL_DIO_SetPinDirection+0xca>
    3346:	88 0f       	add	r24, r24
    3348:	99 1f       	adc	r25, r25
    334a:	0a 94       	dec	r0
    334c:	e2 f7       	brpl	.-8      	; 0x3346 <MCAL_DIO_SetPinDirection+0xc6>
    334e:	84 2b       	or	r24, r20
    3350:	8c 93       	st	X, r24
    3352:	bb c0       	rjmp	.+374    	; 0x34ca <MCAL_DIO_SetPinDirection+0x24a>
			case DIO_Input:	CLR_BIT(DDRA,DIO_Pin.Pin_Number); break;
    3354:	aa e3       	ldi	r26, 0x3A	; 58
    3356:	b0 e0       	ldi	r27, 0x00	; 0
    3358:	ea e3       	ldi	r30, 0x3A	; 58
    335a:	f0 e0       	ldi	r31, 0x00	; 0
    335c:	80 81       	ld	r24, Z
    335e:	48 2f       	mov	r20, r24
    3360:	8b 81       	ldd	r24, Y+3	; 0x03
    3362:	28 2f       	mov	r18, r24
    3364:	30 e0       	ldi	r19, 0x00	; 0
    3366:	81 e0       	ldi	r24, 0x01	; 1
    3368:	90 e0       	ldi	r25, 0x00	; 0
    336a:	02 2e       	mov	r0, r18
    336c:	02 c0       	rjmp	.+4      	; 0x3372 <MCAL_DIO_SetPinDirection+0xf2>
    336e:	88 0f       	add	r24, r24
    3370:	99 1f       	adc	r25, r25
    3372:	0a 94       	dec	r0
    3374:	e2 f7       	brpl	.-8      	; 0x336e <MCAL_DIO_SetPinDirection+0xee>
    3376:	80 95       	com	r24
    3378:	84 23       	and	r24, r20
    337a:	8c 93       	st	X, r24
    337c:	a6 c0       	rjmp	.+332    	; 0x34ca <MCAL_DIO_SetPinDirection+0x24a>
			}
			break;

		case Port_B:
			switch(DIO_Pin.Direction){
    337e:	8c 81       	ldd	r24, Y+4	; 0x04
    3380:	28 2f       	mov	r18, r24
    3382:	30 e0       	ldi	r19, 0x00	; 0
    3384:	3a 87       	std	Y+10, r19	; 0x0a
    3386:	29 87       	std	Y+9, r18	; 0x09
    3388:	89 85       	ldd	r24, Y+9	; 0x09
    338a:	9a 85       	ldd	r25, Y+10	; 0x0a
    338c:	00 97       	sbiw	r24, 0x00	; 0
    338e:	d1 f0       	breq	.+52     	; 0x33c4 <MCAL_DIO_SetPinDirection+0x144>
    3390:	29 85       	ldd	r18, Y+9	; 0x09
    3392:	3a 85       	ldd	r19, Y+10	; 0x0a
    3394:	21 30       	cpi	r18, 0x01	; 1
    3396:	31 05       	cpc	r19, r1
    3398:	09 f0       	breq	.+2      	; 0x339c <MCAL_DIO_SetPinDirection+0x11c>
    339a:	97 c0       	rjmp	.+302    	; 0x34ca <MCAL_DIO_SetPinDirection+0x24a>
			case DIO_Output: SET_BIT(DDRB,DIO_Pin.Pin_Number); break;
    339c:	a7 e3       	ldi	r26, 0x37	; 55
    339e:	b0 e0       	ldi	r27, 0x00	; 0
    33a0:	e7 e3       	ldi	r30, 0x37	; 55
    33a2:	f0 e0       	ldi	r31, 0x00	; 0
    33a4:	80 81       	ld	r24, Z
    33a6:	48 2f       	mov	r20, r24
    33a8:	8b 81       	ldd	r24, Y+3	; 0x03
    33aa:	28 2f       	mov	r18, r24
    33ac:	30 e0       	ldi	r19, 0x00	; 0
    33ae:	81 e0       	ldi	r24, 0x01	; 1
    33b0:	90 e0       	ldi	r25, 0x00	; 0
    33b2:	02 2e       	mov	r0, r18
    33b4:	02 c0       	rjmp	.+4      	; 0x33ba <MCAL_DIO_SetPinDirection+0x13a>
    33b6:	88 0f       	add	r24, r24
    33b8:	99 1f       	adc	r25, r25
    33ba:	0a 94       	dec	r0
    33bc:	e2 f7       	brpl	.-8      	; 0x33b6 <MCAL_DIO_SetPinDirection+0x136>
    33be:	84 2b       	or	r24, r20
    33c0:	8c 93       	st	X, r24
    33c2:	83 c0       	rjmp	.+262    	; 0x34ca <MCAL_DIO_SetPinDirection+0x24a>
			case DIO_Input:	CLR_BIT(DDRB,DIO_Pin.Pin_Number); break;
    33c4:	a7 e3       	ldi	r26, 0x37	; 55
    33c6:	b0 e0       	ldi	r27, 0x00	; 0
    33c8:	e7 e3       	ldi	r30, 0x37	; 55
    33ca:	f0 e0       	ldi	r31, 0x00	; 0
    33cc:	80 81       	ld	r24, Z
    33ce:	48 2f       	mov	r20, r24
    33d0:	8b 81       	ldd	r24, Y+3	; 0x03
    33d2:	28 2f       	mov	r18, r24
    33d4:	30 e0       	ldi	r19, 0x00	; 0
    33d6:	81 e0       	ldi	r24, 0x01	; 1
    33d8:	90 e0       	ldi	r25, 0x00	; 0
    33da:	02 2e       	mov	r0, r18
    33dc:	02 c0       	rjmp	.+4      	; 0x33e2 <MCAL_DIO_SetPinDirection+0x162>
    33de:	88 0f       	add	r24, r24
    33e0:	99 1f       	adc	r25, r25
    33e2:	0a 94       	dec	r0
    33e4:	e2 f7       	brpl	.-8      	; 0x33de <MCAL_DIO_SetPinDirection+0x15e>
    33e6:	80 95       	com	r24
    33e8:	84 23       	and	r24, r20
    33ea:	8c 93       	st	X, r24
    33ec:	6e c0       	rjmp	.+220    	; 0x34ca <MCAL_DIO_SetPinDirection+0x24a>
			}
			break;

		case Port_C:
			switch(DIO_Pin.Direction){
    33ee:	8c 81       	ldd	r24, Y+4	; 0x04
    33f0:	28 2f       	mov	r18, r24
    33f2:	30 e0       	ldi	r19, 0x00	; 0
    33f4:	38 87       	std	Y+8, r19	; 0x08
    33f6:	2f 83       	std	Y+7, r18	; 0x07
    33f8:	8f 81       	ldd	r24, Y+7	; 0x07
    33fa:	98 85       	ldd	r25, Y+8	; 0x08
    33fc:	00 97       	sbiw	r24, 0x00	; 0
    33fe:	d1 f0       	breq	.+52     	; 0x3434 <MCAL_DIO_SetPinDirection+0x1b4>
    3400:	2f 81       	ldd	r18, Y+7	; 0x07
    3402:	38 85       	ldd	r19, Y+8	; 0x08
    3404:	21 30       	cpi	r18, 0x01	; 1
    3406:	31 05       	cpc	r19, r1
    3408:	09 f0       	breq	.+2      	; 0x340c <MCAL_DIO_SetPinDirection+0x18c>
    340a:	5f c0       	rjmp	.+190    	; 0x34ca <MCAL_DIO_SetPinDirection+0x24a>
			case DIO_Output: SET_BIT(DDRC,DIO_Pin.Pin_Number); break;
    340c:	a4 e3       	ldi	r26, 0x34	; 52
    340e:	b0 e0       	ldi	r27, 0x00	; 0
    3410:	e4 e3       	ldi	r30, 0x34	; 52
    3412:	f0 e0       	ldi	r31, 0x00	; 0
    3414:	80 81       	ld	r24, Z
    3416:	48 2f       	mov	r20, r24
    3418:	8b 81       	ldd	r24, Y+3	; 0x03
    341a:	28 2f       	mov	r18, r24
    341c:	30 e0       	ldi	r19, 0x00	; 0
    341e:	81 e0       	ldi	r24, 0x01	; 1
    3420:	90 e0       	ldi	r25, 0x00	; 0
    3422:	02 2e       	mov	r0, r18
    3424:	02 c0       	rjmp	.+4      	; 0x342a <MCAL_DIO_SetPinDirection+0x1aa>
    3426:	88 0f       	add	r24, r24
    3428:	99 1f       	adc	r25, r25
    342a:	0a 94       	dec	r0
    342c:	e2 f7       	brpl	.-8      	; 0x3426 <MCAL_DIO_SetPinDirection+0x1a6>
    342e:	84 2b       	or	r24, r20
    3430:	8c 93       	st	X, r24
    3432:	4b c0       	rjmp	.+150    	; 0x34ca <MCAL_DIO_SetPinDirection+0x24a>
			case DIO_Input:	CLR_BIT(DDRC,DIO_Pin.Pin_Number); break;
    3434:	a4 e3       	ldi	r26, 0x34	; 52
    3436:	b0 e0       	ldi	r27, 0x00	; 0
    3438:	e4 e3       	ldi	r30, 0x34	; 52
    343a:	f0 e0       	ldi	r31, 0x00	; 0
    343c:	80 81       	ld	r24, Z
    343e:	48 2f       	mov	r20, r24
    3440:	8b 81       	ldd	r24, Y+3	; 0x03
    3442:	28 2f       	mov	r18, r24
    3444:	30 e0       	ldi	r19, 0x00	; 0
    3446:	81 e0       	ldi	r24, 0x01	; 1
    3448:	90 e0       	ldi	r25, 0x00	; 0
    344a:	02 2e       	mov	r0, r18
    344c:	02 c0       	rjmp	.+4      	; 0x3452 <MCAL_DIO_SetPinDirection+0x1d2>
    344e:	88 0f       	add	r24, r24
    3450:	99 1f       	adc	r25, r25
    3452:	0a 94       	dec	r0
    3454:	e2 f7       	brpl	.-8      	; 0x344e <MCAL_DIO_SetPinDirection+0x1ce>
    3456:	80 95       	com	r24
    3458:	84 23       	and	r24, r20
    345a:	8c 93       	st	X, r24
    345c:	36 c0       	rjmp	.+108    	; 0x34ca <MCAL_DIO_SetPinDirection+0x24a>
			}
			break;

		case Port_D:
			switch(DIO_Pin.Direction){
    345e:	8c 81       	ldd	r24, Y+4	; 0x04
    3460:	28 2f       	mov	r18, r24
    3462:	30 e0       	ldi	r19, 0x00	; 0
    3464:	3e 83       	std	Y+6, r19	; 0x06
    3466:	2d 83       	std	Y+5, r18	; 0x05
    3468:	8d 81       	ldd	r24, Y+5	; 0x05
    346a:	9e 81       	ldd	r25, Y+6	; 0x06
    346c:	00 97       	sbiw	r24, 0x00	; 0
    346e:	c9 f0       	breq	.+50     	; 0x34a2 <MCAL_DIO_SetPinDirection+0x222>
    3470:	2d 81       	ldd	r18, Y+5	; 0x05
    3472:	3e 81       	ldd	r19, Y+6	; 0x06
    3474:	21 30       	cpi	r18, 0x01	; 1
    3476:	31 05       	cpc	r19, r1
    3478:	41 f5       	brne	.+80     	; 0x34ca <MCAL_DIO_SetPinDirection+0x24a>
			case DIO_Output: SET_BIT(DDRD,DIO_Pin.Pin_Number); break;
    347a:	a1 e3       	ldi	r26, 0x31	; 49
    347c:	b0 e0       	ldi	r27, 0x00	; 0
    347e:	e1 e3       	ldi	r30, 0x31	; 49
    3480:	f0 e0       	ldi	r31, 0x00	; 0
    3482:	80 81       	ld	r24, Z
    3484:	48 2f       	mov	r20, r24
    3486:	8b 81       	ldd	r24, Y+3	; 0x03
    3488:	28 2f       	mov	r18, r24
    348a:	30 e0       	ldi	r19, 0x00	; 0
    348c:	81 e0       	ldi	r24, 0x01	; 1
    348e:	90 e0       	ldi	r25, 0x00	; 0
    3490:	02 2e       	mov	r0, r18
    3492:	02 c0       	rjmp	.+4      	; 0x3498 <MCAL_DIO_SetPinDirection+0x218>
    3494:	88 0f       	add	r24, r24
    3496:	99 1f       	adc	r25, r25
    3498:	0a 94       	dec	r0
    349a:	e2 f7       	brpl	.-8      	; 0x3494 <MCAL_DIO_SetPinDirection+0x214>
    349c:	84 2b       	or	r24, r20
    349e:	8c 93       	st	X, r24
    34a0:	14 c0       	rjmp	.+40     	; 0x34ca <MCAL_DIO_SetPinDirection+0x24a>
			case DIO_Input: CLR_BIT(DDRD,DIO_Pin.Pin_Number); break;
    34a2:	a1 e3       	ldi	r26, 0x31	; 49
    34a4:	b0 e0       	ldi	r27, 0x00	; 0
    34a6:	e1 e3       	ldi	r30, 0x31	; 49
    34a8:	f0 e0       	ldi	r31, 0x00	; 0
    34aa:	80 81       	ld	r24, Z
    34ac:	48 2f       	mov	r20, r24
    34ae:	8b 81       	ldd	r24, Y+3	; 0x03
    34b0:	28 2f       	mov	r18, r24
    34b2:	30 e0       	ldi	r19, 0x00	; 0
    34b4:	81 e0       	ldi	r24, 0x01	; 1
    34b6:	90 e0       	ldi	r25, 0x00	; 0
    34b8:	02 2e       	mov	r0, r18
    34ba:	02 c0       	rjmp	.+4      	; 0x34c0 <MCAL_DIO_SetPinDirection+0x240>
    34bc:	88 0f       	add	r24, r24
    34be:	99 1f       	adc	r25, r25
    34c0:	0a 94       	dec	r0
    34c2:	e2 f7       	brpl	.-8      	; 0x34bc <MCAL_DIO_SetPinDirection+0x23c>
    34c4:	80 95       	com	r24
    34c6:	84 23       	and	r24, r20
    34c8:	8c 93       	st	X, r24
			break;

		}
	}

	return DIO_ReturnError;
    34ca:	89 81       	ldd	r24, Y+1	; 0x01

}
    34cc:	2e 96       	adiw	r28, 0x0e	; 14
    34ce:	0f b6       	in	r0, 0x3f	; 63
    34d0:	f8 94       	cli
    34d2:	de bf       	out	0x3e, r29	; 62
    34d4:	0f be       	out	0x3f, r0	; 63
    34d6:	cd bf       	out	0x3d, r28	; 61
    34d8:	cf 91       	pop	r28
    34da:	df 91       	pop	r29
    34dc:	08 95       	ret

000034de <MCAL_DIO_WritePort>:
 * 	@ RetVal	 - Std_Return.
 *	  Note		 - This API return "OK" when no error occurred,
 *	  			   return "INVALID_PORT" when the entered port is not valid
 *	  			   return "UNKNOWN"	when there's unknown error
 * ==================================================================== */
Std_Return MCAL_DIO_WritePort(DIO_PortType DIO_Port, DIO_StatusType DIO_PortStatus){
    34de:	df 93       	push	r29
    34e0:	cf 93       	push	r28
    34e2:	00 d0       	rcall	.+0      	; 0x34e4 <MCAL_DIO_WritePort+0x6>
    34e4:	00 d0       	rcall	.+0      	; 0x34e6 <MCAL_DIO_WritePort+0x8>
    34e6:	00 d0       	rcall	.+0      	; 0x34e8 <MCAL_DIO_WritePort+0xa>
    34e8:	cd b7       	in	r28, 0x3d	; 61
    34ea:	de b7       	in	r29, 0x3e	; 62
    34ec:	9b 83       	std	Y+3, r25	; 0x03
    34ee:	8a 83       	std	Y+2, r24	; 0x02
    34f0:	6c 83       	std	Y+4, r22	; 0x04

	/*---------- Return Values ----------*/
	// Initialize error status with no errors
	Std_Return DIO_ReturnError = OK;
    34f2:	19 82       	std	Y+1, r1	; 0x01

	// Check if there is any errors in the parameter
	if(((DIO_Port.Port) > Port_D) || ((DIO_Port.Port) < 0)) DIO_ReturnError = INVALID_PORT;
    34f4:	8a 81       	ldd	r24, Y+2	; 0x02
    34f6:	84 30       	cpi	r24, 0x04	; 4
    34f8:	18 f0       	brcs	.+6      	; 0x3500 <MCAL_DIO_WritePort+0x22>
    34fa:	82 e0       	ldi	r24, 0x02	; 2
    34fc:	89 83       	std	Y+1, r24	; 0x01
    34fe:	07 c0       	rjmp	.+14     	; 0x350e <MCAL_DIO_WritePort+0x30>
	else if((DIO_Port.Port) <= Port_D) DIO_ReturnError = OK;
    3500:	8a 81       	ldd	r24, Y+2	; 0x02
    3502:	84 30       	cpi	r24, 0x04	; 4
    3504:	10 f4       	brcc	.+4      	; 0x350a <MCAL_DIO_WritePort+0x2c>
    3506:	19 82       	std	Y+1, r1	; 0x01
    3508:	02 c0       	rjmp	.+4      	; 0x350e <MCAL_DIO_WritePort+0x30>
	else DIO_ReturnError = UNKNOWN;
    350a:	81 e0       	ldi	r24, 0x01	; 1
    350c:	89 83       	std	Y+1, r24	; 0x01




	/*-------- Write Port Status -------*/
	if(DIO_PortStatus == DIO_Set) DIO_PortStatus = 0xFF;
    350e:	8c 81       	ldd	r24, Y+4	; 0x04
    3510:	81 30       	cpi	r24, 0x01	; 1
    3512:	11 f4       	brne	.+4      	; 0x3518 <MCAL_DIO_WritePort+0x3a>
    3514:	8f ef       	ldi	r24, 0xFF	; 255
    3516:	8c 83       	std	Y+4, r24	; 0x04
	if(DIO_ReturnError == OK) {
    3518:	89 81       	ldd	r24, Y+1	; 0x01
    351a:	88 23       	and	r24, r24
    351c:	91 f5       	brne	.+100    	; 0x3582 <MCAL_DIO_WritePort+0xa4>
		switch(DIO_Port.Port){
    351e:	8a 81       	ldd	r24, Y+2	; 0x02
    3520:	28 2f       	mov	r18, r24
    3522:	30 e0       	ldi	r19, 0x00	; 0
    3524:	3e 83       	std	Y+6, r19	; 0x06
    3526:	2d 83       	std	Y+5, r18	; 0x05
    3528:	8d 81       	ldd	r24, Y+5	; 0x05
    352a:	9e 81       	ldd	r25, Y+6	; 0x06
    352c:	81 30       	cpi	r24, 0x01	; 1
    352e:	91 05       	cpc	r25, r1
    3530:	d1 f0       	breq	.+52     	; 0x3566 <MCAL_DIO_WritePort+0x88>
    3532:	2d 81       	ldd	r18, Y+5	; 0x05
    3534:	3e 81       	ldd	r19, Y+6	; 0x06
    3536:	22 30       	cpi	r18, 0x02	; 2
    3538:	31 05       	cpc	r19, r1
    353a:	2c f4       	brge	.+10     	; 0x3546 <MCAL_DIO_WritePort+0x68>
    353c:	8d 81       	ldd	r24, Y+5	; 0x05
    353e:	9e 81       	ldd	r25, Y+6	; 0x06
    3540:	00 97       	sbiw	r24, 0x00	; 0
    3542:	61 f0       	breq	.+24     	; 0x355c <MCAL_DIO_WritePort+0x7e>
    3544:	1e c0       	rjmp	.+60     	; 0x3582 <MCAL_DIO_WritePort+0xa4>
    3546:	2d 81       	ldd	r18, Y+5	; 0x05
    3548:	3e 81       	ldd	r19, Y+6	; 0x06
    354a:	22 30       	cpi	r18, 0x02	; 2
    354c:	31 05       	cpc	r19, r1
    354e:	81 f0       	breq	.+32     	; 0x3570 <MCAL_DIO_WritePort+0x92>
    3550:	8d 81       	ldd	r24, Y+5	; 0x05
    3552:	9e 81       	ldd	r25, Y+6	; 0x06
    3554:	83 30       	cpi	r24, 0x03	; 3
    3556:	91 05       	cpc	r25, r1
    3558:	81 f0       	breq	.+32     	; 0x357a <MCAL_DIO_WritePort+0x9c>
    355a:	13 c0       	rjmp	.+38     	; 0x3582 <MCAL_DIO_WritePort+0xa4>

		case Port_A: PORTA = DIO_PortStatus; break;
    355c:	eb e3       	ldi	r30, 0x3B	; 59
    355e:	f0 e0       	ldi	r31, 0x00	; 0
    3560:	8c 81       	ldd	r24, Y+4	; 0x04
    3562:	80 83       	st	Z, r24
    3564:	0e c0       	rjmp	.+28     	; 0x3582 <MCAL_DIO_WritePort+0xa4>
		case Port_B: PORTB = DIO_PortStatus; break;
    3566:	e8 e3       	ldi	r30, 0x38	; 56
    3568:	f0 e0       	ldi	r31, 0x00	; 0
    356a:	8c 81       	ldd	r24, Y+4	; 0x04
    356c:	80 83       	st	Z, r24
    356e:	09 c0       	rjmp	.+18     	; 0x3582 <MCAL_DIO_WritePort+0xa4>
		case Port_C: PORTC = DIO_PortStatus; break;
    3570:	e5 e3       	ldi	r30, 0x35	; 53
    3572:	f0 e0       	ldi	r31, 0x00	; 0
    3574:	8c 81       	ldd	r24, Y+4	; 0x04
    3576:	80 83       	st	Z, r24
    3578:	04 c0       	rjmp	.+8      	; 0x3582 <MCAL_DIO_WritePort+0xa4>
		case Port_D: PORTD = DIO_PortStatus; break;
    357a:	e2 e3       	ldi	r30, 0x32	; 50
    357c:	f0 e0       	ldi	r31, 0x00	; 0
    357e:	8c 81       	ldd	r24, Y+4	; 0x04
    3580:	80 83       	st	Z, r24

		}
	}

	return DIO_ReturnError;
    3582:	89 81       	ldd	r24, Y+1	; 0x01

}
    3584:	26 96       	adiw	r28, 0x06	; 6
    3586:	0f b6       	in	r0, 0x3f	; 63
    3588:	f8 94       	cli
    358a:	de bf       	out	0x3e, r29	; 62
    358c:	0f be       	out	0x3f, r0	; 63
    358e:	cd bf       	out	0x3d, r28	; 61
    3590:	cf 91       	pop	r28
    3592:	df 91       	pop	r29
    3594:	08 95       	ret

00003596 <MCAL_DIO_WritePin>:
 *	  Note		 - This API return "OK" when no error occurred,
 *	  			   return "INVALID_PORT" when the entered port is not valid,
 *	  			   return "WRONG_PIN" when the entered pin is not valid,
 *	  			   return "UNKNOWN"	when there's unknown error.
 * ==================================================================== */
Std_Return MCAL_DIO_WritePin(DIO_PinType DIO_Pin, DIO_StatusType DIO_PinStatus){
    3596:	df 93       	push	r29
    3598:	cf 93       	push	r28
    359a:	cd b7       	in	r28, 0x3d	; 61
    359c:	de b7       	in	r29, 0x3e	; 62
    359e:	2f 97       	sbiw	r28, 0x0f	; 15
    35a0:	0f b6       	in	r0, 0x3f	; 63
    35a2:	f8 94       	cli
    35a4:	de bf       	out	0x3e, r29	; 62
    35a6:	0f be       	out	0x3f, r0	; 63
    35a8:	cd bf       	out	0x3d, r28	; 61
    35aa:	6a 83       	std	Y+2, r22	; 0x02
    35ac:	7b 83       	std	Y+3, r23	; 0x03
    35ae:	8c 83       	std	Y+4, r24	; 0x04
    35b0:	4d 83       	std	Y+5, r20	; 0x05

	/*---------- Return Values ----------*/
	// Initialize error status with no errors
	Std_Return DIO_ReturnError = OK;
    35b2:	19 82       	std	Y+1, r1	; 0x01

	// Check if there is any error in the parameter
	if(((DIO_Pin.Port) > Port_D) || ((DIO_Pin.Port) < 0)) DIO_ReturnError = INVALID_PORT;
    35b4:	8a 81       	ldd	r24, Y+2	; 0x02
    35b6:	84 30       	cpi	r24, 0x04	; 4
    35b8:	18 f0       	brcs	.+6      	; 0x35c0 <MCAL_DIO_WritePin+0x2a>
    35ba:	82 e0       	ldi	r24, 0x02	; 2
    35bc:	89 83       	std	Y+1, r24	; 0x01
    35be:	0d c0       	rjmp	.+26     	; 0x35da <MCAL_DIO_WritePin+0x44>
	else if(((DIO_Pin.Pin_Number) > 7) || ((DIO_Pin.Pin_Number) < 0)) DIO_ReturnError = WRONG_PIN;
    35c0:	8b 81       	ldd	r24, Y+3	; 0x03
    35c2:	88 30       	cpi	r24, 0x08	; 8
    35c4:	18 f0       	brcs	.+6      	; 0x35cc <MCAL_DIO_WritePin+0x36>
    35c6:	83 e0       	ldi	r24, 0x03	; 3
    35c8:	89 83       	std	Y+1, r24	; 0x01
    35ca:	07 c0       	rjmp	.+14     	; 0x35da <MCAL_DIO_WritePin+0x44>
	else if((DIO_Pin.Port) <= Port_D) DIO_ReturnError = OK;
    35cc:	8a 81       	ldd	r24, Y+2	; 0x02
    35ce:	84 30       	cpi	r24, 0x04	; 4
    35d0:	10 f4       	brcc	.+4      	; 0x35d6 <MCAL_DIO_WritePin+0x40>
    35d2:	19 82       	std	Y+1, r1	; 0x01
    35d4:	02 c0       	rjmp	.+4      	; 0x35da <MCAL_DIO_WritePin+0x44>
	else DIO_ReturnError = UNKNOWN;
    35d6:	81 e0       	ldi	r24, 0x01	; 1
    35d8:	89 83       	std	Y+1, r24	; 0x01




	/*--------- Write Pin Status --------*/
	if(DIO_ReturnError == OK) {
    35da:	89 81       	ldd	r24, Y+1	; 0x01
    35dc:	88 23       	and	r24, r24
    35de:	09 f0       	breq	.+2      	; 0x35e2 <MCAL_DIO_WritePin+0x4c>
    35e0:	00 c1       	rjmp	.+512    	; 0x37e2 <MCAL_DIO_WritePin+0x24c>
		switch(DIO_Pin.Port){
    35e2:	8a 81       	ldd	r24, Y+2	; 0x02
    35e4:	28 2f       	mov	r18, r24
    35e6:	30 e0       	ldi	r19, 0x00	; 0
    35e8:	3f 87       	std	Y+15, r19	; 0x0f
    35ea:	2e 87       	std	Y+14, r18	; 0x0e
    35ec:	8e 85       	ldd	r24, Y+14	; 0x0e
    35ee:	9f 85       	ldd	r25, Y+15	; 0x0f
    35f0:	81 30       	cpi	r24, 0x01	; 1
    35f2:	91 05       	cpc	r25, r1
    35f4:	09 f4       	brne	.+2      	; 0x35f8 <MCAL_DIO_WritePin+0x62>
    35f6:	4f c0       	rjmp	.+158    	; 0x3696 <MCAL_DIO_WritePin+0x100>
    35f8:	2e 85       	ldd	r18, Y+14	; 0x0e
    35fa:	3f 85       	ldd	r19, Y+15	; 0x0f
    35fc:	22 30       	cpi	r18, 0x02	; 2
    35fe:	31 05       	cpc	r19, r1
    3600:	2c f4       	brge	.+10     	; 0x360c <MCAL_DIO_WritePin+0x76>
    3602:	8e 85       	ldd	r24, Y+14	; 0x0e
    3604:	9f 85       	ldd	r25, Y+15	; 0x0f
    3606:	00 97       	sbiw	r24, 0x00	; 0
    3608:	71 f0       	breq	.+28     	; 0x3626 <MCAL_DIO_WritePin+0x90>
    360a:	eb c0       	rjmp	.+470    	; 0x37e2 <MCAL_DIO_WritePin+0x24c>
    360c:	2e 85       	ldd	r18, Y+14	; 0x0e
    360e:	3f 85       	ldd	r19, Y+15	; 0x0f
    3610:	22 30       	cpi	r18, 0x02	; 2
    3612:	31 05       	cpc	r19, r1
    3614:	09 f4       	brne	.+2      	; 0x3618 <MCAL_DIO_WritePin+0x82>
    3616:	77 c0       	rjmp	.+238    	; 0x3706 <MCAL_DIO_WritePin+0x170>
    3618:	8e 85       	ldd	r24, Y+14	; 0x0e
    361a:	9f 85       	ldd	r25, Y+15	; 0x0f
    361c:	83 30       	cpi	r24, 0x03	; 3
    361e:	91 05       	cpc	r25, r1
    3620:	09 f4       	brne	.+2      	; 0x3624 <MCAL_DIO_WritePin+0x8e>
    3622:	a9 c0       	rjmp	.+338    	; 0x3776 <MCAL_DIO_WritePin+0x1e0>
    3624:	de c0       	rjmp	.+444    	; 0x37e2 <MCAL_DIO_WritePin+0x24c>

		case Port_A:
			switch(DIO_PinStatus){
    3626:	8d 81       	ldd	r24, Y+5	; 0x05
    3628:	28 2f       	mov	r18, r24
    362a:	30 e0       	ldi	r19, 0x00	; 0
    362c:	3d 87       	std	Y+13, r19	; 0x0d
    362e:	2c 87       	std	Y+12, r18	; 0x0c
    3630:	8c 85       	ldd	r24, Y+12	; 0x0c
    3632:	9d 85       	ldd	r25, Y+13	; 0x0d
    3634:	00 97       	sbiw	r24, 0x00	; 0
    3636:	d1 f0       	breq	.+52     	; 0x366c <MCAL_DIO_WritePin+0xd6>
    3638:	2c 85       	ldd	r18, Y+12	; 0x0c
    363a:	3d 85       	ldd	r19, Y+13	; 0x0d
    363c:	21 30       	cpi	r18, 0x01	; 1
    363e:	31 05       	cpc	r19, r1
    3640:	09 f0       	breq	.+2      	; 0x3644 <MCAL_DIO_WritePin+0xae>
    3642:	cf c0       	rjmp	.+414    	; 0x37e2 <MCAL_DIO_WritePin+0x24c>
			case DIO_Set: SET_BIT(PORTA,DIO_Pin.Pin_Number); break;
    3644:	ab e3       	ldi	r26, 0x3B	; 59
    3646:	b0 e0       	ldi	r27, 0x00	; 0
    3648:	eb e3       	ldi	r30, 0x3B	; 59
    364a:	f0 e0       	ldi	r31, 0x00	; 0
    364c:	80 81       	ld	r24, Z
    364e:	48 2f       	mov	r20, r24
    3650:	8b 81       	ldd	r24, Y+3	; 0x03
    3652:	28 2f       	mov	r18, r24
    3654:	30 e0       	ldi	r19, 0x00	; 0
    3656:	81 e0       	ldi	r24, 0x01	; 1
    3658:	90 e0       	ldi	r25, 0x00	; 0
    365a:	02 2e       	mov	r0, r18
    365c:	02 c0       	rjmp	.+4      	; 0x3662 <MCAL_DIO_WritePin+0xcc>
    365e:	88 0f       	add	r24, r24
    3660:	99 1f       	adc	r25, r25
    3662:	0a 94       	dec	r0
    3664:	e2 f7       	brpl	.-8      	; 0x365e <MCAL_DIO_WritePin+0xc8>
    3666:	84 2b       	or	r24, r20
    3668:	8c 93       	st	X, r24
    366a:	bb c0       	rjmp	.+374    	; 0x37e2 <MCAL_DIO_WritePin+0x24c>
			case DIO_Reset: CLR_BIT(PORTA,DIO_Pin.Pin_Number); break;
    366c:	ab e3       	ldi	r26, 0x3B	; 59
    366e:	b0 e0       	ldi	r27, 0x00	; 0
    3670:	eb e3       	ldi	r30, 0x3B	; 59
    3672:	f0 e0       	ldi	r31, 0x00	; 0
    3674:	80 81       	ld	r24, Z
    3676:	48 2f       	mov	r20, r24
    3678:	8b 81       	ldd	r24, Y+3	; 0x03
    367a:	28 2f       	mov	r18, r24
    367c:	30 e0       	ldi	r19, 0x00	; 0
    367e:	81 e0       	ldi	r24, 0x01	; 1
    3680:	90 e0       	ldi	r25, 0x00	; 0
    3682:	02 2e       	mov	r0, r18
    3684:	02 c0       	rjmp	.+4      	; 0x368a <MCAL_DIO_WritePin+0xf4>
    3686:	88 0f       	add	r24, r24
    3688:	99 1f       	adc	r25, r25
    368a:	0a 94       	dec	r0
    368c:	e2 f7       	brpl	.-8      	; 0x3686 <MCAL_DIO_WritePin+0xf0>
    368e:	80 95       	com	r24
    3690:	84 23       	and	r24, r20
    3692:	8c 93       	st	X, r24
    3694:	a6 c0       	rjmp	.+332    	; 0x37e2 <MCAL_DIO_WritePin+0x24c>
			}
			break;

		case Port_B:
			switch(DIO_PinStatus){
    3696:	8d 81       	ldd	r24, Y+5	; 0x05
    3698:	28 2f       	mov	r18, r24
    369a:	30 e0       	ldi	r19, 0x00	; 0
    369c:	3b 87       	std	Y+11, r19	; 0x0b
    369e:	2a 87       	std	Y+10, r18	; 0x0a
    36a0:	8a 85       	ldd	r24, Y+10	; 0x0a
    36a2:	9b 85       	ldd	r25, Y+11	; 0x0b
    36a4:	00 97       	sbiw	r24, 0x00	; 0
    36a6:	d1 f0       	breq	.+52     	; 0x36dc <MCAL_DIO_WritePin+0x146>
    36a8:	2a 85       	ldd	r18, Y+10	; 0x0a
    36aa:	3b 85       	ldd	r19, Y+11	; 0x0b
    36ac:	21 30       	cpi	r18, 0x01	; 1
    36ae:	31 05       	cpc	r19, r1
    36b0:	09 f0       	breq	.+2      	; 0x36b4 <MCAL_DIO_WritePin+0x11e>
    36b2:	97 c0       	rjmp	.+302    	; 0x37e2 <MCAL_DIO_WritePin+0x24c>
			case DIO_Set: SET_BIT(PORTB,DIO_Pin.Pin_Number); break;
    36b4:	a8 e3       	ldi	r26, 0x38	; 56
    36b6:	b0 e0       	ldi	r27, 0x00	; 0
    36b8:	e8 e3       	ldi	r30, 0x38	; 56
    36ba:	f0 e0       	ldi	r31, 0x00	; 0
    36bc:	80 81       	ld	r24, Z
    36be:	48 2f       	mov	r20, r24
    36c0:	8b 81       	ldd	r24, Y+3	; 0x03
    36c2:	28 2f       	mov	r18, r24
    36c4:	30 e0       	ldi	r19, 0x00	; 0
    36c6:	81 e0       	ldi	r24, 0x01	; 1
    36c8:	90 e0       	ldi	r25, 0x00	; 0
    36ca:	02 2e       	mov	r0, r18
    36cc:	02 c0       	rjmp	.+4      	; 0x36d2 <MCAL_DIO_WritePin+0x13c>
    36ce:	88 0f       	add	r24, r24
    36d0:	99 1f       	adc	r25, r25
    36d2:	0a 94       	dec	r0
    36d4:	e2 f7       	brpl	.-8      	; 0x36ce <MCAL_DIO_WritePin+0x138>
    36d6:	84 2b       	or	r24, r20
    36d8:	8c 93       	st	X, r24
    36da:	83 c0       	rjmp	.+262    	; 0x37e2 <MCAL_DIO_WritePin+0x24c>
			case DIO_Reset: CLR_BIT(PORTB,DIO_Pin.Pin_Number); break;
    36dc:	a8 e3       	ldi	r26, 0x38	; 56
    36de:	b0 e0       	ldi	r27, 0x00	; 0
    36e0:	e8 e3       	ldi	r30, 0x38	; 56
    36e2:	f0 e0       	ldi	r31, 0x00	; 0
    36e4:	80 81       	ld	r24, Z
    36e6:	48 2f       	mov	r20, r24
    36e8:	8b 81       	ldd	r24, Y+3	; 0x03
    36ea:	28 2f       	mov	r18, r24
    36ec:	30 e0       	ldi	r19, 0x00	; 0
    36ee:	81 e0       	ldi	r24, 0x01	; 1
    36f0:	90 e0       	ldi	r25, 0x00	; 0
    36f2:	02 2e       	mov	r0, r18
    36f4:	02 c0       	rjmp	.+4      	; 0x36fa <MCAL_DIO_WritePin+0x164>
    36f6:	88 0f       	add	r24, r24
    36f8:	99 1f       	adc	r25, r25
    36fa:	0a 94       	dec	r0
    36fc:	e2 f7       	brpl	.-8      	; 0x36f6 <MCAL_DIO_WritePin+0x160>
    36fe:	80 95       	com	r24
    3700:	84 23       	and	r24, r20
    3702:	8c 93       	st	X, r24
    3704:	6e c0       	rjmp	.+220    	; 0x37e2 <MCAL_DIO_WritePin+0x24c>
			}
			break;

		case Port_C:
			switch(DIO_PinStatus){
    3706:	8d 81       	ldd	r24, Y+5	; 0x05
    3708:	28 2f       	mov	r18, r24
    370a:	30 e0       	ldi	r19, 0x00	; 0
    370c:	39 87       	std	Y+9, r19	; 0x09
    370e:	28 87       	std	Y+8, r18	; 0x08
    3710:	88 85       	ldd	r24, Y+8	; 0x08
    3712:	99 85       	ldd	r25, Y+9	; 0x09
    3714:	00 97       	sbiw	r24, 0x00	; 0
    3716:	d1 f0       	breq	.+52     	; 0x374c <MCAL_DIO_WritePin+0x1b6>
    3718:	28 85       	ldd	r18, Y+8	; 0x08
    371a:	39 85       	ldd	r19, Y+9	; 0x09
    371c:	21 30       	cpi	r18, 0x01	; 1
    371e:	31 05       	cpc	r19, r1
    3720:	09 f0       	breq	.+2      	; 0x3724 <MCAL_DIO_WritePin+0x18e>
    3722:	5f c0       	rjmp	.+190    	; 0x37e2 <MCAL_DIO_WritePin+0x24c>
			case DIO_Set: SET_BIT(PORTC,DIO_Pin.Pin_Number); break;
    3724:	a5 e3       	ldi	r26, 0x35	; 53
    3726:	b0 e0       	ldi	r27, 0x00	; 0
    3728:	e5 e3       	ldi	r30, 0x35	; 53
    372a:	f0 e0       	ldi	r31, 0x00	; 0
    372c:	80 81       	ld	r24, Z
    372e:	48 2f       	mov	r20, r24
    3730:	8b 81       	ldd	r24, Y+3	; 0x03
    3732:	28 2f       	mov	r18, r24
    3734:	30 e0       	ldi	r19, 0x00	; 0
    3736:	81 e0       	ldi	r24, 0x01	; 1
    3738:	90 e0       	ldi	r25, 0x00	; 0
    373a:	02 2e       	mov	r0, r18
    373c:	02 c0       	rjmp	.+4      	; 0x3742 <MCAL_DIO_WritePin+0x1ac>
    373e:	88 0f       	add	r24, r24
    3740:	99 1f       	adc	r25, r25
    3742:	0a 94       	dec	r0
    3744:	e2 f7       	brpl	.-8      	; 0x373e <MCAL_DIO_WritePin+0x1a8>
    3746:	84 2b       	or	r24, r20
    3748:	8c 93       	st	X, r24
    374a:	4b c0       	rjmp	.+150    	; 0x37e2 <MCAL_DIO_WritePin+0x24c>
			case DIO_Reset: CLR_BIT(PORTC,DIO_Pin.Pin_Number); break;
    374c:	a5 e3       	ldi	r26, 0x35	; 53
    374e:	b0 e0       	ldi	r27, 0x00	; 0
    3750:	e5 e3       	ldi	r30, 0x35	; 53
    3752:	f0 e0       	ldi	r31, 0x00	; 0
    3754:	80 81       	ld	r24, Z
    3756:	48 2f       	mov	r20, r24
    3758:	8b 81       	ldd	r24, Y+3	; 0x03
    375a:	28 2f       	mov	r18, r24
    375c:	30 e0       	ldi	r19, 0x00	; 0
    375e:	81 e0       	ldi	r24, 0x01	; 1
    3760:	90 e0       	ldi	r25, 0x00	; 0
    3762:	02 2e       	mov	r0, r18
    3764:	02 c0       	rjmp	.+4      	; 0x376a <MCAL_DIO_WritePin+0x1d4>
    3766:	88 0f       	add	r24, r24
    3768:	99 1f       	adc	r25, r25
    376a:	0a 94       	dec	r0
    376c:	e2 f7       	brpl	.-8      	; 0x3766 <MCAL_DIO_WritePin+0x1d0>
    376e:	80 95       	com	r24
    3770:	84 23       	and	r24, r20
    3772:	8c 93       	st	X, r24
    3774:	36 c0       	rjmp	.+108    	; 0x37e2 <MCAL_DIO_WritePin+0x24c>
			}
			break;

		case Port_D:
			switch(DIO_PinStatus){
    3776:	8d 81       	ldd	r24, Y+5	; 0x05
    3778:	28 2f       	mov	r18, r24
    377a:	30 e0       	ldi	r19, 0x00	; 0
    377c:	3f 83       	std	Y+7, r19	; 0x07
    377e:	2e 83       	std	Y+6, r18	; 0x06
    3780:	8e 81       	ldd	r24, Y+6	; 0x06
    3782:	9f 81       	ldd	r25, Y+7	; 0x07
    3784:	00 97       	sbiw	r24, 0x00	; 0
    3786:	c9 f0       	breq	.+50     	; 0x37ba <MCAL_DIO_WritePin+0x224>
    3788:	2e 81       	ldd	r18, Y+6	; 0x06
    378a:	3f 81       	ldd	r19, Y+7	; 0x07
    378c:	21 30       	cpi	r18, 0x01	; 1
    378e:	31 05       	cpc	r19, r1
    3790:	41 f5       	brne	.+80     	; 0x37e2 <MCAL_DIO_WritePin+0x24c>
			case DIO_Set: SET_BIT(PORTD,DIO_Pin.Pin_Number); break;
    3792:	a2 e3       	ldi	r26, 0x32	; 50
    3794:	b0 e0       	ldi	r27, 0x00	; 0
    3796:	e2 e3       	ldi	r30, 0x32	; 50
    3798:	f0 e0       	ldi	r31, 0x00	; 0
    379a:	80 81       	ld	r24, Z
    379c:	48 2f       	mov	r20, r24
    379e:	8b 81       	ldd	r24, Y+3	; 0x03
    37a0:	28 2f       	mov	r18, r24
    37a2:	30 e0       	ldi	r19, 0x00	; 0
    37a4:	81 e0       	ldi	r24, 0x01	; 1
    37a6:	90 e0       	ldi	r25, 0x00	; 0
    37a8:	02 2e       	mov	r0, r18
    37aa:	02 c0       	rjmp	.+4      	; 0x37b0 <MCAL_DIO_WritePin+0x21a>
    37ac:	88 0f       	add	r24, r24
    37ae:	99 1f       	adc	r25, r25
    37b0:	0a 94       	dec	r0
    37b2:	e2 f7       	brpl	.-8      	; 0x37ac <MCAL_DIO_WritePin+0x216>
    37b4:	84 2b       	or	r24, r20
    37b6:	8c 93       	st	X, r24
    37b8:	14 c0       	rjmp	.+40     	; 0x37e2 <MCAL_DIO_WritePin+0x24c>
			case DIO_Reset: CLR_BIT(PORTD,DIO_Pin.Pin_Number); break;
    37ba:	a2 e3       	ldi	r26, 0x32	; 50
    37bc:	b0 e0       	ldi	r27, 0x00	; 0
    37be:	e2 e3       	ldi	r30, 0x32	; 50
    37c0:	f0 e0       	ldi	r31, 0x00	; 0
    37c2:	80 81       	ld	r24, Z
    37c4:	48 2f       	mov	r20, r24
    37c6:	8b 81       	ldd	r24, Y+3	; 0x03
    37c8:	28 2f       	mov	r18, r24
    37ca:	30 e0       	ldi	r19, 0x00	; 0
    37cc:	81 e0       	ldi	r24, 0x01	; 1
    37ce:	90 e0       	ldi	r25, 0x00	; 0
    37d0:	02 2e       	mov	r0, r18
    37d2:	02 c0       	rjmp	.+4      	; 0x37d8 <MCAL_DIO_WritePin+0x242>
    37d4:	88 0f       	add	r24, r24
    37d6:	99 1f       	adc	r25, r25
    37d8:	0a 94       	dec	r0
    37da:	e2 f7       	brpl	.-8      	; 0x37d4 <MCAL_DIO_WritePin+0x23e>
    37dc:	80 95       	com	r24
    37de:	84 23       	and	r24, r20
    37e0:	8c 93       	st	X, r24
			break;

		}
	}

	return DIO_ReturnError;
    37e2:	89 81       	ldd	r24, Y+1	; 0x01

}
    37e4:	2f 96       	adiw	r28, 0x0f	; 15
    37e6:	0f b6       	in	r0, 0x3f	; 63
    37e8:	f8 94       	cli
    37ea:	de bf       	out	0x3e, r29	; 62
    37ec:	0f be       	out	0x3f, r0	; 63
    37ee:	cd bf       	out	0x3d, r28	; 61
    37f0:	cf 91       	pop	r28
    37f2:	df 91       	pop	r29
    37f4:	08 95       	ret

000037f6 <MCAL_DIO_GetPort>:
 * 	@ RetVal	 - Std_Return.
 *	  Note		 - This API return "OK" when no error occurred,
 *	  			   return "INVALID_PORT" when the entered port is not valid
 *	  			   return "UNKNOWN"	when there's unknown error
 * ==================================================================== */
Std_Return MCAL_DIO_GetPort(DIO_PortType DIO_Port, DIO_StatusType *DIO_pPortStatusBuf){
    37f6:	df 93       	push	r29
    37f8:	cf 93       	push	r28
    37fa:	cd b7       	in	r28, 0x3d	; 61
    37fc:	de b7       	in	r29, 0x3e	; 62
    37fe:	27 97       	sbiw	r28, 0x07	; 7
    3800:	0f b6       	in	r0, 0x3f	; 63
    3802:	f8 94       	cli
    3804:	de bf       	out	0x3e, r29	; 62
    3806:	0f be       	out	0x3f, r0	; 63
    3808:	cd bf       	out	0x3d, r28	; 61
    380a:	9b 83       	std	Y+3, r25	; 0x03
    380c:	8a 83       	std	Y+2, r24	; 0x02
    380e:	7d 83       	std	Y+5, r23	; 0x05
    3810:	6c 83       	std	Y+4, r22	; 0x04

	/*---------- Return Values ----------*/
	// Initialize error status with no errors
	Std_Return DIO_ReturnError = OK;
    3812:	19 82       	std	Y+1, r1	; 0x01

	// Check if there is any errors in the parameter
	if(((DIO_Port.Port) > Port_D) || ((DIO_Port.Port) < 0)) DIO_ReturnError = INVALID_PORT;
    3814:	8a 81       	ldd	r24, Y+2	; 0x02
    3816:	84 30       	cpi	r24, 0x04	; 4
    3818:	18 f0       	brcs	.+6      	; 0x3820 <MCAL_DIO_GetPort+0x2a>
    381a:	82 e0       	ldi	r24, 0x02	; 2
    381c:	89 83       	std	Y+1, r24	; 0x01
    381e:	07 c0       	rjmp	.+14     	; 0x382e <MCAL_DIO_GetPort+0x38>
	else if((DIO_Port.Port) <= Port_D) DIO_ReturnError = OK;
    3820:	8a 81       	ldd	r24, Y+2	; 0x02
    3822:	84 30       	cpi	r24, 0x04	; 4
    3824:	10 f4       	brcc	.+4      	; 0x382a <MCAL_DIO_GetPort+0x34>
    3826:	19 82       	std	Y+1, r1	; 0x01
    3828:	02 c0       	rjmp	.+4      	; 0x382e <MCAL_DIO_GetPort+0x38>
	else DIO_ReturnError = UNKNOWN;
    382a:	81 e0       	ldi	r24, 0x01	; 1
    382c:	89 83       	std	Y+1, r24	; 0x01




	/*-------- Get Port Status -------*/
	if(DIO_ReturnError == OK) {
    382e:	89 81       	ldd	r24, Y+1	; 0x01
    3830:	88 23       	and	r24, r24
    3832:	d1 f5       	brne	.+116    	; 0x38a8 <MCAL_DIO_GetPort+0xb2>
		switch (DIO_Port.Port){
    3834:	8a 81       	ldd	r24, Y+2	; 0x02
    3836:	28 2f       	mov	r18, r24
    3838:	30 e0       	ldi	r19, 0x00	; 0
    383a:	3f 83       	std	Y+7, r19	; 0x07
    383c:	2e 83       	std	Y+6, r18	; 0x06
    383e:	8e 81       	ldd	r24, Y+6	; 0x06
    3840:	9f 81       	ldd	r25, Y+7	; 0x07
    3842:	81 30       	cpi	r24, 0x01	; 1
    3844:	91 05       	cpc	r25, r1
    3846:	e1 f0       	breq	.+56     	; 0x3880 <MCAL_DIO_GetPort+0x8a>
    3848:	2e 81       	ldd	r18, Y+6	; 0x06
    384a:	3f 81       	ldd	r19, Y+7	; 0x07
    384c:	22 30       	cpi	r18, 0x02	; 2
    384e:	31 05       	cpc	r19, r1
    3850:	2c f4       	brge	.+10     	; 0x385c <MCAL_DIO_GetPort+0x66>
    3852:	8e 81       	ldd	r24, Y+6	; 0x06
    3854:	9f 81       	ldd	r25, Y+7	; 0x07
    3856:	00 97       	sbiw	r24, 0x00	; 0
    3858:	61 f0       	breq	.+24     	; 0x3872 <MCAL_DIO_GetPort+0x7c>
    385a:	26 c0       	rjmp	.+76     	; 0x38a8 <MCAL_DIO_GetPort+0xb2>
    385c:	2e 81       	ldd	r18, Y+6	; 0x06
    385e:	3f 81       	ldd	r19, Y+7	; 0x07
    3860:	22 30       	cpi	r18, 0x02	; 2
    3862:	31 05       	cpc	r19, r1
    3864:	a1 f0       	breq	.+40     	; 0x388e <MCAL_DIO_GetPort+0x98>
    3866:	8e 81       	ldd	r24, Y+6	; 0x06
    3868:	9f 81       	ldd	r25, Y+7	; 0x07
    386a:	83 30       	cpi	r24, 0x03	; 3
    386c:	91 05       	cpc	r25, r1
    386e:	b1 f0       	breq	.+44     	; 0x389c <MCAL_DIO_GetPort+0xa6>
    3870:	1b c0       	rjmp	.+54     	; 0x38a8 <MCAL_DIO_GetPort+0xb2>

		case Port_A: *DIO_pPortStatusBuf = PINA; break;
    3872:	e9 e3       	ldi	r30, 0x39	; 57
    3874:	f0 e0       	ldi	r31, 0x00	; 0
    3876:	80 81       	ld	r24, Z
    3878:	ec 81       	ldd	r30, Y+4	; 0x04
    387a:	fd 81       	ldd	r31, Y+5	; 0x05
    387c:	80 83       	st	Z, r24
    387e:	14 c0       	rjmp	.+40     	; 0x38a8 <MCAL_DIO_GetPort+0xb2>
		case Port_B: *DIO_pPortStatusBuf = PINB; break;
    3880:	e6 e3       	ldi	r30, 0x36	; 54
    3882:	f0 e0       	ldi	r31, 0x00	; 0
    3884:	80 81       	ld	r24, Z
    3886:	ec 81       	ldd	r30, Y+4	; 0x04
    3888:	fd 81       	ldd	r31, Y+5	; 0x05
    388a:	80 83       	st	Z, r24
    388c:	0d c0       	rjmp	.+26     	; 0x38a8 <MCAL_DIO_GetPort+0xb2>
		case Port_C: *DIO_pPortStatusBuf = PINC; break;
    388e:	e3 e3       	ldi	r30, 0x33	; 51
    3890:	f0 e0       	ldi	r31, 0x00	; 0
    3892:	80 81       	ld	r24, Z
    3894:	ec 81       	ldd	r30, Y+4	; 0x04
    3896:	fd 81       	ldd	r31, Y+5	; 0x05
    3898:	80 83       	st	Z, r24
    389a:	06 c0       	rjmp	.+12     	; 0x38a8 <MCAL_DIO_GetPort+0xb2>
		case Port_D: *DIO_pPortStatusBuf = PIND; break;
    389c:	e0 e3       	ldi	r30, 0x30	; 48
    389e:	f0 e0       	ldi	r31, 0x00	; 0
    38a0:	80 81       	ld	r24, Z
    38a2:	ec 81       	ldd	r30, Y+4	; 0x04
    38a4:	fd 81       	ldd	r31, Y+5	; 0x05
    38a6:	80 83       	st	Z, r24

		}
	}

	return DIO_ReturnError;
    38a8:	89 81       	ldd	r24, Y+1	; 0x01

}
    38aa:	27 96       	adiw	r28, 0x07	; 7
    38ac:	0f b6       	in	r0, 0x3f	; 63
    38ae:	f8 94       	cli
    38b0:	de bf       	out	0x3e, r29	; 62
    38b2:	0f be       	out	0x3f, r0	; 63
    38b4:	cd bf       	out	0x3d, r28	; 61
    38b6:	cf 91       	pop	r28
    38b8:	df 91       	pop	r29
    38ba:	08 95       	ret

000038bc <MCAL_DIO_GetPin>:
 *	  Note		 - This API return "OK" when no error occurred,
 *	  			   return "INVALID_PORT" when the entered port is not valid,
 *	  			   return "WRONG_PIN" when the entered pin is not valid,
 *	  			   return "UNKNOWN"	when there's unknown error.
 * ==================================================================== */
Std_Return MCAL_DIO_GetPin(DIO_PinType DIO_Pin, DIO_StatusType *DIO_pPinStatusBuf){
    38bc:	df 93       	push	r29
    38be:	cf 93       	push	r28
    38c0:	cd b7       	in	r28, 0x3d	; 61
    38c2:	de b7       	in	r29, 0x3e	; 62
    38c4:	28 97       	sbiw	r28, 0x08	; 8
    38c6:	0f b6       	in	r0, 0x3f	; 63
    38c8:	f8 94       	cli
    38ca:	de bf       	out	0x3e, r29	; 62
    38cc:	0f be       	out	0x3f, r0	; 63
    38ce:	cd bf       	out	0x3d, r28	; 61
    38d0:	6a 83       	std	Y+2, r22	; 0x02
    38d2:	7b 83       	std	Y+3, r23	; 0x03
    38d4:	8c 83       	std	Y+4, r24	; 0x04
    38d6:	5e 83       	std	Y+6, r21	; 0x06
    38d8:	4d 83       	std	Y+5, r20	; 0x05

	/*---------- Return Values ----------*/
	// Initialize error status with no errors
	Std_Return DIO_ReturnError = OK;
    38da:	19 82       	std	Y+1, r1	; 0x01

	// Check if there is any error in the parameter
	if(((DIO_Pin.Port) > Port_D) || ((DIO_Pin.Port) < 0)) DIO_ReturnError = INVALID_PORT;
    38dc:	8a 81       	ldd	r24, Y+2	; 0x02
    38de:	84 30       	cpi	r24, 0x04	; 4
    38e0:	18 f0       	brcs	.+6      	; 0x38e8 <MCAL_DIO_GetPin+0x2c>
    38e2:	82 e0       	ldi	r24, 0x02	; 2
    38e4:	89 83       	std	Y+1, r24	; 0x01
    38e6:	0d c0       	rjmp	.+26     	; 0x3902 <MCAL_DIO_GetPin+0x46>
	else if(((DIO_Pin.Pin_Number) > 7) || ((DIO_Pin.Pin_Number) < 0)) DIO_ReturnError = WRONG_PIN;
    38e8:	8b 81       	ldd	r24, Y+3	; 0x03
    38ea:	88 30       	cpi	r24, 0x08	; 8
    38ec:	18 f0       	brcs	.+6      	; 0x38f4 <MCAL_DIO_GetPin+0x38>
    38ee:	83 e0       	ldi	r24, 0x03	; 3
    38f0:	89 83       	std	Y+1, r24	; 0x01
    38f2:	07 c0       	rjmp	.+14     	; 0x3902 <MCAL_DIO_GetPin+0x46>
	else if((DIO_Pin.Port) <= Port_D) DIO_ReturnError = OK;
    38f4:	8a 81       	ldd	r24, Y+2	; 0x02
    38f6:	84 30       	cpi	r24, 0x04	; 4
    38f8:	10 f4       	brcc	.+4      	; 0x38fe <MCAL_DIO_GetPin+0x42>
    38fa:	19 82       	std	Y+1, r1	; 0x01
    38fc:	02 c0       	rjmp	.+4      	; 0x3902 <MCAL_DIO_GetPin+0x46>
	else DIO_ReturnError = UNKNOWN;
    38fe:	81 e0       	ldi	r24, 0x01	; 1
    3900:	89 83       	std	Y+1, r24	; 0x01




	/*---------- Get Pin Status ---------*/
	if(DIO_ReturnError == OK) {
    3902:	89 81       	ldd	r24, Y+1	; 0x01
    3904:	88 23       	and	r24, r24
    3906:	09 f0       	breq	.+2      	; 0x390a <MCAL_DIO_GetPin+0x4e>
    3908:	70 c0       	rjmp	.+224    	; 0x39ea <MCAL_DIO_GetPin+0x12e>
		switch (DIO_Pin.Port){
    390a:	8a 81       	ldd	r24, Y+2	; 0x02
    390c:	28 2f       	mov	r18, r24
    390e:	30 e0       	ldi	r19, 0x00	; 0
    3910:	38 87       	std	Y+8, r19	; 0x08
    3912:	2f 83       	std	Y+7, r18	; 0x07
    3914:	4f 81       	ldd	r20, Y+7	; 0x07
    3916:	58 85       	ldd	r21, Y+8	; 0x08
    3918:	41 30       	cpi	r20, 0x01	; 1
    391a:	51 05       	cpc	r21, r1
    391c:	59 f1       	breq	.+86     	; 0x3974 <MCAL_DIO_GetPin+0xb8>
    391e:	8f 81       	ldd	r24, Y+7	; 0x07
    3920:	98 85       	ldd	r25, Y+8	; 0x08
    3922:	82 30       	cpi	r24, 0x02	; 2
    3924:	91 05       	cpc	r25, r1
    3926:	34 f4       	brge	.+12     	; 0x3934 <MCAL_DIO_GetPin+0x78>
    3928:	2f 81       	ldd	r18, Y+7	; 0x07
    392a:	38 85       	ldd	r19, Y+8	; 0x08
    392c:	21 15       	cp	r18, r1
    392e:	31 05       	cpc	r19, r1
    3930:	69 f0       	breq	.+26     	; 0x394c <MCAL_DIO_GetPin+0x90>
    3932:	5b c0       	rjmp	.+182    	; 0x39ea <MCAL_DIO_GetPin+0x12e>
    3934:	4f 81       	ldd	r20, Y+7	; 0x07
    3936:	58 85       	ldd	r21, Y+8	; 0x08
    3938:	42 30       	cpi	r20, 0x02	; 2
    393a:	51 05       	cpc	r21, r1
    393c:	79 f1       	breq	.+94     	; 0x399c <MCAL_DIO_GetPin+0xe0>
    393e:	8f 81       	ldd	r24, Y+7	; 0x07
    3940:	98 85       	ldd	r25, Y+8	; 0x08
    3942:	83 30       	cpi	r24, 0x03	; 3
    3944:	91 05       	cpc	r25, r1
    3946:	09 f4       	brne	.+2      	; 0x394a <MCAL_DIO_GetPin+0x8e>
    3948:	3d c0       	rjmp	.+122    	; 0x39c4 <MCAL_DIO_GetPin+0x108>
    394a:	4f c0       	rjmp	.+158    	; 0x39ea <MCAL_DIO_GetPin+0x12e>

		case Port_A: *DIO_pPinStatusBuf = GET_BIT(PINA,DIO_Pin.Pin_Number); break;
    394c:	e9 e3       	ldi	r30, 0x39	; 57
    394e:	f0 e0       	ldi	r31, 0x00	; 0
    3950:	80 81       	ld	r24, Z
    3952:	28 2f       	mov	r18, r24
    3954:	30 e0       	ldi	r19, 0x00	; 0
    3956:	8b 81       	ldd	r24, Y+3	; 0x03
    3958:	88 2f       	mov	r24, r24
    395a:	90 e0       	ldi	r25, 0x00	; 0
    395c:	a9 01       	movw	r20, r18
    395e:	02 c0       	rjmp	.+4      	; 0x3964 <MCAL_DIO_GetPin+0xa8>
    3960:	55 95       	asr	r21
    3962:	47 95       	ror	r20
    3964:	8a 95       	dec	r24
    3966:	e2 f7       	brpl	.-8      	; 0x3960 <MCAL_DIO_GetPin+0xa4>
    3968:	ca 01       	movw	r24, r20
    396a:	81 70       	andi	r24, 0x01	; 1
    396c:	ed 81       	ldd	r30, Y+5	; 0x05
    396e:	fe 81       	ldd	r31, Y+6	; 0x06
    3970:	80 83       	st	Z, r24
    3972:	3b c0       	rjmp	.+118    	; 0x39ea <MCAL_DIO_GetPin+0x12e>
		case Port_B: *DIO_pPinStatusBuf = GET_BIT(PINB,DIO_Pin.Pin_Number); break;
    3974:	e6 e3       	ldi	r30, 0x36	; 54
    3976:	f0 e0       	ldi	r31, 0x00	; 0
    3978:	80 81       	ld	r24, Z
    397a:	28 2f       	mov	r18, r24
    397c:	30 e0       	ldi	r19, 0x00	; 0
    397e:	8b 81       	ldd	r24, Y+3	; 0x03
    3980:	88 2f       	mov	r24, r24
    3982:	90 e0       	ldi	r25, 0x00	; 0
    3984:	a9 01       	movw	r20, r18
    3986:	02 c0       	rjmp	.+4      	; 0x398c <MCAL_DIO_GetPin+0xd0>
    3988:	55 95       	asr	r21
    398a:	47 95       	ror	r20
    398c:	8a 95       	dec	r24
    398e:	e2 f7       	brpl	.-8      	; 0x3988 <MCAL_DIO_GetPin+0xcc>
    3990:	ca 01       	movw	r24, r20
    3992:	81 70       	andi	r24, 0x01	; 1
    3994:	ed 81       	ldd	r30, Y+5	; 0x05
    3996:	fe 81       	ldd	r31, Y+6	; 0x06
    3998:	80 83       	st	Z, r24
    399a:	27 c0       	rjmp	.+78     	; 0x39ea <MCAL_DIO_GetPin+0x12e>
		case Port_C: *DIO_pPinStatusBuf = GET_BIT(PINC,DIO_Pin.Pin_Number); break;
    399c:	e3 e3       	ldi	r30, 0x33	; 51
    399e:	f0 e0       	ldi	r31, 0x00	; 0
    39a0:	80 81       	ld	r24, Z
    39a2:	28 2f       	mov	r18, r24
    39a4:	30 e0       	ldi	r19, 0x00	; 0
    39a6:	8b 81       	ldd	r24, Y+3	; 0x03
    39a8:	88 2f       	mov	r24, r24
    39aa:	90 e0       	ldi	r25, 0x00	; 0
    39ac:	a9 01       	movw	r20, r18
    39ae:	02 c0       	rjmp	.+4      	; 0x39b4 <MCAL_DIO_GetPin+0xf8>
    39b0:	55 95       	asr	r21
    39b2:	47 95       	ror	r20
    39b4:	8a 95       	dec	r24
    39b6:	e2 f7       	brpl	.-8      	; 0x39b0 <MCAL_DIO_GetPin+0xf4>
    39b8:	ca 01       	movw	r24, r20
    39ba:	81 70       	andi	r24, 0x01	; 1
    39bc:	ed 81       	ldd	r30, Y+5	; 0x05
    39be:	fe 81       	ldd	r31, Y+6	; 0x06
    39c0:	80 83       	st	Z, r24
    39c2:	13 c0       	rjmp	.+38     	; 0x39ea <MCAL_DIO_GetPin+0x12e>
		case Port_D: *DIO_pPinStatusBuf = GET_BIT(PIND,DIO_Pin.Pin_Number); break;
    39c4:	e0 e3       	ldi	r30, 0x30	; 48
    39c6:	f0 e0       	ldi	r31, 0x00	; 0
    39c8:	80 81       	ld	r24, Z
    39ca:	28 2f       	mov	r18, r24
    39cc:	30 e0       	ldi	r19, 0x00	; 0
    39ce:	8b 81       	ldd	r24, Y+3	; 0x03
    39d0:	88 2f       	mov	r24, r24
    39d2:	90 e0       	ldi	r25, 0x00	; 0
    39d4:	a9 01       	movw	r20, r18
    39d6:	02 c0       	rjmp	.+4      	; 0x39dc <MCAL_DIO_GetPin+0x120>
    39d8:	55 95       	asr	r21
    39da:	47 95       	ror	r20
    39dc:	8a 95       	dec	r24
    39de:	e2 f7       	brpl	.-8      	; 0x39d8 <MCAL_DIO_GetPin+0x11c>
    39e0:	ca 01       	movw	r24, r20
    39e2:	81 70       	andi	r24, 0x01	; 1
    39e4:	ed 81       	ldd	r30, Y+5	; 0x05
    39e6:	fe 81       	ldd	r31, Y+6	; 0x06
    39e8:	80 83       	st	Z, r24

		}
	}

	return DIO_ReturnError;
    39ea:	89 81       	ldd	r24, Y+1	; 0x01

}
    39ec:	28 96       	adiw	r28, 0x08	; 8
    39ee:	0f b6       	in	r0, 0x3f	; 63
    39f0:	f8 94       	cli
    39f2:	de bf       	out	0x3e, r29	; 62
    39f4:	0f be       	out	0x3f, r0	; 63
    39f6:	cd bf       	out	0x3d, r28	; 61
    39f8:	cf 91       	pop	r28
    39fa:	df 91       	pop	r29
    39fc:	08 95       	ret

000039fe <MCAL_GIE_Enable>:
/* =======================================================================
 * 	@ Func  	 - MCAL_GIE_Enable
 * 	@ Brief 	 - Enables Global Interrupt
 * 	@ RetVal	 - None.
 * ==================================================================== */
void MCAL_GIE_Enable(void){
    39fe:	df 93       	push	r29
    3a00:	cf 93       	push	r28
    3a02:	cd b7       	in	r28, 0x3d	; 61
    3a04:	de b7       	in	r29, 0x3e	; 62

	/*---- Enable Global Interrupt ----*/
	SET_BIT(SREG,SREG_I);
    3a06:	af e5       	ldi	r26, 0x5F	; 95
    3a08:	b0 e0       	ldi	r27, 0x00	; 0
    3a0a:	ef e5       	ldi	r30, 0x5F	; 95
    3a0c:	f0 e0       	ldi	r31, 0x00	; 0
    3a0e:	80 81       	ld	r24, Z
    3a10:	80 68       	ori	r24, 0x80	; 128
    3a12:	8c 93       	st	X, r24

}
    3a14:	cf 91       	pop	r28
    3a16:	df 91       	pop	r29
    3a18:	08 95       	ret

00003a1a <MCAL_GIE_Disable>:
/* =======================================================================
 * 	@ Func  	 - MCAL_GIE_Disable
 * 	@ Brief 	 - Disables Global Interrupt
 * 	@ RetVal	 - None.
 * ==================================================================== */
void MCAL_GIE_Disable(void){
    3a1a:	df 93       	push	r29
    3a1c:	cf 93       	push	r28
    3a1e:	cd b7       	in	r28, 0x3d	; 61
    3a20:	de b7       	in	r29, 0x3e	; 62

	/*---- Disable Global Interrupt ----*/
	CLR_BIT(SREG,SREG_I);
    3a22:	af e5       	ldi	r26, 0x5F	; 95
    3a24:	b0 e0       	ldi	r27, 0x00	; 0
    3a26:	ef e5       	ldi	r30, 0x5F	; 95
    3a28:	f0 e0       	ldi	r31, 0x00	; 0
    3a2a:	80 81       	ld	r24, Z
    3a2c:	8f 77       	andi	r24, 0x7F	; 127
    3a2e:	8c 93       	st	X, r24

}
    3a30:	cf 91       	pop	r28
    3a32:	df 91       	pop	r29
    3a34:	08 95       	ret

00003a36 <MCAL_UART_Init>:
 * 	@ Brief 	 - Initialize the UART according to the specified configuration.
 * 	@ Param [in] - UART_Config: All UART Configuration.
 * 	@ RetVal	 - None.
 *	  Note		 - UART uses Pin 0 & 1 in Port D
 * ==================================================================== */
void MCAL_UART_Init(UART_Config UART_Config){
    3a36:	df 93       	push	r29
    3a38:	cf 93       	push	r28
    3a3a:	cd b7       	in	r28, 0x3d	; 61
    3a3c:	de b7       	in	r29, 0x3e	; 62
    3a3e:	6a 97       	sbiw	r28, 0x1a	; 26
    3a40:	0f b6       	in	r0, 0x3f	; 63
    3a42:	f8 94       	cli
    3a44:	de bf       	out	0x3e, r29	; 62
    3a46:	0f be       	out	0x3f, r0	; 63
    3a48:	cd bf       	out	0x3d, r28	; 61

	/*- Save a Copy of the Configuration -*/
	UART_DefaultConfig = UART_Config;
    3a4a:	8f e6       	ldi	r24, 0x6F	; 111
    3a4c:	90 e0       	ldi	r25, 0x00	; 0
    3a4e:	9d 87       	std	Y+13, r25	; 0x0d
    3a50:	8c 87       	std	Y+12, r24	; 0x0c
    3a52:	fe 01       	movw	r30, r28
    3a54:	7f 96       	adiw	r30, 0x1f	; 31
    3a56:	ff 87       	std	Y+15, r31	; 0x0f
    3a58:	ee 87       	std	Y+14, r30	; 0x0e
    3a5a:	f3 e1       	ldi	r31, 0x13	; 19
    3a5c:	f8 8b       	std	Y+16, r31	; 0x10
    3a5e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3a60:	ff 85       	ldd	r31, Y+15	; 0x0f
    3a62:	00 80       	ld	r0, Z
    3a64:	8e 85       	ldd	r24, Y+14	; 0x0e
    3a66:	9f 85       	ldd	r25, Y+15	; 0x0f
    3a68:	01 96       	adiw	r24, 0x01	; 1
    3a6a:	9f 87       	std	Y+15, r25	; 0x0f
    3a6c:	8e 87       	std	Y+14, r24	; 0x0e
    3a6e:	ec 85       	ldd	r30, Y+12	; 0x0c
    3a70:	fd 85       	ldd	r31, Y+13	; 0x0d
    3a72:	00 82       	st	Z, r0
    3a74:	8c 85       	ldd	r24, Y+12	; 0x0c
    3a76:	9d 85       	ldd	r25, Y+13	; 0x0d
    3a78:	01 96       	adiw	r24, 0x01	; 1
    3a7a:	9d 87       	std	Y+13, r25	; 0x0d
    3a7c:	8c 87       	std	Y+12, r24	; 0x0c
    3a7e:	98 89       	ldd	r25, Y+16	; 0x10
    3a80:	91 50       	subi	r25, 0x01	; 1
    3a82:	98 8b       	std	Y+16, r25	; 0x10
    3a84:	e8 89       	ldd	r30, Y+16	; 0x10
    3a86:	ee 23       	and	r30, r30
    3a88:	51 f7       	brne	.-44     	; 0x3a5e <MCAL_UART_Init+0x28>



	/*-------- DIO Configuration --------*/
	// DIO Configure pin 0 in port D as input pin for receiving
	DIO_PinType UART_Rx = {Port_D, Pin0, DIO_Input};
    3a8a:	ce 01       	movw	r24, r28
    3a8c:	06 96       	adiw	r24, 0x06	; 6
    3a8e:	9a 8b       	std	Y+18, r25	; 0x12
    3a90:	89 8b       	std	Y+17, r24	; 0x11
    3a92:	e8 e9       	ldi	r30, 0x98	; 152
    3a94:	f0 e0       	ldi	r31, 0x00	; 0
    3a96:	fc 8b       	std	Y+20, r31	; 0x14
    3a98:	eb 8b       	std	Y+19, r30	; 0x13
    3a9a:	f3 e0       	ldi	r31, 0x03	; 3
    3a9c:	fd 8b       	std	Y+21, r31	; 0x15
    3a9e:	eb 89       	ldd	r30, Y+19	; 0x13
    3aa0:	fc 89       	ldd	r31, Y+20	; 0x14
    3aa2:	00 80       	ld	r0, Z
    3aa4:	8b 89       	ldd	r24, Y+19	; 0x13
    3aa6:	9c 89       	ldd	r25, Y+20	; 0x14
    3aa8:	01 96       	adiw	r24, 0x01	; 1
    3aaa:	9c 8b       	std	Y+20, r25	; 0x14
    3aac:	8b 8b       	std	Y+19, r24	; 0x13
    3aae:	e9 89       	ldd	r30, Y+17	; 0x11
    3ab0:	fa 89       	ldd	r31, Y+18	; 0x12
    3ab2:	00 82       	st	Z, r0
    3ab4:	89 89       	ldd	r24, Y+17	; 0x11
    3ab6:	9a 89       	ldd	r25, Y+18	; 0x12
    3ab8:	01 96       	adiw	r24, 0x01	; 1
    3aba:	9a 8b       	std	Y+18, r25	; 0x12
    3abc:	89 8b       	std	Y+17, r24	; 0x11
    3abe:	9d 89       	ldd	r25, Y+21	; 0x15
    3ac0:	91 50       	subi	r25, 0x01	; 1
    3ac2:	9d 8b       	std	Y+21, r25	; 0x15
    3ac4:	ed 89       	ldd	r30, Y+21	; 0x15
    3ac6:	ee 23       	and	r30, r30
    3ac8:	51 f7       	brne	.-44     	; 0x3a9e <MCAL_UART_Init+0x68>
	MCAL_DIO_SetPinDirection(UART_Rx);
    3aca:	6e 81       	ldd	r22, Y+6	; 0x06
    3acc:	7f 81       	ldd	r23, Y+7	; 0x07
    3ace:	88 85       	ldd	r24, Y+8	; 0x08
    3ad0:	0e 94 40 19 	call	0x3280	; 0x3280 <MCAL_DIO_SetPinDirection>

	// DIO Configure pin 1 in port D as output pin for transmitting
	DIO_PinType UART_Tx = {Port_D, Pin1, DIO_Output};
    3ad4:	ce 01       	movw	r24, r28
    3ad6:	09 96       	adiw	r24, 0x09	; 9
    3ad8:	9f 8b       	std	Y+23, r25	; 0x17
    3ada:	8e 8b       	std	Y+22, r24	; 0x16
    3adc:	e5 e9       	ldi	r30, 0x95	; 149
    3ade:	f0 e0       	ldi	r31, 0x00	; 0
    3ae0:	f9 8f       	std	Y+25, r31	; 0x19
    3ae2:	e8 8f       	std	Y+24, r30	; 0x18
    3ae4:	f3 e0       	ldi	r31, 0x03	; 3
    3ae6:	fa 8f       	std	Y+26, r31	; 0x1a
    3ae8:	e8 8d       	ldd	r30, Y+24	; 0x18
    3aea:	f9 8d       	ldd	r31, Y+25	; 0x19
    3aec:	00 80       	ld	r0, Z
    3aee:	88 8d       	ldd	r24, Y+24	; 0x18
    3af0:	99 8d       	ldd	r25, Y+25	; 0x19
    3af2:	01 96       	adiw	r24, 0x01	; 1
    3af4:	99 8f       	std	Y+25, r25	; 0x19
    3af6:	88 8f       	std	Y+24, r24	; 0x18
    3af8:	ee 89       	ldd	r30, Y+22	; 0x16
    3afa:	ff 89       	ldd	r31, Y+23	; 0x17
    3afc:	00 82       	st	Z, r0
    3afe:	8e 89       	ldd	r24, Y+22	; 0x16
    3b00:	9f 89       	ldd	r25, Y+23	; 0x17
    3b02:	01 96       	adiw	r24, 0x01	; 1
    3b04:	9f 8b       	std	Y+23, r25	; 0x17
    3b06:	8e 8b       	std	Y+22, r24	; 0x16
    3b08:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3b0a:	91 50       	subi	r25, 0x01	; 1
    3b0c:	9a 8f       	std	Y+26, r25	; 0x1a
    3b0e:	ea 8d       	ldd	r30, Y+26	; 0x1a
    3b10:	ee 23       	and	r30, r30
    3b12:	51 f7       	brne	.-44     	; 0x3ae8 <MCAL_UART_Init+0xb2>
	MCAL_DIO_SetPinDirection(UART_Tx);
    3b14:	69 85       	ldd	r22, Y+9	; 0x09
    3b16:	7a 85       	ldd	r23, Y+10	; 0x0a
    3b18:	8b 85       	ldd	r24, Y+11	; 0x0b
    3b1a:	0e 94 40 19 	call	0x3280	; 0x3280 <MCAL_DIO_SetPinDirection>



	/*-- UCSRC Register Configuration --*/
	// Initial value of UCSRC register
	Register_Type UCSRC_Config = 0b10000000;
    3b1e:	80 e8       	ldi	r24, 0x80	; 128
    3b20:	8d 83       	std	Y+5, r24	; 0x05

	// Set UART Configuration
	UCSRC_Config = UCSRC_Config | (UART_DefaultConfig.Synchronization);
    3b22:	90 91 71 00 	lds	r25, 0x0071
    3b26:	8d 81       	ldd	r24, Y+5	; 0x05
    3b28:	89 2b       	or	r24, r25
    3b2a:	8d 83       	std	Y+5, r24	; 0x05

	// Set UART Parity
	UCSRC_Config = UCSRC_Config | (UART_DefaultConfig.Parity);
    3b2c:	90 91 75 00 	lds	r25, 0x0075
    3b30:	8d 81       	ldd	r24, Y+5	; 0x05
    3b32:	89 2b       	or	r24, r25
    3b34:	8d 83       	std	Y+5, r24	; 0x05

	// Set UART Stop bit select
	UCSRC_Config = UCSRC_Config | (UART_DefaultConfig.Stop_Bit_Select);
    3b36:	90 91 76 00 	lds	r25, 0x0076
    3b3a:	8d 81       	ldd	r24, Y+5	; 0x05
    3b3c:	89 2b       	or	r24, r25
    3b3e:	8d 83       	std	Y+5, r24	; 0x05

	// Set UART Data size
	if((UART_DefaultConfig.Data_Size) == UART_9_Bits) UCSRC_Config = UCSRC_Config | UART_8_Bits;
    3b40:	80 91 74 00 	lds	r24, 0x0074
    3b44:	84 30       	cpi	r24, 0x04	; 4
    3b46:	21 f4       	brne	.+8      	; 0x3b50 <MCAL_UART_Init+0x11a>
    3b48:	8d 81       	ldd	r24, Y+5	; 0x05
    3b4a:	86 60       	ori	r24, 0x06	; 6
    3b4c:	8d 83       	std	Y+5, r24	; 0x05
    3b4e:	05 c0       	rjmp	.+10     	; 0x3b5a <MCAL_UART_Init+0x124>
	else UCSRC_Config = UCSRC_Config | (UART_DefaultConfig.Data_Size);
    3b50:	80 91 74 00 	lds	r24, 0x0074
    3b54:	9d 81       	ldd	r25, Y+5	; 0x05
    3b56:	89 2b       	or	r24, r25
    3b58:	8d 83       	std	Y+5, r24	; 0x05

	// Set UART Clock polarity
	UCSRC_Config = UCSRC_Config | (UART_DefaultConfig.Clock_Polarity);
    3b5a:	90 91 77 00 	lds	r25, 0x0077
    3b5e:	8d 81       	ldd	r24, Y+5	; 0x05
    3b60:	89 2b       	or	r24, r25
    3b62:	8d 83       	std	Y+5, r24	; 0x05

	// Sets the final configuration to UCSRC register
	UCSRC = UCSRC_Config;
    3b64:	e0 e4       	ldi	r30, 0x40	; 64
    3b66:	f0 e0       	ldi	r31, 0x00	; 0
    3b68:	8d 81       	ldd	r24, Y+5	; 0x05
    3b6a:	80 83       	st	Z, r24



	/*-- UCSRB Register Configuration --*/
	// Initial value of UCSRB register
	Register_Type UCSRB_Config = 0b00000000;
    3b6c:	1c 82       	std	Y+4, r1	; 0x04

	// Set UART Operation mode
	UCSRB_Config = UCSRB_Config | (UART_DefaultConfig.Operation_Mode);
    3b6e:	90 91 6f 00 	lds	r25, 0x006F
    3b72:	8c 81       	ldd	r24, Y+4	; 0x04
    3b74:	89 2b       	or	r24, r25
    3b76:	8c 83       	std	Y+4, r24	; 0x04

	// Set UCSZ2 Bit to complete configure if data size is 9 bits
	if((UART_DefaultConfig.Data_Size) == UART_9_Bits) UCSRB_Config = UCSRB_Config | UART_9_Bits;
    3b78:	80 91 74 00 	lds	r24, 0x0074
    3b7c:	84 30       	cpi	r24, 0x04	; 4
    3b7e:	19 f4       	brne	.+6      	; 0x3b86 <MCAL_UART_Init+0x150>
    3b80:	8c 81       	ldd	r24, Y+4	; 0x04
    3b82:	84 60       	ori	r24, 0x04	; 4
    3b84:	8c 83       	std	Y+4, r24	; 0x04

	// Enable interrupts in case of using UART with interrupt operation mode
	if((UART_DefaultConfig.Operation_Mode) == UART_Interrupt) UCSRB_Config = UCSRB_Config | ((uint8)(1<<UCSRB_RXCIE)) | ((uint8)(1<<UCSRB_TXCIE)) | ((uint8)(1<<UCSRB_UDRIE));
    3b86:	80 91 6f 00 	lds	r24, 0x006F
    3b8a:	80 3e       	cpi	r24, 0xE0	; 224
    3b8c:	19 f4       	brne	.+6      	; 0x3b94 <MCAL_UART_Init+0x15e>
    3b8e:	8c 81       	ldd	r24, Y+4	; 0x04
    3b90:	80 6e       	ori	r24, 0xE0	; 224
    3b92:	8c 83       	std	Y+4, r24	; 0x04

	// Sets the final configuration to UCSRB register
	UCSRB = UCSRB_Config;
    3b94:	ea e2       	ldi	r30, 0x2A	; 42
    3b96:	f0 e0       	ldi	r31, 0x00	; 0
    3b98:	8c 81       	ldd	r24, Y+4	; 0x04
    3b9a:	80 83       	st	Z, r24



	/*-- UCSRA Register Configuration --*/
	Register_Type UCSRA_Config = 0b00000000;
    3b9c:	1b 82       	std	Y+3, r1	; 0x03

	// Set Double Transmission Speed Configuration
	UCSRA_Config = UCSRA_Config | (UART_DefaultConfig.Double_Transmission_Speed);
    3b9e:	90 91 72 00 	lds	r25, 0x0072
    3ba2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ba4:	89 2b       	or	r24, r25
    3ba6:	8b 83       	std	Y+3, r24	; 0x03

	// Set Multi-processor Communication Configuration
	UCSRA_Config = UCSRA_Config | (UART_DefaultConfig.Multi_Processor_Comm_Mode);
    3ba8:	90 91 73 00 	lds	r25, 0x0073
    3bac:	8b 81       	ldd	r24, Y+3	; 0x03
    3bae:	89 2b       	or	r24, r25
    3bb0:	8b 83       	std	Y+3, r24	; 0x03

	// Sets the final configuration to UCSRA register
	UCSRA = UCSRA_Config;
    3bb2:	eb e2       	ldi	r30, 0x2B	; 43
    3bb4:	f0 e0       	ldi	r31, 0x00	; 0
    3bb6:	8b 81       	ldd	r24, Y+3	; 0x03
    3bb8:	80 83       	st	Z, r24



	/*----- Baud Rate Configuration ----*/
	uint16 UBRR;
	if(UART_DefaultConfig.Synchronization == UART_Synchronous) UBRR = (F_CPU/(2*UART_DefaultConfig.Baud_Rate))-1;
    3bba:	80 91 71 00 	lds	r24, 0x0071
    3bbe:	80 34       	cpi	r24, 0x40	; 64
    3bc0:	e1 f4       	brne	.+56     	; 0x3bfa <MCAL_UART_Init+0x1c4>
    3bc2:	80 91 78 00 	lds	r24, 0x0078
    3bc6:	90 91 79 00 	lds	r25, 0x0079
    3bca:	a0 91 7a 00 	lds	r26, 0x007A
    3bce:	b0 91 7b 00 	lds	r27, 0x007B
    3bd2:	9c 01       	movw	r18, r24
    3bd4:	ad 01       	movw	r20, r26
    3bd6:	22 0f       	add	r18, r18
    3bd8:	33 1f       	adc	r19, r19
    3bda:	44 1f       	adc	r20, r20
    3bdc:	55 1f       	adc	r21, r21
    3bde:	80 e0       	ldi	r24, 0x00	; 0
    3be0:	92 e1       	ldi	r25, 0x12	; 18
    3be2:	aa e7       	ldi	r26, 0x7A	; 122
    3be4:	b0 e0       	ldi	r27, 0x00	; 0
    3be6:	bc 01       	movw	r22, r24
    3be8:	cd 01       	movw	r24, r26
    3bea:	0e 94 88 21 	call	0x4310	; 0x4310 <__udivmodsi4>
    3bee:	da 01       	movw	r26, r20
    3bf0:	c9 01       	movw	r24, r18
    3bf2:	01 97       	sbiw	r24, 0x01	; 1
    3bf4:	9a 83       	std	Y+2, r25	; 0x02
    3bf6:	89 83       	std	Y+1, r24	; 0x01
    3bf8:	4f c0       	rjmp	.+158    	; 0x3c98 <MCAL_UART_Init+0x262>
	else {
		if(UART_DefaultConfig.Double_Transmission_Speed == UART_Enable_Double_Transmission_Speed) UBRR = (F_CPU/(8*UART_DefaultConfig.Baud_Rate))-1;
    3bfa:	80 91 72 00 	lds	r24, 0x0072
    3bfe:	82 30       	cpi	r24, 0x02	; 2
    3c00:	21 f5       	brne	.+72     	; 0x3c4a <MCAL_UART_Init+0x214>
    3c02:	80 91 78 00 	lds	r24, 0x0078
    3c06:	90 91 79 00 	lds	r25, 0x0079
    3c0a:	a0 91 7a 00 	lds	r26, 0x007A
    3c0e:	b0 91 7b 00 	lds	r27, 0x007B
    3c12:	88 0f       	add	r24, r24
    3c14:	99 1f       	adc	r25, r25
    3c16:	aa 1f       	adc	r26, r26
    3c18:	bb 1f       	adc	r27, r27
    3c1a:	88 0f       	add	r24, r24
    3c1c:	99 1f       	adc	r25, r25
    3c1e:	aa 1f       	adc	r26, r26
    3c20:	bb 1f       	adc	r27, r27
    3c22:	88 0f       	add	r24, r24
    3c24:	99 1f       	adc	r25, r25
    3c26:	aa 1f       	adc	r26, r26
    3c28:	bb 1f       	adc	r27, r27
    3c2a:	9c 01       	movw	r18, r24
    3c2c:	ad 01       	movw	r20, r26
    3c2e:	80 e0       	ldi	r24, 0x00	; 0
    3c30:	92 e1       	ldi	r25, 0x12	; 18
    3c32:	aa e7       	ldi	r26, 0x7A	; 122
    3c34:	b0 e0       	ldi	r27, 0x00	; 0
    3c36:	bc 01       	movw	r22, r24
    3c38:	cd 01       	movw	r24, r26
    3c3a:	0e 94 88 21 	call	0x4310	; 0x4310 <__udivmodsi4>
    3c3e:	da 01       	movw	r26, r20
    3c40:	c9 01       	movw	r24, r18
    3c42:	01 97       	sbiw	r24, 0x01	; 1
    3c44:	9a 83       	std	Y+2, r25	; 0x02
    3c46:	89 83       	std	Y+1, r24	; 0x01
    3c48:	27 c0       	rjmp	.+78     	; 0x3c98 <MCAL_UART_Init+0x262>
		else  UBRR = (F_CPU/(16*UART_DefaultConfig.Baud_Rate))-1;
    3c4a:	80 91 78 00 	lds	r24, 0x0078
    3c4e:	90 91 79 00 	lds	r25, 0x0079
    3c52:	a0 91 7a 00 	lds	r26, 0x007A
    3c56:	b0 91 7b 00 	lds	r27, 0x007B
    3c5a:	88 0f       	add	r24, r24
    3c5c:	99 1f       	adc	r25, r25
    3c5e:	aa 1f       	adc	r26, r26
    3c60:	bb 1f       	adc	r27, r27
    3c62:	88 0f       	add	r24, r24
    3c64:	99 1f       	adc	r25, r25
    3c66:	aa 1f       	adc	r26, r26
    3c68:	bb 1f       	adc	r27, r27
    3c6a:	88 0f       	add	r24, r24
    3c6c:	99 1f       	adc	r25, r25
    3c6e:	aa 1f       	adc	r26, r26
    3c70:	bb 1f       	adc	r27, r27
    3c72:	88 0f       	add	r24, r24
    3c74:	99 1f       	adc	r25, r25
    3c76:	aa 1f       	adc	r26, r26
    3c78:	bb 1f       	adc	r27, r27
    3c7a:	9c 01       	movw	r18, r24
    3c7c:	ad 01       	movw	r20, r26
    3c7e:	80 e0       	ldi	r24, 0x00	; 0
    3c80:	92 e1       	ldi	r25, 0x12	; 18
    3c82:	aa e7       	ldi	r26, 0x7A	; 122
    3c84:	b0 e0       	ldi	r27, 0x00	; 0
    3c86:	bc 01       	movw	r22, r24
    3c88:	cd 01       	movw	r24, r26
    3c8a:	0e 94 88 21 	call	0x4310	; 0x4310 <__udivmodsi4>
    3c8e:	da 01       	movw	r26, r20
    3c90:	c9 01       	movw	r24, r18
    3c92:	01 97       	sbiw	r24, 0x01	; 1
    3c94:	9a 83       	std	Y+2, r25	; 0x02
    3c96:	89 83       	std	Y+1, r24	; 0x01
	}
	UBRRH = (uint8)(UBRR>>8);
    3c98:	e0 e4       	ldi	r30, 0x40	; 64
    3c9a:	f0 e0       	ldi	r31, 0x00	; 0
    3c9c:	89 81       	ldd	r24, Y+1	; 0x01
    3c9e:	9a 81       	ldd	r25, Y+2	; 0x02
    3ca0:	89 2f       	mov	r24, r25
    3ca2:	99 27       	eor	r25, r25
    3ca4:	80 83       	st	Z, r24
	UBRRL = (uint8)(UBRR & (0xFF));
    3ca6:	e9 e2       	ldi	r30, 0x29	; 41
    3ca8:	f0 e0       	ldi	r31, 0x00	; 0
    3caa:	89 81       	ldd	r24, Y+1	; 0x01
    3cac:	80 83       	st	Z, r24




	/*------ Transmission Modes ------*/
	if(UART_DefaultConfig.Transmission_Mode == UART_TX_Only) SET_BIT(UCSRB,UCSRB_TXEN);
    3cae:	80 91 70 00 	lds	r24, 0x0070
    3cb2:	81 30       	cpi	r24, 0x01	; 1
    3cb4:	41 f4       	brne	.+16     	; 0x3cc6 <MCAL_UART_Init+0x290>
    3cb6:	aa e2       	ldi	r26, 0x2A	; 42
    3cb8:	b0 e0       	ldi	r27, 0x00	; 0
    3cba:	ea e2       	ldi	r30, 0x2A	; 42
    3cbc:	f0 e0       	ldi	r31, 0x00	; 0
    3cbe:	80 81       	ld	r24, Z
    3cc0:	88 60       	ori	r24, 0x08	; 8
    3cc2:	8c 93       	st	X, r24
    3cc4:	1e c0       	rjmp	.+60     	; 0x3d02 <MCAL_UART_Init+0x2cc>
	else if(UART_DefaultConfig.Transmission_Mode == UART_RX_Only) SET_BIT(UCSRB,UCSRB_RXEN);
    3cc6:	80 91 70 00 	lds	r24, 0x0070
    3cca:	88 23       	and	r24, r24
    3ccc:	41 f4       	brne	.+16     	; 0x3cde <MCAL_UART_Init+0x2a8>
    3cce:	aa e2       	ldi	r26, 0x2A	; 42
    3cd0:	b0 e0       	ldi	r27, 0x00	; 0
    3cd2:	ea e2       	ldi	r30, 0x2A	; 42
    3cd4:	f0 e0       	ldi	r31, 0x00	; 0
    3cd6:	80 81       	ld	r24, Z
    3cd8:	80 61       	ori	r24, 0x10	; 16
    3cda:	8c 93       	st	X, r24
    3cdc:	12 c0       	rjmp	.+36     	; 0x3d02 <MCAL_UART_Init+0x2cc>
	else if(UART_DefaultConfig.Transmission_Mode == UART_TX_RX) {
    3cde:	80 91 70 00 	lds	r24, 0x0070
    3ce2:	82 30       	cpi	r24, 0x02	; 2
    3ce4:	71 f4       	brne	.+28     	; 0x3d02 <MCAL_UART_Init+0x2cc>
		SET_BIT(UCSRB,UCSRB_TXEN);
    3ce6:	aa e2       	ldi	r26, 0x2A	; 42
    3ce8:	b0 e0       	ldi	r27, 0x00	; 0
    3cea:	ea e2       	ldi	r30, 0x2A	; 42
    3cec:	f0 e0       	ldi	r31, 0x00	; 0
    3cee:	80 81       	ld	r24, Z
    3cf0:	88 60       	ori	r24, 0x08	; 8
    3cf2:	8c 93       	st	X, r24
		SET_BIT(UCSRB,UCSRB_RXEN);
    3cf4:	aa e2       	ldi	r26, 0x2A	; 42
    3cf6:	b0 e0       	ldi	r27, 0x00	; 0
    3cf8:	ea e2       	ldi	r30, 0x2A	; 42
    3cfa:	f0 e0       	ldi	r31, 0x00	; 0
    3cfc:	80 81       	ld	r24, Z
    3cfe:	80 61       	ori	r24, 0x10	; 16
    3d00:	8c 93       	st	X, r24
	}

}
    3d02:	6a 96       	adiw	r28, 0x1a	; 26
    3d04:	0f b6       	in	r0, 0x3f	; 63
    3d06:	f8 94       	cli
    3d08:	de bf       	out	0x3e, r29	; 62
    3d0a:	0f be       	out	0x3f, r0	; 63
    3d0c:	cd bf       	out	0x3d, r28	; 61
    3d0e:	cf 91       	pop	r28
    3d10:	df 91       	pop	r29
    3d12:	08 95       	ret

00003d14 <MCAL_UART_ByteReceiveStatus>:
 * 	@ Brief 	 - Check if there is byte to receive in UART bus.
 * 	@ RetVal	 - Std_Return.
 *	  Note		 - This API return "UART_BYTE_READY" when there is byte ready to receive,
 *	  			   return "UART_NO_BYTE" when there is nobyte ready to receive.
 * ==================================================================== */
Std_Return MCAL_UART_ByteReceiveStatus(void){
    3d14:	df 93       	push	r29
    3d16:	cf 93       	push	r28
    3d18:	cd b7       	in	r28, 0x3d	; 61
    3d1a:	de b7       	in	r29, 0x3e	; 62

	return GET_BIT(UCSRA,UCSRA_RXC);
    3d1c:	eb e2       	ldi	r30, 0x2B	; 43
    3d1e:	f0 e0       	ldi	r31, 0x00	; 0
    3d20:	80 81       	ld	r24, Z
    3d22:	88 1f       	adc	r24, r24
    3d24:	88 27       	eor	r24, r24
    3d26:	88 1f       	adc	r24, r24

}
    3d28:	cf 91       	pop	r28
    3d2a:	df 91       	pop	r29
    3d2c:	08 95       	ret

00003d2e <MCAL_UART_Receive>:
 *	  Note		 - This API return "OK" when no error occurred,
 *	  			   return "UART_FRAME_ERROR" when there is error in the received frame,
 *	  			   return "UART_DATA_OVER_RUN" when the receive buffer is full,
 *	  			   return "UART_PARITY_ERROR" when there is parity error.
 * ==================================================================== */
Std_Return MCAL_UART_Receive(uint16 *UART_pRxBuf){
    3d2e:	df 93       	push	r29
    3d30:	cf 93       	push	r28
    3d32:	00 d0       	rcall	.+0      	; 0x3d34 <MCAL_UART_Receive+0x6>
    3d34:	0f 92       	push	r0
    3d36:	cd b7       	in	r28, 0x3d	; 61
    3d38:	de b7       	in	r29, 0x3e	; 62
    3d3a:	9b 83       	std	Y+3, r25	; 0x03
    3d3c:	8a 83       	std	Y+2, r24	; 0x02

	/*---- Receive UDR Register Data ---*/
	// Initialize error status with no errors
	Std_Return UART_ReturnError = OK;
    3d3e:	19 82       	std	Y+1, r1	; 0x01

	// Read UDR Register Data
	// Receive data in polling operation mode
	while(!GET_BIT(UCSRA,UCSRA_RXC));
    3d40:	eb e2       	ldi	r30, 0x2B	; 43
    3d42:	f0 e0       	ldi	r31, 0x00	; 0
    3d44:	80 81       	ld	r24, Z
    3d46:	88 23       	and	r24, r24
    3d48:	dc f7       	brge	.-10     	; 0x3d40 <MCAL_UART_Receive+0x12>
	if(UART_DefaultConfig.Data_Size == UART_9_Bits) {
    3d4a:	80 91 74 00 	lds	r24, 0x0074
    3d4e:	84 30       	cpi	r24, 0x04	; 4
    3d50:	f9 f4       	brne	.+62     	; 0x3d90 <MCAL_UART_Receive+0x62>
		*(UART_9BitDataType*)UART_pRxBuf = (GET_BIT(UCSRB,UCSRB_RXB8)<<9);
    3d52:	ea e2       	ldi	r30, 0x2A	; 42
    3d54:	f0 e0       	ldi	r31, 0x00	; 0
    3d56:	80 81       	ld	r24, Z
    3d58:	86 95       	lsr	r24
    3d5a:	88 2f       	mov	r24, r24
    3d5c:	90 e0       	ldi	r25, 0x00	; 0
    3d5e:	81 70       	andi	r24, 0x01	; 1
    3d60:	90 70       	andi	r25, 0x00	; 0
    3d62:	98 2f       	mov	r25, r24
    3d64:	88 27       	eor	r24, r24
    3d66:	99 0f       	add	r25, r25
    3d68:	ea 81       	ldd	r30, Y+2	; 0x02
    3d6a:	fb 81       	ldd	r31, Y+3	; 0x03
    3d6c:	91 83       	std	Z+1, r25	; 0x01
    3d6e:	80 83       	st	Z, r24
		*(UART_9BitDataType*)UART_pRxBuf = *(UART_9BitDataType*)UART_pRxBuf | UDR;
    3d70:	ea 81       	ldd	r30, Y+2	; 0x02
    3d72:	fb 81       	ldd	r31, Y+3	; 0x03
    3d74:	20 81       	ld	r18, Z
    3d76:	31 81       	ldd	r19, Z+1	; 0x01
    3d78:	ec e2       	ldi	r30, 0x2C	; 44
    3d7a:	f0 e0       	ldi	r31, 0x00	; 0
    3d7c:	80 81       	ld	r24, Z
    3d7e:	88 2f       	mov	r24, r24
    3d80:	90 e0       	ldi	r25, 0x00	; 0
    3d82:	82 2b       	or	r24, r18
    3d84:	93 2b       	or	r25, r19
    3d86:	ea 81       	ldd	r30, Y+2	; 0x02
    3d88:	fb 81       	ldd	r31, Y+3	; 0x03
    3d8a:	91 83       	std	Z+1, r25	; 0x01
    3d8c:	80 83       	st	Z, r24
    3d8e:	06 c0       	rjmp	.+12     	; 0x3d9c <MCAL_UART_Receive+0x6e>
	}
	else *(UART_8BitDataType*)UART_pRxBuf = UDR;
    3d90:	ea 81       	ldd	r30, Y+2	; 0x02
    3d92:	fb 81       	ldd	r31, Y+3	; 0x03
    3d94:	ac e2       	ldi	r26, 0x2C	; 44
    3d96:	b0 e0       	ldi	r27, 0x00	; 0
    3d98:	8c 91       	ld	r24, X
    3d9a:	80 83       	st	Z, r24

	// Check if there is frame error
	if(GET_BIT(UCSRA,UCSRA_FE)) UART_ReturnError = UART_FRAME_ERROR;
    3d9c:	eb e2       	ldi	r30, 0x2B	; 43
    3d9e:	f0 e0       	ldi	r31, 0x00	; 0
    3da0:	80 81       	ld	r24, Z
    3da2:	82 95       	swap	r24
    3da4:	8f 70       	andi	r24, 0x0F	; 15
    3da6:	88 2f       	mov	r24, r24
    3da8:	90 e0       	ldi	r25, 0x00	; 0
    3daa:	81 70       	andi	r24, 0x01	; 1
    3dac:	90 70       	andi	r25, 0x00	; 0
    3dae:	88 23       	and	r24, r24
    3db0:	19 f0       	breq	.+6      	; 0x3db8 <MCAL_UART_Receive+0x8a>
    3db2:	85 e0       	ldi	r24, 0x05	; 5
    3db4:	89 83       	std	Y+1, r24	; 0x01
    3db6:	0e c0       	rjmp	.+28     	; 0x3dd4 <MCAL_UART_Receive+0xa6>

	// Check if there is data over run error
	else if(GET_BIT(UCSRA,UCSRA_DOR)) UART_ReturnError = UART_DATA_OVER_RUN;
    3db8:	eb e2       	ldi	r30, 0x2B	; 43
    3dba:	f0 e0       	ldi	r31, 0x00	; 0
    3dbc:	80 81       	ld	r24, Z
    3dbe:	86 95       	lsr	r24
    3dc0:	86 95       	lsr	r24
    3dc2:	86 95       	lsr	r24
    3dc4:	88 2f       	mov	r24, r24
    3dc6:	90 e0       	ldi	r25, 0x00	; 0
    3dc8:	81 70       	andi	r24, 0x01	; 1
    3dca:	90 70       	andi	r25, 0x00	; 0
    3dcc:	88 23       	and	r24, r24
    3dce:	11 f0       	breq	.+4      	; 0x3dd4 <MCAL_UART_Receive+0xa6>
    3dd0:	86 e0       	ldi	r24, 0x06	; 6
    3dd2:	89 83       	std	Y+1, r24	; 0x01

	// Check if there is parity error
	if(UART_DefaultConfig.Parity != UART_Parity_Disable){
    3dd4:	80 91 75 00 	lds	r24, 0x0075
    3dd8:	88 23       	and	r24, r24
    3dda:	69 f0       	breq	.+26     	; 0x3df6 <MCAL_UART_Receive+0xc8>
		if(GET_BIT(UCSRA,UCSRA_PE)) UART_ReturnError = UART_PARITY_ERROR;
    3ddc:	eb e2       	ldi	r30, 0x2B	; 43
    3dde:	f0 e0       	ldi	r31, 0x00	; 0
    3de0:	80 81       	ld	r24, Z
    3de2:	86 95       	lsr	r24
    3de4:	86 95       	lsr	r24
    3de6:	88 2f       	mov	r24, r24
    3de8:	90 e0       	ldi	r25, 0x00	; 0
    3dea:	81 70       	andi	r24, 0x01	; 1
    3dec:	90 70       	andi	r25, 0x00	; 0
    3dee:	88 23       	and	r24, r24
    3df0:	11 f0       	breq	.+4      	; 0x3df6 <MCAL_UART_Receive+0xc8>
    3df2:	87 e0       	ldi	r24, 0x07	; 7
    3df4:	89 83       	std	Y+1, r24	; 0x01
	}

	return UART_ReturnError;
    3df6:	89 81       	ldd	r24, Y+1	; 0x01

}
    3df8:	0f 90       	pop	r0
    3dfa:	0f 90       	pop	r0
    3dfc:	0f 90       	pop	r0
    3dfe:	cf 91       	pop	r28
    3e00:	df 91       	pop	r29
    3e02:	08 95       	ret

00003e04 <MCAL_UART_Send>:
 * 	@ Func  	 - MCAL_UART_Send
 * 	@ Brief 	 - Send data to UART bus.
 * 	@ Param [in] - UART_pTxBuf: Data buffer for data to be sent.
 * 	@ RetVal	 - None.
 * ==================================================================== */
void MCAL_UART_Send(uint16 UART_pTxBuf){
    3e04:	df 93       	push	r29
    3e06:	cf 93       	push	r28
    3e08:	00 d0       	rcall	.+0      	; 0x3e0a <MCAL_UART_Send+0x6>
    3e0a:	00 d0       	rcall	.+0      	; 0x3e0c <MCAL_UART_Send+0x8>
    3e0c:	cd b7       	in	r28, 0x3d	; 61
    3e0e:	de b7       	in	r29, 0x3e	; 62
    3e10:	9a 83       	std	Y+2, r25	; 0x02
    3e12:	89 83       	std	Y+1, r24	; 0x01

	/*----- Send UDR Register Data ----*/
	// Send data in polling operation mode
	while(!GET_BIT(UCSRA,UCSRA_UDRE));
    3e14:	eb e2       	ldi	r30, 0x2B	; 43
    3e16:	f0 e0       	ldi	r31, 0x00	; 0
    3e18:	80 81       	ld	r24, Z
    3e1a:	82 95       	swap	r24
    3e1c:	86 95       	lsr	r24
    3e1e:	87 70       	andi	r24, 0x07	; 7
    3e20:	88 2f       	mov	r24, r24
    3e22:	90 e0       	ldi	r25, 0x00	; 0
    3e24:	81 70       	andi	r24, 0x01	; 1
    3e26:	90 70       	andi	r25, 0x00	; 0
    3e28:	00 97       	sbiw	r24, 0x00	; 0
    3e2a:	a1 f3       	breq	.-24     	; 0x3e14 <MCAL_UART_Send+0x10>
	if(UART_DefaultConfig.Data_Size == UART_9_Bits) {
    3e2c:	80 91 74 00 	lds	r24, 0x0074
    3e30:	84 30       	cpi	r24, 0x04	; 4
    3e32:	41 f5       	brne	.+80     	; 0x3e84 <MCAL_UART_Send+0x80>
		switch(GET_BIT(UART_pTxBuf,9)){
    3e34:	89 81       	ldd	r24, Y+1	; 0x01
    3e36:	9a 81       	ldd	r25, Y+2	; 0x02
    3e38:	89 2f       	mov	r24, r25
    3e3a:	99 27       	eor	r25, r25
    3e3c:	86 95       	lsr	r24
    3e3e:	9c 01       	movw	r18, r24
    3e40:	21 70       	andi	r18, 0x01	; 1
    3e42:	30 70       	andi	r19, 0x00	; 0
    3e44:	3c 83       	std	Y+4, r19	; 0x04
    3e46:	2b 83       	std	Y+3, r18	; 0x03
    3e48:	8b 81       	ldd	r24, Y+3	; 0x03
    3e4a:	9c 81       	ldd	r25, Y+4	; 0x04
    3e4c:	00 97       	sbiw	r24, 0x00	; 0
    3e4e:	31 f0       	breq	.+12     	; 0x3e5c <MCAL_UART_Send+0x58>
    3e50:	2b 81       	ldd	r18, Y+3	; 0x03
    3e52:	3c 81       	ldd	r19, Y+4	; 0x04
    3e54:	21 30       	cpi	r18, 0x01	; 1
    3e56:	31 05       	cpc	r19, r1
    3e58:	49 f0       	breq	.+18     	; 0x3e6c <MCAL_UART_Send+0x68>
    3e5a:	0f c0       	rjmp	.+30     	; 0x3e7a <MCAL_UART_Send+0x76>
			case 0: CLR_BIT(UCSRB,UCSRB_TXB8); break;
    3e5c:	aa e2       	ldi	r26, 0x2A	; 42
    3e5e:	b0 e0       	ldi	r27, 0x00	; 0
    3e60:	ea e2       	ldi	r30, 0x2A	; 42
    3e62:	f0 e0       	ldi	r31, 0x00	; 0
    3e64:	80 81       	ld	r24, Z
    3e66:	8e 7f       	andi	r24, 0xFE	; 254
    3e68:	8c 93       	st	X, r24
    3e6a:	07 c0       	rjmp	.+14     	; 0x3e7a <MCAL_UART_Send+0x76>
			case 1: SET_BIT(UCSRB,UCSRB_TXB8); break;
    3e6c:	aa e2       	ldi	r26, 0x2A	; 42
    3e6e:	b0 e0       	ldi	r27, 0x00	; 0
    3e70:	ea e2       	ldi	r30, 0x2A	; 42
    3e72:	f0 e0       	ldi	r31, 0x00	; 0
    3e74:	80 81       	ld	r24, Z
    3e76:	81 60       	ori	r24, 0x01	; 1
    3e78:	8c 93       	st	X, r24
		}
		UDR = (uint8)(UART_pTxBuf & (0xFF));
    3e7a:	ec e2       	ldi	r30, 0x2C	; 44
    3e7c:	f0 e0       	ldi	r31, 0x00	; 0
    3e7e:	89 81       	ldd	r24, Y+1	; 0x01
    3e80:	80 83       	st	Z, r24
    3e82:	04 c0       	rjmp	.+8      	; 0x3e8c <MCAL_UART_Send+0x88>
	}
	else UDR = (UART_8BitDataType)UART_pTxBuf;
    3e84:	ec e2       	ldi	r30, 0x2C	; 44
    3e86:	f0 e0       	ldi	r31, 0x00	; 0
    3e88:	89 81       	ldd	r24, Y+1	; 0x01
    3e8a:	80 83       	st	Z, r24
	while(!GET_BIT(UCSRA,UCSRA_TXC));
    3e8c:	eb e2       	ldi	r30, 0x2B	; 43
    3e8e:	f0 e0       	ldi	r31, 0x00	; 0
    3e90:	80 81       	ld	r24, Z
    3e92:	82 95       	swap	r24
    3e94:	86 95       	lsr	r24
    3e96:	86 95       	lsr	r24
    3e98:	83 70       	andi	r24, 0x03	; 3
    3e9a:	88 2f       	mov	r24, r24
    3e9c:	90 e0       	ldi	r25, 0x00	; 0
    3e9e:	81 70       	andi	r24, 0x01	; 1
    3ea0:	90 70       	andi	r25, 0x00	; 0
    3ea2:	00 97       	sbiw	r24, 0x00	; 0
    3ea4:	99 f3       	breq	.-26     	; 0x3e8c <MCAL_UART_Send+0x88>

}
    3ea6:	0f 90       	pop	r0
    3ea8:	0f 90       	pop	r0
    3eaa:	0f 90       	pop	r0
    3eac:	0f 90       	pop	r0
    3eae:	cf 91       	pop	r28
    3eb0:	df 91       	pop	r29
    3eb2:	08 95       	ret

00003eb4 <MCAL_UART_SendString>:
 * 	@ Brief 	 - Send string to UART bus.
 * 	@ Param [in] - UART_String: String which wanted to be sent.
 * 	@ RetVal	 - None.
 * 	  Note		 - This API should be used with 8 bits data size configuration.
 * ==================================================================== */
void MCAL_UART_SendString(const char *UART_String){
    3eb4:	df 93       	push	r29
    3eb6:	cf 93       	push	r28
    3eb8:	00 d0       	rcall	.+0      	; 0x3eba <MCAL_UART_SendString+0x6>
    3eba:	0f 92       	push	r0
    3ebc:	cd b7       	in	r28, 0x3d	; 61
    3ebe:	de b7       	in	r29, 0x3e	; 62
    3ec0:	9b 83       	std	Y+3, r25	; 0x03
    3ec2:	8a 83       	std	Y+2, r24	; 0x02

	/*-------- Send String Data -------*/
	// Initialize string array index
	uint8 UART_StringIdx = 0;
    3ec4:	19 82       	std	Y+1, r1	; 0x01

	// Send first char in the string
	MCAL_UART_Send(*((UART_8BitDataType*)UART_String+UART_StringIdx));
    3ec6:	2a 81       	ldd	r18, Y+2	; 0x02
    3ec8:	3b 81       	ldd	r19, Y+3	; 0x03
    3eca:	89 81       	ldd	r24, Y+1	; 0x01
    3ecc:	88 2f       	mov	r24, r24
    3ece:	90 e0       	ldi	r25, 0x00	; 0
    3ed0:	f9 01       	movw	r30, r18
    3ed2:	e8 0f       	add	r30, r24
    3ed4:	f9 1f       	adc	r31, r25
    3ed6:	80 81       	ld	r24, Z
    3ed8:	88 2f       	mov	r24, r24
    3eda:	90 e0       	ldi	r25, 0x00	; 0
    3edc:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <MCAL_UART_Send>
    3ee0:	10 c0       	rjmp	.+32     	; 0x3f02 <MCAL_UART_SendString+0x4e>

	// Looping in string array and send each character
	while(*((UART_8BitDataType*)UART_String+UART_StringIdx) != '\0'){
		UART_StringIdx++;
    3ee2:	89 81       	ldd	r24, Y+1	; 0x01
    3ee4:	8f 5f       	subi	r24, 0xFF	; 255
    3ee6:	89 83       	std	Y+1, r24	; 0x01
		MCAL_UART_Send(*((UART_8BitDataType*)UART_String+UART_StringIdx));
    3ee8:	2a 81       	ldd	r18, Y+2	; 0x02
    3eea:	3b 81       	ldd	r19, Y+3	; 0x03
    3eec:	89 81       	ldd	r24, Y+1	; 0x01
    3eee:	88 2f       	mov	r24, r24
    3ef0:	90 e0       	ldi	r25, 0x00	; 0
    3ef2:	f9 01       	movw	r30, r18
    3ef4:	e8 0f       	add	r30, r24
    3ef6:	f9 1f       	adc	r31, r25
    3ef8:	80 81       	ld	r24, Z
    3efa:	88 2f       	mov	r24, r24
    3efc:	90 e0       	ldi	r25, 0x00	; 0
    3efe:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <MCAL_UART_Send>

	// Send first char in the string
	MCAL_UART_Send(*((UART_8BitDataType*)UART_String+UART_StringIdx));

	// Looping in string array and send each character
	while(*((UART_8BitDataType*)UART_String+UART_StringIdx) != '\0'){
    3f02:	2a 81       	ldd	r18, Y+2	; 0x02
    3f04:	3b 81       	ldd	r19, Y+3	; 0x03
    3f06:	89 81       	ldd	r24, Y+1	; 0x01
    3f08:	88 2f       	mov	r24, r24
    3f0a:	90 e0       	ldi	r25, 0x00	; 0
    3f0c:	f9 01       	movw	r30, r18
    3f0e:	e8 0f       	add	r30, r24
    3f10:	f9 1f       	adc	r31, r25
    3f12:	80 81       	ld	r24, Z
    3f14:	88 23       	and	r24, r24
    3f16:	29 f7       	brne	.-54     	; 0x3ee2 <MCAL_UART_SendString+0x2e>
		UART_StringIdx++;
		MCAL_UART_Send(*((UART_8BitDataType*)UART_String+UART_StringIdx));
	}

}
    3f18:	0f 90       	pop	r0
    3f1a:	0f 90       	pop	r0
    3f1c:	0f 90       	pop	r0
    3f1e:	cf 91       	pop	r28
    3f20:	df 91       	pop	r29
    3f22:	08 95       	ret

00003f24 <MCAL_UART_ReadString>:
 * 	@ Param [Out]- UART_String: Pointer to char array to store string on it.
 * 	@ Param [in] - UART_StringLength: Length of the received string.
 * 	@ RetVal	 - None.
 * 	  Note		 - This API should be used with 8 bits data size configuration.
 * ==================================================================== */
void MCAL_UART_ReadString(char *UART_String){
    3f24:	df 93       	push	r29
    3f26:	cf 93       	push	r28
    3f28:	00 d0       	rcall	.+0      	; 0x3f2a <MCAL_UART_ReadString+0x6>
    3f2a:	0f 92       	push	r0
    3f2c:	cd b7       	in	r28, 0x3d	; 61
    3f2e:	de b7       	in	r29, 0x3e	; 62
    3f30:	9b 83       	std	Y+3, r25	; 0x03
    3f32:	8a 83       	std	Y+2, r24	; 0x02

	/*-------- Receive String Data -------*/
	// Initialize string array index
	uint8 UART_StringIdx = 0;
    3f34:	19 82       	std	Y+1, r1	; 0x01

	// Receive first char in the string
	MCAL_UART_Receive(UART_String+UART_StringIdx);
    3f36:	2a 81       	ldd	r18, Y+2	; 0x02
    3f38:	3b 81       	ldd	r19, Y+3	; 0x03
    3f3a:	89 81       	ldd	r24, Y+1	; 0x01
    3f3c:	88 2f       	mov	r24, r24
    3f3e:	90 e0       	ldi	r25, 0x00	; 0
    3f40:	82 0f       	add	r24, r18
    3f42:	93 1f       	adc	r25, r19
    3f44:	0e 94 97 1e 	call	0x3d2e	; 0x3d2e <MCAL_UART_Receive>
    3f48:	0c c0       	rjmp	.+24     	; 0x3f62 <MCAL_UART_ReadString+0x3e>

	// Looping in string array and receive each character
	while(*((UART_8BitDataType*)UART_String+UART_StringIdx) != '#'){
		UART_StringIdx++;
    3f4a:	89 81       	ldd	r24, Y+1	; 0x01
    3f4c:	8f 5f       	subi	r24, 0xFF	; 255
    3f4e:	89 83       	std	Y+1, r24	; 0x01
		MCAL_UART_Receive(UART_String+UART_StringIdx);
    3f50:	2a 81       	ldd	r18, Y+2	; 0x02
    3f52:	3b 81       	ldd	r19, Y+3	; 0x03
    3f54:	89 81       	ldd	r24, Y+1	; 0x01
    3f56:	88 2f       	mov	r24, r24
    3f58:	90 e0       	ldi	r25, 0x00	; 0
    3f5a:	82 0f       	add	r24, r18
    3f5c:	93 1f       	adc	r25, r19
    3f5e:	0e 94 97 1e 	call	0x3d2e	; 0x3d2e <MCAL_UART_Receive>

	// Receive first char in the string
	MCAL_UART_Receive(UART_String+UART_StringIdx);

	// Looping in string array and receive each character
	while(*((UART_8BitDataType*)UART_String+UART_StringIdx) != '#'){
    3f62:	89 81       	ldd	r24, Y+1	; 0x01
    3f64:	28 2f       	mov	r18, r24
    3f66:	30 e0       	ldi	r19, 0x00	; 0
    3f68:	8a 81       	ldd	r24, Y+2	; 0x02
    3f6a:	9b 81       	ldd	r25, Y+3	; 0x03
    3f6c:	fc 01       	movw	r30, r24
    3f6e:	e2 0f       	add	r30, r18
    3f70:	f3 1f       	adc	r31, r19
    3f72:	80 81       	ld	r24, Z
    3f74:	83 32       	cpi	r24, 0x23	; 35
    3f76:	49 f7       	brne	.-46     	; 0x3f4a <MCAL_UART_ReadString+0x26>
		UART_StringIdx++;
		MCAL_UART_Receive(UART_String+UART_StringIdx);
	}

	// Delete the # and replace it with \0
	*((UART_8BitDataType*)UART_String+UART_StringIdx) = '\0';
    3f78:	89 81       	ldd	r24, Y+1	; 0x01
    3f7a:	28 2f       	mov	r18, r24
    3f7c:	30 e0       	ldi	r19, 0x00	; 0
    3f7e:	8a 81       	ldd	r24, Y+2	; 0x02
    3f80:	9b 81       	ldd	r25, Y+3	; 0x03
    3f82:	fc 01       	movw	r30, r24
    3f84:	e2 0f       	add	r30, r18
    3f86:	f3 1f       	adc	r31, r19
    3f88:	10 82       	st	Z, r1

}
    3f8a:	0f 90       	pop	r0
    3f8c:	0f 90       	pop	r0
    3f8e:	0f 90       	pop	r0
    3f90:	cf 91       	pop	r28
    3f92:	df 91       	pop	r29
    3f94:	08 95       	ret

00003f96 <__vector_13>:

/* =======================================================================
 * 	@ Brief: Call back function when data received complete interrupt occur.
 * ==================================================================== */
void __vector_13 (void) __attribute__((signal));
void __vector_13 (void){
    3f96:	1f 92       	push	r1
    3f98:	0f 92       	push	r0
    3f9a:	0f b6       	in	r0, 0x3f	; 63
    3f9c:	0f 92       	push	r0
    3f9e:	11 24       	eor	r1, r1
    3fa0:	2f 93       	push	r18
    3fa2:	3f 93       	push	r19
    3fa4:	4f 93       	push	r20
    3fa6:	5f 93       	push	r21
    3fa8:	6f 93       	push	r22
    3faa:	7f 93       	push	r23
    3fac:	8f 93       	push	r24
    3fae:	9f 93       	push	r25
    3fb0:	af 93       	push	r26
    3fb2:	bf 93       	push	r27
    3fb4:	ef 93       	push	r30
    3fb6:	ff 93       	push	r31
    3fb8:	df 93       	push	r29
    3fba:	cf 93       	push	r28
    3fbc:	cd b7       	in	r28, 0x3d	; 61
    3fbe:	de b7       	in	r29, 0x3e	; 62

	/*------- Call Back Function --------*/
	if(UART_DefaultConfig.CallBackFunc_RxComplete != NULL) UART_DefaultConfig.CallBackFunc_RxComplete();
    3fc0:	80 91 7c 00 	lds	r24, 0x007C
    3fc4:	90 91 7d 00 	lds	r25, 0x007D
    3fc8:	00 97       	sbiw	r24, 0x00	; 0
    3fca:	29 f0       	breq	.+10     	; 0x3fd6 <__vector_13+0x40>
    3fcc:	e0 91 7c 00 	lds	r30, 0x007C
    3fd0:	f0 91 7d 00 	lds	r31, 0x007D
    3fd4:	09 95       	icall

}
    3fd6:	cf 91       	pop	r28
    3fd8:	df 91       	pop	r29
    3fda:	ff 91       	pop	r31
    3fdc:	ef 91       	pop	r30
    3fde:	bf 91       	pop	r27
    3fe0:	af 91       	pop	r26
    3fe2:	9f 91       	pop	r25
    3fe4:	8f 91       	pop	r24
    3fe6:	7f 91       	pop	r23
    3fe8:	6f 91       	pop	r22
    3fea:	5f 91       	pop	r21
    3fec:	4f 91       	pop	r20
    3fee:	3f 91       	pop	r19
    3ff0:	2f 91       	pop	r18
    3ff2:	0f 90       	pop	r0
    3ff4:	0f be       	out	0x3f, r0	; 63
    3ff6:	0f 90       	pop	r0
    3ff8:	1f 90       	pop	r1
    3ffa:	18 95       	reti

00003ffc <__vector_14>:

/* =======================================================================
 * 	@ Brief: Call back function when data register is empty interrupt occur.
 * ==================================================================== */
void __vector_14 (void) __attribute__((signal));
void __vector_14 (void){
    3ffc:	1f 92       	push	r1
    3ffe:	0f 92       	push	r0
    4000:	0f b6       	in	r0, 0x3f	; 63
    4002:	0f 92       	push	r0
    4004:	11 24       	eor	r1, r1
    4006:	2f 93       	push	r18
    4008:	3f 93       	push	r19
    400a:	4f 93       	push	r20
    400c:	5f 93       	push	r21
    400e:	6f 93       	push	r22
    4010:	7f 93       	push	r23
    4012:	8f 93       	push	r24
    4014:	9f 93       	push	r25
    4016:	af 93       	push	r26
    4018:	bf 93       	push	r27
    401a:	ef 93       	push	r30
    401c:	ff 93       	push	r31
    401e:	df 93       	push	r29
    4020:	cf 93       	push	r28
    4022:	cd b7       	in	r28, 0x3d	; 61
    4024:	de b7       	in	r29, 0x3e	; 62

	/*------- Call Back Function --------*/
	if(UART_DefaultConfig.CallBackFunc_DataRegEmpty != NULL) UART_DefaultConfig.CallBackFunc_DataRegEmpty();
    4026:	80 91 80 00 	lds	r24, 0x0080
    402a:	90 91 81 00 	lds	r25, 0x0081
    402e:	00 97       	sbiw	r24, 0x00	; 0
    4030:	29 f0       	breq	.+10     	; 0x403c <__vector_14+0x40>
    4032:	e0 91 80 00 	lds	r30, 0x0080
    4036:	f0 91 81 00 	lds	r31, 0x0081
    403a:	09 95       	icall

}
    403c:	cf 91       	pop	r28
    403e:	df 91       	pop	r29
    4040:	ff 91       	pop	r31
    4042:	ef 91       	pop	r30
    4044:	bf 91       	pop	r27
    4046:	af 91       	pop	r26
    4048:	9f 91       	pop	r25
    404a:	8f 91       	pop	r24
    404c:	7f 91       	pop	r23
    404e:	6f 91       	pop	r22
    4050:	5f 91       	pop	r21
    4052:	4f 91       	pop	r20
    4054:	3f 91       	pop	r19
    4056:	2f 91       	pop	r18
    4058:	0f 90       	pop	r0
    405a:	0f be       	out	0x3f, r0	; 63
    405c:	0f 90       	pop	r0
    405e:	1f 90       	pop	r1
    4060:	18 95       	reti

00004062 <__vector_15>:

/* =======================================================================
 * 	@ Brief: Call back function when data transmit is complete interrupt occur.
 * ==================================================================== */
void __vector_15 (void) __attribute__((signal));
void __vector_15 (void){
    4062:	1f 92       	push	r1
    4064:	0f 92       	push	r0
    4066:	0f b6       	in	r0, 0x3f	; 63
    4068:	0f 92       	push	r0
    406a:	11 24       	eor	r1, r1
    406c:	2f 93       	push	r18
    406e:	3f 93       	push	r19
    4070:	4f 93       	push	r20
    4072:	5f 93       	push	r21
    4074:	6f 93       	push	r22
    4076:	7f 93       	push	r23
    4078:	8f 93       	push	r24
    407a:	9f 93       	push	r25
    407c:	af 93       	push	r26
    407e:	bf 93       	push	r27
    4080:	ef 93       	push	r30
    4082:	ff 93       	push	r31
    4084:	df 93       	push	r29
    4086:	cf 93       	push	r28
    4088:	cd b7       	in	r28, 0x3d	; 61
    408a:	de b7       	in	r29, 0x3e	; 62

	/*------- Call Back Function --------*/
	if(UART_DefaultConfig.CallBackFunc_TxComplete != NULL) UART_DefaultConfig.CallBackFunc_TxComplete();
    408c:	80 91 7e 00 	lds	r24, 0x007E
    4090:	90 91 7f 00 	lds	r25, 0x007F
    4094:	00 97       	sbiw	r24, 0x00	; 0
    4096:	29 f0       	breq	.+10     	; 0x40a2 <__vector_15+0x40>
    4098:	e0 91 7e 00 	lds	r30, 0x007E
    409c:	f0 91 7f 00 	lds	r31, 0x007F
    40a0:	09 95       	icall

}
    40a2:	cf 91       	pop	r28
    40a4:	df 91       	pop	r29
    40a6:	ff 91       	pop	r31
    40a8:	ef 91       	pop	r30
    40aa:	bf 91       	pop	r27
    40ac:	af 91       	pop	r26
    40ae:	9f 91       	pop	r25
    40b0:	8f 91       	pop	r24
    40b2:	7f 91       	pop	r23
    40b4:	6f 91       	pop	r22
    40b6:	5f 91       	pop	r21
    40b8:	4f 91       	pop	r20
    40ba:	3f 91       	pop	r19
    40bc:	2f 91       	pop	r18
    40be:	0f 90       	pop	r0
    40c0:	0f be       	out	0x3f, r0	; 63
    40c2:	0f 90       	pop	r0
    40c4:	1f 90       	pop	r1
    40c6:	18 95       	reti

000040c8 <HAL_LED_Init>:
 *	  Note		 - This API return "OK" when no error occurred,
 *	  			   return "INVALID_PORT" when the entered port is not valid,
 *	  			   return "WRONG_PIN" when the entered pin is not valid,
 *	  			   return "UNKNOWN"	when there's unknown error.
 * ==================================================================== */
Std_Return HAL_LED_Init(LED_Type LED){
    40c8:	df 93       	push	r29
    40ca:	cf 93       	push	r28
    40cc:	00 d0       	rcall	.+0      	; 0x40ce <HAL_LED_Init+0x6>
    40ce:	00 d0       	rcall	.+0      	; 0x40d0 <HAL_LED_Init+0x8>
    40d0:	00 d0       	rcall	.+0      	; 0x40d2 <HAL_LED_Init+0xa>
    40d2:	cd b7       	in	r28, 0x3d	; 61
    40d4:	de b7       	in	r29, 0x3e	; 62
    40d6:	9e 83       	std	Y+6, r25	; 0x06
    40d8:	8d 83       	std	Y+5, r24	; 0x05

	/*------ DIO Pin Configuration ------*/
	DIO_PinType LED_Pin;
	LED_Pin.Port = LED.Port;
    40da:	8d 81       	ldd	r24, Y+5	; 0x05
    40dc:	8a 83       	std	Y+2, r24	; 0x02
	LED_Pin.Pin_Number = LED.Pin_Number;
    40de:	8e 81       	ldd	r24, Y+6	; 0x06
    40e0:	8b 83       	std	Y+3, r24	; 0x03
	LED_Pin.Direction = DIO_Output;
    40e2:	81 e0       	ldi	r24, 0x01	; 1
    40e4:	8c 83       	std	Y+4, r24	; 0x04



	/*------ Set Pin as Output Pin ------*/
	Std_Return DIO_Return;
	DIO_Return = MCAL_DIO_SetPinDirection(LED_Pin);
    40e6:	6a 81       	ldd	r22, Y+2	; 0x02
    40e8:	7b 81       	ldd	r23, Y+3	; 0x03
    40ea:	8c 81       	ldd	r24, Y+4	; 0x04
    40ec:	0e 94 40 19 	call	0x3280	; 0x3280 <MCAL_DIO_SetPinDirection>
    40f0:	89 83       	std	Y+1, r24	; 0x01

	return DIO_Return;
    40f2:	89 81       	ldd	r24, Y+1	; 0x01

}
    40f4:	26 96       	adiw	r28, 0x06	; 6
    40f6:	0f b6       	in	r0, 0x3f	; 63
    40f8:	f8 94       	cli
    40fa:	de bf       	out	0x3e, r29	; 62
    40fc:	0f be       	out	0x3f, r0	; 63
    40fe:	cd bf       	out	0x3d, r28	; 61
    4100:	cf 91       	pop	r28
    4102:	df 91       	pop	r29
    4104:	08 95       	ret

00004106 <HAL_LED_On>:
 * 	@ Param [in] - LED: LED which is needed to be turn on.
 * 	@ RetVal	 - Std_Return.
 *	  Note		 - This API return "OK" when no error occurred,
 *	  			   return "INVALID_LED" when the entered LED is not valid.
 * ==================================================================== */
Std_Return HAL_LED_On(LED_Type LED){
    4106:	df 93       	push	r29
    4108:	cf 93       	push	r28
    410a:	cd b7       	in	r28, 0x3d	; 61
    410c:	de b7       	in	r29, 0x3e	; 62
    410e:	27 97       	sbiw	r28, 0x07	; 7
    4110:	0f b6       	in	r0, 0x3f	; 63
    4112:	f8 94       	cli
    4114:	de bf       	out	0x3e, r29	; 62
    4116:	0f be       	out	0x3f, r0	; 63
    4118:	cd bf       	out	0x3d, r28	; 61
    411a:	9f 83       	std	Y+7, r25	; 0x07
    411c:	8e 83       	std	Y+6, r24	; 0x06

	/*------ DIO Pin Configuration ------*/
	DIO_PinType LED_Pin;
	LED_Pin.Port = LED.Port;
    411e:	8e 81       	ldd	r24, Y+6	; 0x06
    4120:	8b 83       	std	Y+3, r24	; 0x03
	LED_Pin.Pin_Number = LED.Pin_Number;
    4122:	8f 81       	ldd	r24, Y+7	; 0x07
    4124:	8c 83       	std	Y+4, r24	; 0x04



	/*---------- Set LED Pin -----------*/
	// Initialize error status with no errors
	Std_Return LED_ReturnError = OK;
    4126:	1a 82       	std	Y+2, r1	; 0x02

	// Write LED pin to set and receive if there is any error from DIO
	Std_Return DIO_Return;
	DIO_Return = MCAL_DIO_WritePin(LED_Pin,DIO_Set);
    4128:	6b 81       	ldd	r22, Y+3	; 0x03
    412a:	7c 81       	ldd	r23, Y+4	; 0x04
    412c:	8d 81       	ldd	r24, Y+5	; 0x05
    412e:	41 e0       	ldi	r20, 0x01	; 1
    4130:	0e 94 cb 1a 	call	0x3596	; 0x3596 <MCAL_DIO_WritePin>
    4134:	89 83       	std	Y+1, r24	; 0x01

	// There is error returned from DIO
	if(DIO_Return != OK) LED_ReturnError = INVALID_LED;
    4136:	89 81       	ldd	r24, Y+1	; 0x01
    4138:	88 23       	and	r24, r24
    413a:	11 f0       	breq	.+4      	; 0x4140 <HAL_LED_On+0x3a>
    413c:	84 e0       	ldi	r24, 0x04	; 4
    413e:	8a 83       	std	Y+2, r24	; 0x02

	return LED_ReturnError;
    4140:	8a 81       	ldd	r24, Y+2	; 0x02

}
    4142:	27 96       	adiw	r28, 0x07	; 7
    4144:	0f b6       	in	r0, 0x3f	; 63
    4146:	f8 94       	cli
    4148:	de bf       	out	0x3e, r29	; 62
    414a:	0f be       	out	0x3f, r0	; 63
    414c:	cd bf       	out	0x3d, r28	; 61
    414e:	cf 91       	pop	r28
    4150:	df 91       	pop	r29
    4152:	08 95       	ret

00004154 <HAL_LED_Off>:
 * 	@ Param [in] - LED: LED which is needed to be turn off.
 * 	@ RetVal	 - Std_Return.
 *	  Note		 - This API return "OK" when no error occurred,
 *	  			   return "INVALID_LED" when the entered LED is not valid.
 * ==================================================================== */
Std_Return HAL_LED_Off(LED_Type LED){
    4154:	df 93       	push	r29
    4156:	cf 93       	push	r28
    4158:	cd b7       	in	r28, 0x3d	; 61
    415a:	de b7       	in	r29, 0x3e	; 62
    415c:	27 97       	sbiw	r28, 0x07	; 7
    415e:	0f b6       	in	r0, 0x3f	; 63
    4160:	f8 94       	cli
    4162:	de bf       	out	0x3e, r29	; 62
    4164:	0f be       	out	0x3f, r0	; 63
    4166:	cd bf       	out	0x3d, r28	; 61
    4168:	9f 83       	std	Y+7, r25	; 0x07
    416a:	8e 83       	std	Y+6, r24	; 0x06

	/*------ DIO Pin Configuration ------*/
	DIO_PinType LED_Pin;
	LED_Pin.Port = LED.Port;
    416c:	8e 81       	ldd	r24, Y+6	; 0x06
    416e:	8b 83       	std	Y+3, r24	; 0x03
	LED_Pin.Pin_Number = LED.Pin_Number;
    4170:	8f 81       	ldd	r24, Y+7	; 0x07
    4172:	8c 83       	std	Y+4, r24	; 0x04



	/*---------- Reset LED Pin ----------*/
	// Initialize error status with no errors
	Std_Return LED_ReturnError = OK;
    4174:	1a 82       	std	Y+2, r1	; 0x02

	// Write LED pin to reset and receive if there is any error from DIO
	Std_Return DIO_Return;
	DIO_Return = MCAL_DIO_WritePin(LED_Pin,DIO_Reset);
    4176:	6b 81       	ldd	r22, Y+3	; 0x03
    4178:	7c 81       	ldd	r23, Y+4	; 0x04
    417a:	8d 81       	ldd	r24, Y+5	; 0x05
    417c:	40 e0       	ldi	r20, 0x00	; 0
    417e:	0e 94 cb 1a 	call	0x3596	; 0x3596 <MCAL_DIO_WritePin>
    4182:	89 83       	std	Y+1, r24	; 0x01

	// There is error returned from DIO
	if(DIO_Return != OK) LED_ReturnError = INVALID_LED;
    4184:	89 81       	ldd	r24, Y+1	; 0x01
    4186:	88 23       	and	r24, r24
    4188:	11 f0       	breq	.+4      	; 0x418e <HAL_LED_Off+0x3a>
    418a:	84 e0       	ldi	r24, 0x04	; 4
    418c:	8a 83       	std	Y+2, r24	; 0x02

	return LED_ReturnError;
    418e:	8a 81       	ldd	r24, Y+2	; 0x02

}
    4190:	27 96       	adiw	r28, 0x07	; 7
    4192:	0f b6       	in	r0, 0x3f	; 63
    4194:	f8 94       	cli
    4196:	de bf       	out	0x3e, r29	; 62
    4198:	0f be       	out	0x3f, r0	; 63
    419a:	cd bf       	out	0x3d, r28	; 61
    419c:	cf 91       	pop	r28
    419e:	df 91       	pop	r29
    41a0:	08 95       	ret

000041a2 <HAL_LED_Toggle>:
 * 	@ Param [in] - LED: LED which is needed to be toggle.
 * 	@ RetVal	 - Std_Return.
 *	  Note		 - This API return "OK" when no error occurred,
 *	  			   return "INVALID_LED" when the entered LED is not valid.
 * ==================================================================== */
Std_Return HAL_LED_Toggle(LED_Type LED){
    41a2:	df 93       	push	r29
    41a4:	cf 93       	push	r28
    41a6:	cd b7       	in	r28, 0x3d	; 61
    41a8:	de b7       	in	r29, 0x3e	; 62
    41aa:	2a 97       	sbiw	r28, 0x0a	; 10
    41ac:	0f b6       	in	r0, 0x3f	; 63
    41ae:	f8 94       	cli
    41b0:	de bf       	out	0x3e, r29	; 62
    41b2:	0f be       	out	0x3f, r0	; 63
    41b4:	cd bf       	out	0x3d, r28	; 61
    41b6:	98 87       	std	Y+8, r25	; 0x08
    41b8:	8f 83       	std	Y+7, r24	; 0x07

	/*------ DIO Pin Configuration ------*/
	DIO_PinType LED_Pin;
	LED_Pin.Port = LED.Port;
    41ba:	8f 81       	ldd	r24, Y+7	; 0x07
    41bc:	8b 83       	std	Y+3, r24	; 0x03
	LED_Pin.Pin_Number = LED.Pin_Number;
    41be:	88 85       	ldd	r24, Y+8	; 0x08
    41c0:	8c 83       	std	Y+4, r24	; 0x04



	/*------- Get LED Pin Status -------*/
	// Initialize error status with no errors
	Std_Return LED_ReturnError = OK;
    41c2:	1a 82       	std	Y+2, r1	; 0x02

	// Get LED pin status and receive if there is any error from DIO
	Std_Return DIO_Return;
	DIO_StatusType LED_PinStatus;
	DIO_Return = MCAL_DIO_GetPin(LED_Pin,&LED_PinStatus);
    41c4:	9e 01       	movw	r18, r28
    41c6:	2a 5f       	subi	r18, 0xFA	; 250
    41c8:	3f 4f       	sbci	r19, 0xFF	; 255
    41ca:	6b 81       	ldd	r22, Y+3	; 0x03
    41cc:	7c 81       	ldd	r23, Y+4	; 0x04
    41ce:	8d 81       	ldd	r24, Y+5	; 0x05
    41d0:	a9 01       	movw	r20, r18
    41d2:	0e 94 5e 1c 	call	0x38bc	; 0x38bc <MCAL_DIO_GetPin>
    41d6:	89 83       	std	Y+1, r24	; 0x01



	/*----- Toggle LED Pin Status -----*/
	// Toggle LED pin status and receive if there is any error from DIO
	if(DIO_Return == OK){
    41d8:	89 81       	ldd	r24, Y+1	; 0x01
    41da:	88 23       	and	r24, r24
    41dc:	e9 f4       	brne	.+58     	; 0x4218 <HAL_LED_Toggle+0x76>
		switch(LED_PinStatus){
    41de:	8e 81       	ldd	r24, Y+6	; 0x06
    41e0:	28 2f       	mov	r18, r24
    41e2:	30 e0       	ldi	r19, 0x00	; 0
    41e4:	3a 87       	std	Y+10, r19	; 0x0a
    41e6:	29 87       	std	Y+9, r18	; 0x09
    41e8:	89 85       	ldd	r24, Y+9	; 0x09
    41ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    41ec:	00 97       	sbiw	r24, 0x00	; 0
    41ee:	69 f0       	breq	.+26     	; 0x420a <HAL_LED_Toggle+0x68>
    41f0:	29 85       	ldd	r18, Y+9	; 0x09
    41f2:	3a 85       	ldd	r19, Y+10	; 0x0a
    41f4:	21 30       	cpi	r18, 0x01	; 1
    41f6:	31 05       	cpc	r19, r1
    41f8:	79 f4       	brne	.+30     	; 0x4218 <HAL_LED_Toggle+0x76>

		case DIO_Set: DIO_Return = MCAL_DIO_WritePin(LED_Pin,DIO_Reset); break;
    41fa:	6b 81       	ldd	r22, Y+3	; 0x03
    41fc:	7c 81       	ldd	r23, Y+4	; 0x04
    41fe:	8d 81       	ldd	r24, Y+5	; 0x05
    4200:	40 e0       	ldi	r20, 0x00	; 0
    4202:	0e 94 cb 1a 	call	0x3596	; 0x3596 <MCAL_DIO_WritePin>
    4206:	89 83       	std	Y+1, r24	; 0x01
    4208:	07 c0       	rjmp	.+14     	; 0x4218 <HAL_LED_Toggle+0x76>
		case DIO_Reset: DIO_Return = MCAL_DIO_WritePin(LED_Pin,DIO_Set); break;
    420a:	6b 81       	ldd	r22, Y+3	; 0x03
    420c:	7c 81       	ldd	r23, Y+4	; 0x04
    420e:	8d 81       	ldd	r24, Y+5	; 0x05
    4210:	41 e0       	ldi	r20, 0x01	; 1
    4212:	0e 94 cb 1a 	call	0x3596	; 0x3596 <MCAL_DIO_WritePin>
    4216:	89 83       	std	Y+1, r24	; 0x01

		}
	}

	// There is error returned from DIO
	if(DIO_Return != OK) LED_ReturnError = INVALID_LED;
    4218:	89 81       	ldd	r24, Y+1	; 0x01
    421a:	88 23       	and	r24, r24
    421c:	11 f0       	breq	.+4      	; 0x4222 <HAL_LED_Toggle+0x80>
    421e:	84 e0       	ldi	r24, 0x04	; 4
    4220:	8a 83       	std	Y+2, r24	; 0x02

	return LED_ReturnError;
    4222:	8a 81       	ldd	r24, Y+2	; 0x02

}
    4224:	2a 96       	adiw	r28, 0x0a	; 10
    4226:	0f b6       	in	r0, 0x3f	; 63
    4228:	f8 94       	cli
    422a:	de bf       	out	0x3e, r29	; 62
    422c:	0f be       	out	0x3f, r0	; 63
    422e:	cd bf       	out	0x3d, r28	; 61
    4230:	cf 91       	pop	r28
    4232:	df 91       	pop	r29
    4234:	08 95       	ret

00004236 <HAL_Relay_Init>:
 *	  Note		 - This API return "OK" when no error occurred,
 *	  			   return "INVALID_PORT" when the entered port is not valid,
 *	  			   return "WRONG_PIN" when the entered pin is not valid,
 *	  			   return "UNKNOWN"	when there's unknown error.
 * ==================================================================== */
Std_Return HAL_Relay_Init(Relay_Type Relay){
    4236:	df 93       	push	r29
    4238:	cf 93       	push	r28
    423a:	00 d0       	rcall	.+0      	; 0x423c <HAL_Relay_Init+0x6>
    423c:	00 d0       	rcall	.+0      	; 0x423e <HAL_Relay_Init+0x8>
    423e:	00 d0       	rcall	.+0      	; 0x4240 <HAL_Relay_Init+0xa>
    4240:	cd b7       	in	r28, 0x3d	; 61
    4242:	de b7       	in	r29, 0x3e	; 62
    4244:	9e 83       	std	Y+6, r25	; 0x06
    4246:	8d 83       	std	Y+5, r24	; 0x05

	/*------ DIO Pin Configuration ------*/
	DIO_PinType Relay_Pin;
	Relay_Pin.Port = Relay.Port;
    4248:	8d 81       	ldd	r24, Y+5	; 0x05
    424a:	8a 83       	std	Y+2, r24	; 0x02
	Relay_Pin.Pin_Number = Relay.Pin_Number;
    424c:	8e 81       	ldd	r24, Y+6	; 0x06
    424e:	8b 83       	std	Y+3, r24	; 0x03
	Relay_Pin.Direction = DIO_Output;
    4250:	81 e0       	ldi	r24, 0x01	; 1
    4252:	8c 83       	std	Y+4, r24	; 0x04



	/*------ Set Pin as Output Pin ------*/
	Std_Return DIO_Return;
	DIO_Return = MCAL_DIO_SetPinDirection(Relay_Pin);
    4254:	6a 81       	ldd	r22, Y+2	; 0x02
    4256:	7b 81       	ldd	r23, Y+3	; 0x03
    4258:	8c 81       	ldd	r24, Y+4	; 0x04
    425a:	0e 94 40 19 	call	0x3280	; 0x3280 <MCAL_DIO_SetPinDirection>
    425e:	89 83       	std	Y+1, r24	; 0x01

	return DIO_Return;
    4260:	89 81       	ldd	r24, Y+1	; 0x01

}
    4262:	26 96       	adiw	r28, 0x06	; 6
    4264:	0f b6       	in	r0, 0x3f	; 63
    4266:	f8 94       	cli
    4268:	de bf       	out	0x3e, r29	; 62
    426a:	0f be       	out	0x3f, r0	; 63
    426c:	cd bf       	out	0x3d, r28	; 61
    426e:	cf 91       	pop	r28
    4270:	df 91       	pop	r29
    4272:	08 95       	ret

00004274 <HAL_Relay_On>:
 * 	@ Param [in] - Relay: Relay which is needed to be turn on.
 * 	@ RetVal	 - Std_Return.
 *	  Note		 - This API return "OK" when no error occurred,
 *	  			   return "INVALID_RELAY" when the entered Relay is not valid.
 * ==================================================================== */
Std_Return HAL_Relay_On(Relay_Type Relay){
    4274:	df 93       	push	r29
    4276:	cf 93       	push	r28
    4278:	cd b7       	in	r28, 0x3d	; 61
    427a:	de b7       	in	r29, 0x3e	; 62
    427c:	27 97       	sbiw	r28, 0x07	; 7
    427e:	0f b6       	in	r0, 0x3f	; 63
    4280:	f8 94       	cli
    4282:	de bf       	out	0x3e, r29	; 62
    4284:	0f be       	out	0x3f, r0	; 63
    4286:	cd bf       	out	0x3d, r28	; 61
    4288:	9f 83       	std	Y+7, r25	; 0x07
    428a:	8e 83       	std	Y+6, r24	; 0x06

	/*------ DIO Pin Configuration ------*/
	DIO_PinType Relay_Pin;
	Relay_Pin.Port = Relay.Port;
    428c:	8e 81       	ldd	r24, Y+6	; 0x06
    428e:	8b 83       	std	Y+3, r24	; 0x03
	Relay_Pin.Pin_Number = Relay.Pin_Number;
    4290:	8f 81       	ldd	r24, Y+7	; 0x07
    4292:	8c 83       	std	Y+4, r24	; 0x04



	/*---------- Set Relay Pin -----------*/
	// Initialize error status with no errors
	Std_Return Relay_ReturnError = OK;
    4294:	1a 82       	std	Y+2, r1	; 0x02

	// Write Relay pin to set and receive if there is any error from DIO
	Std_Return DIO_Return;
	DIO_Return = MCAL_DIO_WritePin(Relay_Pin,DIO_Set);
    4296:	6b 81       	ldd	r22, Y+3	; 0x03
    4298:	7c 81       	ldd	r23, Y+4	; 0x04
    429a:	8d 81       	ldd	r24, Y+5	; 0x05
    429c:	41 e0       	ldi	r20, 0x01	; 1
    429e:	0e 94 cb 1a 	call	0x3596	; 0x3596 <MCAL_DIO_WritePin>
    42a2:	89 83       	std	Y+1, r24	; 0x01

	// There is error returned from DIO
	if(DIO_Return != OK) Relay_ReturnError = INVALID_RELAY;
    42a4:	89 81       	ldd	r24, Y+1	; 0x01
    42a6:	88 23       	and	r24, r24
    42a8:	11 f0       	breq	.+4      	; 0x42ae <HAL_Relay_On+0x3a>
    42aa:	88 e0       	ldi	r24, 0x08	; 8
    42ac:	8a 83       	std	Y+2, r24	; 0x02

	return Relay_ReturnError;
    42ae:	8a 81       	ldd	r24, Y+2	; 0x02

}
    42b0:	27 96       	adiw	r28, 0x07	; 7
    42b2:	0f b6       	in	r0, 0x3f	; 63
    42b4:	f8 94       	cli
    42b6:	de bf       	out	0x3e, r29	; 62
    42b8:	0f be       	out	0x3f, r0	; 63
    42ba:	cd bf       	out	0x3d, r28	; 61
    42bc:	cf 91       	pop	r28
    42be:	df 91       	pop	r29
    42c0:	08 95       	ret

000042c2 <HAL_Relay_Off>:
 * 	@ Param [in] - Relay: Relay which is needed to be turn off.
 * 	@ RetVal	 - Std_Return.
 *	  Note		 - This API return "OK" when no error occurred,
 *	  			   return "INVALID_RELAY" when the entered Relay is not valid.
 * ==================================================================== */
Std_Return HAL_Relay_Off(Relay_Type Relay){
    42c2:	df 93       	push	r29
    42c4:	cf 93       	push	r28
    42c6:	cd b7       	in	r28, 0x3d	; 61
    42c8:	de b7       	in	r29, 0x3e	; 62
    42ca:	27 97       	sbiw	r28, 0x07	; 7
    42cc:	0f b6       	in	r0, 0x3f	; 63
    42ce:	f8 94       	cli
    42d0:	de bf       	out	0x3e, r29	; 62
    42d2:	0f be       	out	0x3f, r0	; 63
    42d4:	cd bf       	out	0x3d, r28	; 61
    42d6:	9f 83       	std	Y+7, r25	; 0x07
    42d8:	8e 83       	std	Y+6, r24	; 0x06

	/*------ DIO Pin Configuration ------*/
	DIO_PinType Relay_Pin;
	Relay_Pin.Port = Relay.Port;
    42da:	8e 81       	ldd	r24, Y+6	; 0x06
    42dc:	8b 83       	std	Y+3, r24	; 0x03
	Relay_Pin.Pin_Number = Relay.Pin_Number;
    42de:	8f 81       	ldd	r24, Y+7	; 0x07
    42e0:	8c 83       	std	Y+4, r24	; 0x04



	/*---------- Set Relay Pin -----------*/
	// Initialize error status with no errors
	Std_Return Relay_ReturnError = OK;
    42e2:	1a 82       	std	Y+2, r1	; 0x02

	// Write Relay pin to set and receive if there is any error from DIO
	Std_Return DIO_Return;
	DIO_Return = MCAL_DIO_WritePin(Relay_Pin,DIO_Reset);
    42e4:	6b 81       	ldd	r22, Y+3	; 0x03
    42e6:	7c 81       	ldd	r23, Y+4	; 0x04
    42e8:	8d 81       	ldd	r24, Y+5	; 0x05
    42ea:	40 e0       	ldi	r20, 0x00	; 0
    42ec:	0e 94 cb 1a 	call	0x3596	; 0x3596 <MCAL_DIO_WritePin>
    42f0:	89 83       	std	Y+1, r24	; 0x01

	// There is error returned from DIO
	if(DIO_Return != OK) Relay_ReturnError = INVALID_RELAY;
    42f2:	89 81       	ldd	r24, Y+1	; 0x01
    42f4:	88 23       	and	r24, r24
    42f6:	11 f0       	breq	.+4      	; 0x42fc <HAL_Relay_Off+0x3a>
    42f8:	88 e0       	ldi	r24, 0x08	; 8
    42fa:	8a 83       	std	Y+2, r24	; 0x02

	return Relay_ReturnError;
    42fc:	8a 81       	ldd	r24, Y+2	; 0x02

}
    42fe:	27 96       	adiw	r28, 0x07	; 7
    4300:	0f b6       	in	r0, 0x3f	; 63
    4302:	f8 94       	cli
    4304:	de bf       	out	0x3e, r29	; 62
    4306:	0f be       	out	0x3f, r0	; 63
    4308:	cd bf       	out	0x3d, r28	; 61
    430a:	cf 91       	pop	r28
    430c:	df 91       	pop	r29
    430e:	08 95       	ret

00004310 <__udivmodsi4>:
    4310:	a1 e2       	ldi	r26, 0x21	; 33
    4312:	1a 2e       	mov	r1, r26
    4314:	aa 1b       	sub	r26, r26
    4316:	bb 1b       	sub	r27, r27
    4318:	fd 01       	movw	r30, r26
    431a:	0d c0       	rjmp	.+26     	; 0x4336 <__udivmodsi4_ep>

0000431c <__udivmodsi4_loop>:
    431c:	aa 1f       	adc	r26, r26
    431e:	bb 1f       	adc	r27, r27
    4320:	ee 1f       	adc	r30, r30
    4322:	ff 1f       	adc	r31, r31
    4324:	a2 17       	cp	r26, r18
    4326:	b3 07       	cpc	r27, r19
    4328:	e4 07       	cpc	r30, r20
    432a:	f5 07       	cpc	r31, r21
    432c:	20 f0       	brcs	.+8      	; 0x4336 <__udivmodsi4_ep>
    432e:	a2 1b       	sub	r26, r18
    4330:	b3 0b       	sbc	r27, r19
    4332:	e4 0b       	sbc	r30, r20
    4334:	f5 0b       	sbc	r31, r21

00004336 <__udivmodsi4_ep>:
    4336:	66 1f       	adc	r22, r22
    4338:	77 1f       	adc	r23, r23
    433a:	88 1f       	adc	r24, r24
    433c:	99 1f       	adc	r25, r25
    433e:	1a 94       	dec	r1
    4340:	69 f7       	brne	.-38     	; 0x431c <__udivmodsi4_loop>
    4342:	60 95       	com	r22
    4344:	70 95       	com	r23
    4346:	80 95       	com	r24
    4348:	90 95       	com	r25
    434a:	9b 01       	movw	r18, r22
    434c:	ac 01       	movw	r20, r24
    434e:	bd 01       	movw	r22, r26
    4350:	cf 01       	movw	r24, r30
    4352:	08 95       	ret

00004354 <atoi>:
    4354:	fc 01       	movw	r30, r24
    4356:	88 27       	eor	r24, r24
    4358:	99 27       	eor	r25, r25
    435a:	e8 94       	clt
    435c:	21 91       	ld	r18, Z+
    435e:	20 32       	cpi	r18, 0x20	; 32
    4360:	e9 f3       	breq	.-6      	; 0x435c <atoi+0x8>
    4362:	29 30       	cpi	r18, 0x09	; 9
    4364:	10 f0       	brcs	.+4      	; 0x436a <atoi+0x16>
    4366:	2e 30       	cpi	r18, 0x0E	; 14
    4368:	c8 f3       	brcs	.-14     	; 0x435c <atoi+0x8>
    436a:	2b 32       	cpi	r18, 0x2B	; 43
    436c:	41 f0       	breq	.+16     	; 0x437e <atoi+0x2a>
    436e:	2d 32       	cpi	r18, 0x2D	; 45
    4370:	39 f4       	brne	.+14     	; 0x4380 <atoi+0x2c>
    4372:	68 94       	set
    4374:	04 c0       	rjmp	.+8      	; 0x437e <atoi+0x2a>
    4376:	0e 94 f7 21 	call	0x43ee	; 0x43ee <__mulhi_const_10>
    437a:	82 0f       	add	r24, r18
    437c:	91 1d       	adc	r25, r1
    437e:	21 91       	ld	r18, Z+
    4380:	20 53       	subi	r18, 0x30	; 48
    4382:	2a 30       	cpi	r18, 0x0A	; 10
    4384:	c0 f3       	brcs	.-16     	; 0x4376 <atoi+0x22>
    4386:	1e f4       	brtc	.+6      	; 0x438e <atoi+0x3a>
    4388:	90 95       	com	r25
    438a:	81 95       	neg	r24
    438c:	9f 4f       	sbci	r25, 0xFF	; 255
    438e:	08 95       	ret

00004390 <memcpy>:
    4390:	fb 01       	movw	r30, r22
    4392:	dc 01       	movw	r26, r24
    4394:	02 c0       	rjmp	.+4      	; 0x439a <memcpy+0xa>
    4396:	01 90       	ld	r0, Z+
    4398:	0d 92       	st	X+, r0
    439a:	41 50       	subi	r20, 0x01	; 1
    439c:	50 40       	sbci	r21, 0x00	; 0
    439e:	d8 f7       	brcc	.-10     	; 0x4396 <memcpy+0x6>
    43a0:	08 95       	ret

000043a2 <memset>:
    43a2:	dc 01       	movw	r26, r24
    43a4:	01 c0       	rjmp	.+2      	; 0x43a8 <memset+0x6>
    43a6:	6d 93       	st	X+, r22
    43a8:	41 50       	subi	r20, 0x01	; 1
    43aa:	50 40       	sbci	r21, 0x00	; 0
    43ac:	e0 f7       	brcc	.-8      	; 0x43a6 <memset+0x4>
    43ae:	08 95       	ret

000043b0 <strcmp>:
    43b0:	fb 01       	movw	r30, r22
    43b2:	dc 01       	movw	r26, r24
    43b4:	8d 91       	ld	r24, X+
    43b6:	01 90       	ld	r0, Z+
    43b8:	80 19       	sub	r24, r0
    43ba:	01 10       	cpse	r0, r1
    43bc:	d9 f3       	breq	.-10     	; 0x43b4 <strcmp+0x4>
    43be:	99 0b       	sbc	r25, r25
    43c0:	08 95       	ret

000043c2 <strcpy>:
    43c2:	fb 01       	movw	r30, r22
    43c4:	dc 01       	movw	r26, r24
    43c6:	01 90       	ld	r0, Z+
    43c8:	0d 92       	st	X+, r0
    43ca:	00 20       	and	r0, r0
    43cc:	e1 f7       	brne	.-8      	; 0x43c6 <strcpy+0x4>
    43ce:	08 95       	ret

000043d0 <strncpy>:
    43d0:	fb 01       	movw	r30, r22
    43d2:	dc 01       	movw	r26, r24
    43d4:	41 50       	subi	r20, 0x01	; 1
    43d6:	50 40       	sbci	r21, 0x00	; 0
    43d8:	48 f0       	brcs	.+18     	; 0x43ec <strncpy+0x1c>
    43da:	01 90       	ld	r0, Z+
    43dc:	0d 92       	st	X+, r0
    43de:	00 20       	and	r0, r0
    43e0:	c9 f7       	brne	.-14     	; 0x43d4 <strncpy+0x4>
    43e2:	01 c0       	rjmp	.+2      	; 0x43e6 <strncpy+0x16>
    43e4:	1d 92       	st	X+, r1
    43e6:	41 50       	subi	r20, 0x01	; 1
    43e8:	50 40       	sbci	r21, 0x00	; 0
    43ea:	e0 f7       	brcc	.-8      	; 0x43e4 <strncpy+0x14>
    43ec:	08 95       	ret

000043ee <__mulhi_const_10>:
    43ee:	7a e0       	ldi	r23, 0x0A	; 10
    43f0:	97 9f       	mul	r25, r23
    43f2:	90 2d       	mov	r25, r0
    43f4:	87 9f       	mul	r24, r23
    43f6:	80 2d       	mov	r24, r0
    43f8:	91 0d       	add	r25, r1
    43fa:	11 24       	eor	r1, r1
    43fc:	08 95       	ret

000043fe <_exit>:
    43fe:	f8 94       	cli

00004400 <__stop_program>:
    4400:	ff cf       	rjmp	.-2      	; 0x4400 <__stop_program>
